-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Facilities for manipulating Haskell source code using Template
--   Haskell.
@package template-haskell


-- | Abstract syntax definitions for Template Haskell.
module Language.Haskell.TH.Syntax.Internals
newtype ModName
ModName :: String -> ModName
newtype PkgName
PkgName :: String -> PkgName
newtype OccName
OccName :: String -> OccName
instance Typeable ModName
instance Typeable PkgName
instance Typeable OccName
instance Eq ModName
instance Ord ModName
instance Data ModName
instance Eq PkgName
instance Ord PkgName
instance Data PkgName
instance Eq OccName
instance Ord OccName
instance Data OccName


-- | Abstract syntax definitions for Template Haskell.
module Language.Haskell.TH.Syntax
class (Monad m, Applicative m) => Quasi m
qNewName :: Quasi m => String -> m Name
qReport :: Quasi m => Bool -> String -> m ()
qRecover :: Quasi m => m a -> m a -> m a
qLookupName :: Quasi m => Bool -> String -> m (Maybe Name)
qReify :: Quasi m => Name -> m Info
qReifyInstances :: Quasi m => Name -> [Type] -> m [Dec]
qLocation :: Quasi m => m Loc
qRunIO :: Quasi m => IO a -> m a
qAddDependentFile :: Quasi m => FilePath -> m ()
class Lift t
lift :: Lift t => t -> Q Exp
liftString :: String -> Q Exp
data Q a
runQ :: Quasi m => Q a -> m a
report :: Bool -> String -> Q ()
recover :: Q a -> Q a -> Q a

-- | <a>reify</a> looks up information about the <a>Name</a>
reify :: Name -> Q Info
lookupTypeName :: String -> Q (Maybe Name)
lookupValueName :: String -> Q (Maybe Name)

-- | <a>location</a> gives you the <tt>Location</tt> at which this
--   computation is spliced.
location :: Q Loc

-- | The <a>runIO</a> function lets you run an I/O computation in the
--   <a>Q</a> monad. Take care: you are guaranteed the ordering of calls to
--   <a>runIO</a> within a single <a>Q</a> computation, but not about the
--   order in which splices are run.
--   
--   Note: for various murky reasons, stdout and stderr handles are not
--   necesarily flushed when the compiler finishes running, so you should
--   flush them yourself.
runIO :: IO a -> Q a

-- | Record external files that runIO is using (dependent upon). The
--   compiler can then recognize that it should re-compile the file using
--   this TH when the external file changes. Note that ghc -M will still
--   not know about these dependencies - it does not execute TH. Expects an
--   absolute file path.
addDependentFile :: FilePath -> Q ()
isInstance :: Name -> [Type] -> Q Bool

-- | <tt>classInstances</tt> looks up instaces of a class
reifyInstances :: Name -> [Type] -> Q [Dec]

-- | For <a>global</a> names (<a>NameG</a>) we need a totally unique name,
--   so we must include the name-space of the thing
--   
--   For unique-numbered things (<a>NameU</a>), we've got a unique
--   reference anyway, so no need for name space
--   
--   For dynamically bound thing (<a>NameS</a>) we probably want them to in
--   a context-dependent way, so again we don't want the name space. For
--   example:
--   
--   <pre>
--   let v = mkName "T" in [| data $v = $v |]
--   </pre>
--   
--   Here we use the same Name for both type constructor and data
--   constructor
--   
--   NameL and NameG are bound *outside* the TH syntax tree either globally
--   (NameG) or locally (NameL). Ex:
--   
--   <pre>
--   f x = $(h [| (map, x) |])
--   </pre>
--   
--   The <a>map</a> will be a NameG, and <tt>x</tt> wil be a NameL
--   
--   These Names should never appear in a binding position in a TH syntax
--   tree
data Name
Name :: OccName -> NameFlavour -> Name

-- | The string can have a <a>.</a>, thus <a>Foo.baz</a>, giving a
--   dynamically-bound qualified name, in which case we want to generate a
--   NameQ
--   
--   Parse the string to see if it has a <a>.</a> in it so we know whether
--   to generate a qualified or unqualified name It's a bit tricky because
--   we need to parse
--   
--   <pre>
--   Foo.Baz.x   as    Qual Foo.Baz x
--   </pre>
--   
--   So we parse it from back to front
mkName :: String -> Name
newName :: String -> Q Name

-- | Base, unqualified name.
nameBase :: Name -> String
nameModule :: Name -> Maybe String
showName :: Name -> String
showName' :: NameIs -> Name -> String
data NameIs
Alone :: NameIs
Applied :: NameIs
Infix :: NameIs
data Dec

-- | <pre>
--   { f p1 p2 = b where decs }
--   </pre>
FunD :: Name -> [Clause] -> Dec

-- | <pre>
--   { p = b where decs }
--   </pre>
ValD :: Pat -> Body -> [Dec] -> Dec

-- | <pre>
--   { data Cxt x =&gt; T x = A x | B (T x)
--          deriving (Z,W)}
--   </pre>
DataD :: Cxt -> Name -> [TyVarBndr] -> [Con] -> [Name] -> Dec

-- | <pre>
--   { newtype Cxt x =&gt; T x = A (B x)
--          deriving (Z,W)}
--   </pre>
NewtypeD :: Cxt -> Name -> [TyVarBndr] -> Con -> [Name] -> Dec

-- | <pre>
--   { type T x = (x,x) }
--   </pre>
TySynD :: Name -> [TyVarBndr] -> Type -> Dec

-- | <pre>
--   { class Eq a =&gt; Ord a where ds }
--   </pre>
ClassD :: Cxt -> Name -> [TyVarBndr] -> [FunDep] -> [Dec] -> Dec

-- | <pre>
--   { instance Show w =&gt; Show [w]
--          where ds }
--   </pre>
InstanceD :: Cxt -> Type -> [Dec] -> Dec

-- | <pre>
--   { length :: [a] -&gt; Int }
--   </pre>
SigD :: Name -> Type -> Dec
ForeignD :: Foreign -> Dec

-- | <pre>
--   { {--} }
--   </pre>
PragmaD :: Pragma -> Dec

-- | <pre>
--   { type family T a b c :: * }
--   </pre>
FamilyD :: FamFlavour -> Name -> [TyVarBndr] -> (Maybe Kind) -> Dec

-- | <pre>
--   { data instance Cxt x =&gt; T [x] = A x 
--                                   | B (T x)
--          deriving (Z,W)}
--   </pre>
DataInstD :: Cxt -> Name -> [Type] -> [Con] -> [Name] -> Dec

-- | <pre>
--   { newtype instance Cxt x =&gt; T [x] = A (B x)
--          deriving (Z,W)}
--   </pre>
NewtypeInstD :: Cxt -> Name -> [Type] -> Con -> [Name] -> Dec

-- | <pre>
--   { type instance T (Maybe x) = (x,x) }
--   </pre>
TySynInstD :: Name -> [Type] -> Type -> Dec

-- | The <a>CompE</a> constructor represents a list comprehension, and
--   takes a [<a>Stmt</a>]. The result expression of the comprehension is
--   the *last* of these, and should be a <a>NoBindS</a>.
--   
--   E.g. translation:
--   
--   <pre>
--   [ f x | x &lt;- xs ]
--   </pre>
--   
--   <pre>
--   CompE [BindS (VarP x) (VarE xs), NoBindS (AppE (VarE f) (VarE x))]
--   </pre>
data Exp

-- | <pre>
--   { x }
--   </pre>
VarE :: Name -> Exp

-- | <pre>
--   data T1 = C1 t1 t2; p = {C1} e1 e2
--   </pre>
ConE :: Name -> Exp

-- | <pre>
--   { 5 or <tt>c</tt>}
--   </pre>
LitE :: Lit -> Exp

-- | <pre>
--   { f x }
--   </pre>
AppE :: Exp -> Exp -> Exp

-- | <pre>
--   {x + y} or {(x+)} or {(+ x)} or {(+)}
--   </pre>
--   
--   It's a bit gruesome to use an Exp as the operator, but how else can we
--   distinguish constructors from non-constructors? Maybe there should be
--   a var-or-con type? Or maybe we should leave it to the String itself?
InfixE :: (Maybe Exp) -> Exp -> (Maybe Exp) -> Exp

-- | <pre>
--   {x + y}
--   </pre>
--   
--   See Note [Unresolved infix] at <a>Language.Haskell.TH.Syntax#infix</a>
UInfixE :: Exp -> Exp -> Exp -> Exp

-- | <pre>
--   { (e) }
--   </pre>
--   
--   See Note [Unresolved infix] at <a>Language.Haskell.TH.Syntax#infix</a>
ParensE :: Exp -> Exp

-- | <pre>
--   {  p1 p2 -&gt; e }
--   </pre>
LamE :: [Pat] -> Exp -> Exp

-- | <pre>
--   { (e1,e2) }
--   </pre>
TupE :: [Exp] -> Exp

-- | <pre>
--   { () }
--   </pre>
UnboxedTupE :: [Exp] -> Exp

-- | <pre>
--   { if e1 then e2 else e3 }
--   </pre>
CondE :: Exp -> Exp -> Exp -> Exp

-- | <pre>
--   { let x=e1;   y=e2 in e3 }
--   </pre>
LetE :: [Dec] -> Exp -> Exp

-- | <pre>
--   { case e of m1; m2 }
--   </pre>
CaseE :: Exp -> [Match] -> Exp

-- | <pre>
--   { do { p &lt;- e1; e2 }  }
--   </pre>
DoE :: [Stmt] -> Exp

-- | <pre>
--   { [ (x,y) | x &lt;- xs, y &lt;- ys ] }
--   </pre>
CompE :: [Stmt] -> Exp

-- | <pre>
--   { [ 1 ,2 .. 10 ] }
--   </pre>
ArithSeqE :: Range -> Exp

-- | <pre>
--   { [1,2,3] }
--   </pre>
ListE :: [Exp] -> Exp

-- | <pre>
--   { e :: t }
--   </pre>
SigE :: Exp -> Type -> Exp

-- | <pre>
--   { T { x = y, z = w } }
--   </pre>
RecConE :: Name -> [FieldExp] -> Exp

-- | <pre>
--   { (f x) { z = w } }
--   </pre>
RecUpdE :: Exp -> [FieldExp] -> Exp
data Con

-- | <pre>
--   C Int a
--   </pre>
NormalC :: Name -> [StrictType] -> Con

-- | <pre>
--   C { v :: Int, w :: a }
--   </pre>
RecC :: Name -> [VarStrictType] -> Con

-- | <pre>
--   Int :+ a
--   </pre>
InfixC :: StrictType -> Name -> StrictType -> Con

-- | <pre>
--   forall a. Eq a =&gt; C [a]
--   </pre>
ForallC :: [TyVarBndr] -> Cxt -> Con -> Con
data Type

-- | <pre>
--   forall <a>vars</a>. <a>ctxt</a> -&gt; <a>type</a>
--   </pre>
ForallT :: [TyVarBndr] -> Cxt -> Type -> Type

-- | <pre>
--   a
--   </pre>
VarT :: Name -> Type

-- | <pre>
--   T
--   </pre>
ConT :: Name -> Type

-- | <pre>
--   (,), (,,), etc.
--   </pre>
TupleT :: Int -> Type

-- | <pre>
--   (), (), etc.
--   </pre>
UnboxedTupleT :: Int -> Type

-- | <pre>
--   -&gt;
--   </pre>
ArrowT :: Type

-- | <pre>
--   []
--   </pre>
ListT :: Type

-- | <pre>
--   T a b
--   </pre>
AppT :: Type -> Type -> Type

-- | <pre>
--   t :: k
--   </pre>
SigT :: Type -> Kind -> Type
data TyVarBndr

-- | <pre>
--   a
--   </pre>
PlainTV :: Name -> TyVarBndr

-- | <pre>
--   (a :: k)
--   </pre>
KindedTV :: Name -> Kind -> TyVarBndr
data Kind

-- | <pre>
--   <a>*</a>
--   </pre>
StarK :: Kind

-- | <pre>
--   k1 -&gt; k2
--   </pre>
ArrowK :: Kind -> Kind -> Kind
type Cxt = [Pred]
data Pred

-- | <pre>
--   Eq (Int, a)
--   </pre>
ClassP :: Name -> [Type] -> Pred

-- | <pre>
--   F a ~ Bool
--   </pre>
EqualP :: Type -> Type -> Pred
data Match

-- | <pre>
--   case e of { pat -&gt; body where decs }
--   </pre>
Match :: Pat -> Body -> [Dec] -> Match
data Clause

-- | <pre>
--   f { p1 p2 = body where decs }
--   </pre>
Clause :: [Pat] -> Body -> [Dec] -> Clause
data Body

-- | <pre>
--   f p { | e1 = e2 | e3 = e4 } where ds
--   </pre>
GuardedB :: [(Guard, Exp)] -> Body

-- | <pre>
--   f p { = e } where ds
--   </pre>
NormalB :: Exp -> Body
data Guard
NormalG :: Exp -> Guard
PatG :: [Stmt] -> Guard
data Stmt
BindS :: Pat -> Exp -> Stmt
LetS :: [Dec] -> Stmt
NoBindS :: Exp -> Stmt
ParS :: [[Stmt]] -> Stmt
data Range
FromR :: Exp -> Range
FromThenR :: Exp -> Exp -> Range
FromToR :: Exp -> Exp -> Range
FromThenToR :: Exp -> Exp -> Exp -> Range
data Lit
CharL :: Char -> Lit
StringL :: String -> Lit

-- | Used for overloaded and non-overloaded literals. We don't have a good
--   way to represent non-overloaded literals at the moment. Maybe that
--   doesn't matter?
IntegerL :: Integer -> Lit
RationalL :: Rational -> Lit
IntPrimL :: Integer -> Lit
WordPrimL :: Integer -> Lit
FloatPrimL :: Rational -> Lit
DoublePrimL :: Rational -> Lit

-- | A primitive C-style string, type Addr#
StringPrimL :: String -> Lit

-- | Pattern in Haskell given in <tt>{}</tt>
data Pat

-- | <pre>
--   { 5 or <tt>c</tt> }
--   </pre>
LitP :: Lit -> Pat

-- | <pre>
--   { x }
--   </pre>
VarP :: Name -> Pat

-- | <pre>
--   { (p1,p2) }
--   </pre>
TupP :: [Pat] -> Pat

-- | <pre>
--   { () }
--   </pre>
UnboxedTupP :: [Pat] -> Pat

-- | <pre>
--   data T1 = C1 t1 t2; {C1 p1 p1} = e
--   </pre>
ConP :: Name -> [Pat] -> Pat

-- | <pre>
--   foo ({x :+ y}) = e
--   </pre>
InfixP :: Pat -> Name -> Pat -> Pat

-- | <pre>
--   foo ({x :+ y}) = e
--   </pre>
--   
--   See Note [Unresolved infix] at <a>Language.Haskell.TH.Syntax#infix</a>
UInfixP :: Pat -> Name -> Pat -> Pat

-- | <pre>
--   {(p)}
--   </pre>
--   
--   See Note [Unresolved infix] at <a>Language.Haskell.TH.Syntax#infix</a>
ParensP :: Pat -> Pat

-- | <pre>
--   { ~p }
--   </pre>
TildeP :: Pat -> Pat

-- | <pre>
--   { !p }
--   </pre>
BangP :: Pat -> Pat

-- | <pre>
--   { x @ p }
--   </pre>
AsP :: Name -> Pat -> Pat

-- | <pre>
--   { _ }
--   </pre>
WildP :: Pat

-- | <pre>
--   f (Pt { pointx = x }) = g x
--   </pre>
RecP :: Name -> [FieldPat] -> Pat

-- | <pre>
--   { [1,2,3] }
--   </pre>
ListP :: [Pat] -> Pat

-- | <pre>
--   { p :: t }
--   </pre>
SigP :: Pat -> Type -> Pat

-- | <pre>
--   { e -&gt; p }
--   </pre>
ViewP :: Exp -> Pat -> Pat
type FieldExp = (Name, Exp)
type FieldPat = (Name, Pat)
data Strict
IsStrict :: Strict
NotStrict :: Strict
Unpacked :: Strict
data Foreign
ImportF :: Callconv -> Safety -> String -> Name -> Type -> Foreign
ExportF :: Callconv -> String -> Name -> Type -> Foreign
data Callconv
CCall :: Callconv
StdCall :: Callconv
data Safety
Unsafe :: Safety
Safe :: Safety
Interruptible :: Safety
data Pragma
InlineP :: Name -> InlineSpec -> Pragma
SpecialiseP :: Name -> Type -> (Maybe InlineSpec) -> Pragma
data InlineSpec
InlineSpec :: Bool -> Bool -> (Maybe (Bool, Int)) -> InlineSpec
type StrictType = (Strict, Type)
type VarStrictType = (Name, Strict, Type)
data FunDep
FunDep :: [Name] -> [Name] -> FunDep
data FamFlavour
TypeFam :: FamFlavour
DataFam :: FamFlavour

-- | Obtained from <a>reify</a> in the <a>Q</a> Monad.
data Info

-- | A class is reified to its declaration and a list of its instances
ClassI :: Dec -> [InstanceDec] -> Info
ClassOpI :: Name -> Type -> Name -> Fixity -> Info
TyConI :: Dec -> Info
FamilyI :: Dec -> [InstanceDec] -> Info
PrimTyConI :: Name -> Int -> Bool -> Info
DataConI :: Name -> Type -> Name -> Fixity -> Info
VarI :: Name -> Type -> (Maybe Dec) -> Fixity -> Info
TyVarI :: Name -> Type -> Info
data Loc
Loc :: String -> String -> String -> CharPos -> CharPos -> Loc
loc_filename :: Loc -> String
loc_package :: Loc -> String
loc_module :: Loc -> String
loc_start :: Loc -> CharPos
loc_end :: Loc -> CharPos
type CharPos = (Int, Int)
data Fixity
Fixity :: Int -> FixityDirection -> Fixity
data FixityDirection
InfixL :: FixityDirection
InfixR :: FixityDirection
InfixN :: FixityDirection
defaultFixity :: Fixity
maxPrecedence :: Int
returnQ :: a -> Q a
bindQ :: Q a -> (a -> Q b) -> Q b
sequenceQ :: [Q a] -> Q [a]
data NameFlavour

-- | An unqualified name; dynamically bound
NameS :: NameFlavour

-- | A qualified name; dynamically bound
NameQ :: ModName -> NameFlavour

-- | A unique local name
NameU :: Int# -> NameFlavour

-- | Local name bound outside of the TH AST
NameL :: Int# -> NameFlavour

-- | Global name bound outside of the TH AST: An original name (occurrences
--   only, not binders) Need the namespace too to be sure which thing we
--   are naming
NameG :: NameSpace -> PkgName -> ModName -> NameFlavour
data NameSpace

-- | Variables
VarName :: NameSpace

-- | Data constructors
DataName :: NameSpace

-- | Type constructors and classes; Haskell has them in the same name space
--   for now.
TcClsName :: NameSpace
mkNameG_v :: String -> String -> String -> Name
mkNameG_d :: String -> String -> String -> Name
mkNameG_tc :: String -> String -> String -> Name
type Uniq = Int

-- | Only used internally
mkNameL :: String -> Uniq -> Name

-- | Only used internally
mkNameU :: String -> Uniq -> Name
tupleTypeName :: Int -> Name
tupleDataName :: Int -> Name
unboxedTupleTypeName :: Int -> Name
unboxedTupleDataName :: Int -> Name
data OccName
mkOccName :: String -> OccName
occString :: OccName -> String
data ModName
mkModName :: String -> ModName
modString :: ModName -> String
data PkgName
mkPkgName :: String -> PkgName
pkgString :: PkgName -> String
instance Typeable NameSpace
instance Typeable NameFlavour
instance Typeable FixityDirection
instance Typeable Fixity
instance Typeable Lit
instance Typeable FamFlavour
instance Typeable Callconv
instance Typeable Safety
instance Typeable InlineSpec
instance Typeable Strict
instance Typeable Kind
instance Typeable Name
instance Typeable FunDep
instance Typeable TyVarBndr
instance Typeable Type
instance Typeable Pred
instance Typeable Con
instance Typeable Pragma
instance Typeable Foreign
instance Typeable Exp
instance Typeable Match
instance Typeable Pat
instance Typeable Dec
instance Typeable Clause
instance Typeable Body
instance Typeable Guard
instance Typeable Stmt
instance Typeable Range
instance Typeable Info
instance Eq NameSpace
instance Ord NameSpace
instance Data NameSpace
instance Eq FixityDirection
instance Show FixityDirection
instance Data FixityDirection
instance Eq Fixity
instance Show Fixity
instance Data Fixity
instance Show Lit
instance Eq Lit
instance Data Lit
instance Show FamFlavour
instance Eq FamFlavour
instance Data FamFlavour
instance Show Callconv
instance Eq Callconv
instance Data Callconv
instance Show Safety
instance Eq Safety
instance Data Safety
instance Show InlineSpec
instance Eq InlineSpec
instance Data InlineSpec
instance Show Strict
instance Eq Strict
instance Data Strict
instance Show Kind
instance Eq Kind
instance Data Kind
instance Data Name
instance Show FunDep
instance Eq FunDep
instance Data FunDep
instance Show TyVarBndr
instance Eq TyVarBndr
instance Data TyVarBndr
instance Show Type
instance Eq Type
instance Data Type
instance Show Pred
instance Eq Pred
instance Data Pred
instance Show Con
instance Eq Con
instance Data Con
instance Show Pragma
instance Eq Pragma
instance Data Pragma
instance Show Foreign
instance Eq Foreign
instance Data Foreign
instance Show Exp
instance Eq Exp
instance Data Exp
instance Show Match
instance Eq Match
instance Data Match
instance Show Pat
instance Eq Pat
instance Data Pat
instance Show Dec
instance Eq Dec
instance Data Dec
instance Show Clause
instance Eq Clause
instance Data Clause
instance Show Body
instance Eq Body
instance Data Body
instance Show Guard
instance Eq Guard
instance Data Guard
instance Show Stmt
instance Eq Stmt
instance Data Stmt
instance Show Range
instance Eq Range
instance Data Range
instance Show Info
instance Data Info
instance Show Name
instance Ord NameFlavour
instance Eq NameFlavour
instance Ord Name
instance Eq Name
instance Data NameFlavour
instance (Lift a, Lift b, Lift c, Lift d, Lift e, Lift f, Lift g) => Lift (a, b, c, d, e, f, g)
instance (Lift a, Lift b, Lift c, Lift d, Lift e, Lift f) => Lift (a, b, c, d, e, f)
instance (Lift a, Lift b, Lift c, Lift d, Lift e) => Lift (a, b, c, d, e)
instance (Lift a, Lift b, Lift c, Lift d) => Lift (a, b, c, d)
instance (Lift a, Lift b, Lift c) => Lift (a, b, c)
instance (Lift a, Lift b) => Lift (a, b)
instance Lift a => Lift [a]
instance (Lift a, Lift b) => Lift (Either a b)
instance Lift a => Lift (Maybe a)
instance Lift Bool
instance Lift Char
instance Lift Int
instance Lift Integer
instance Quasi Q
instance Applicative Q
instance Functor Q
instance Monad Q
instance Quasi IO


-- | TH.Lib contains lots of useful helper functions for generating and
--   manipulating Template Haskell terms
module Language.Haskell.TH.Lib
type InfoQ = Q Info
type PatQ = Q Pat
type FieldPatQ = Q FieldPat
type ExpQ = Q Exp
type DecQ = Q Dec
type DecsQ = Q [Dec]
type ConQ = Q Con
type TypeQ = Q Type
type CxtQ = Q Cxt
type PredQ = Q Pred
type MatchQ = Q Match
type ClauseQ = Q Clause
type BodyQ = Q Body
type GuardQ = Q Guard
type StmtQ = Q Stmt
type RangeQ = Q Range
type StrictTypeQ = Q StrictType
type VarStrictTypeQ = Q VarStrictType
type FieldExpQ = Q FieldExp
type InlineSpecQ = Q InlineSpec
intPrimL :: Integer -> Lit
wordPrimL :: Integer -> Lit
floatPrimL :: Rational -> Lit
doublePrimL :: Rational -> Lit
integerL :: Integer -> Lit
charL :: Char -> Lit
stringL :: String -> Lit
stringPrimL :: String -> Lit
rationalL :: Rational -> Lit
litP :: Lit -> PatQ
varP :: Name -> PatQ
tupP :: [PatQ] -> PatQ
unboxedTupP :: [PatQ] -> PatQ
conP :: Name -> [PatQ] -> PatQ
infixP :: PatQ -> Name -> PatQ -> PatQ
uInfixP :: PatQ -> Name -> PatQ -> PatQ
parensP :: PatQ -> PatQ
tildeP :: PatQ -> PatQ
bangP :: PatQ -> PatQ
asP :: Name -> PatQ -> PatQ
wildP :: PatQ
recP :: Name -> [FieldPatQ] -> PatQ
listP :: [PatQ] -> PatQ
sigP :: PatQ -> TypeQ -> PatQ
viewP :: ExpQ -> PatQ -> PatQ
fieldPat :: Name -> PatQ -> FieldPatQ
bindS :: PatQ -> ExpQ -> StmtQ
letS :: [DecQ] -> StmtQ
noBindS :: ExpQ -> StmtQ
parS :: [[StmtQ]] -> StmtQ
fromR :: ExpQ -> RangeQ
fromThenR :: ExpQ -> ExpQ -> RangeQ
fromToR :: ExpQ -> ExpQ -> RangeQ
fromThenToR :: ExpQ -> ExpQ -> ExpQ -> RangeQ
normalB :: ExpQ -> BodyQ
guardedB :: [Q (Guard, Exp)] -> BodyQ
normalG :: ExpQ -> GuardQ
normalGE :: ExpQ -> ExpQ -> Q (Guard, Exp)
patG :: [StmtQ] -> GuardQ
patGE :: [StmtQ] -> ExpQ -> Q (Guard, Exp)

-- | Use with <a>caseE</a>
match :: PatQ -> BodyQ -> [DecQ] -> MatchQ

-- | Use with <a>funD</a>
clause :: [PatQ] -> BodyQ -> [DecQ] -> ClauseQ

-- | Dynamically binding a variable (unhygenic)
dyn :: String -> Q Exp
global :: Name -> ExpQ
varE :: Name -> ExpQ
conE :: Name -> ExpQ
litE :: Lit -> ExpQ
appE :: ExpQ -> ExpQ -> ExpQ
parensE :: ExpQ -> ExpQ
uInfixE :: ExpQ -> ExpQ -> ExpQ -> ExpQ
infixE :: Maybe ExpQ -> ExpQ -> Maybe ExpQ -> ExpQ
infixApp :: ExpQ -> ExpQ -> ExpQ -> ExpQ
sectionL :: ExpQ -> ExpQ -> ExpQ
sectionR :: ExpQ -> ExpQ -> ExpQ
lamE :: [PatQ] -> ExpQ -> ExpQ

-- | Single-arg lambda
lam1E :: PatQ -> ExpQ -> ExpQ
tupE :: [ExpQ] -> ExpQ
unboxedTupE :: [ExpQ] -> ExpQ
condE :: ExpQ -> ExpQ -> ExpQ -> ExpQ
letE :: [DecQ] -> ExpQ -> ExpQ
caseE :: ExpQ -> [MatchQ] -> ExpQ
doE :: [StmtQ] -> ExpQ
compE :: [StmtQ] -> ExpQ
arithSeqE :: RangeQ -> ExpQ
listE :: [ExpQ] -> ExpQ
sigE :: ExpQ -> TypeQ -> ExpQ
recConE :: Name -> [Q (Name, Exp)] -> ExpQ
recUpdE :: ExpQ -> [Q (Name, Exp)] -> ExpQ
stringE :: String -> ExpQ
fieldExp :: Name -> ExpQ -> Q (Name, Exp)
fromE :: ExpQ -> ExpQ
fromThenE :: ExpQ -> ExpQ -> ExpQ
fromToE :: ExpQ -> ExpQ -> ExpQ
fromThenToE :: ExpQ -> ExpQ -> ExpQ -> ExpQ
valD :: PatQ -> BodyQ -> [DecQ] -> DecQ
funD :: Name -> [ClauseQ] -> DecQ
tySynD :: Name -> [TyVarBndr] -> TypeQ -> DecQ
dataD :: CxtQ -> Name -> [TyVarBndr] -> [ConQ] -> [Name] -> DecQ
newtypeD :: CxtQ -> Name -> [TyVarBndr] -> ConQ -> [Name] -> DecQ
classD :: CxtQ -> Name -> [TyVarBndr] -> [FunDep] -> [DecQ] -> DecQ
instanceD :: CxtQ -> TypeQ -> [DecQ] -> DecQ
sigD :: Name -> TypeQ -> DecQ
forImpD :: Callconv -> Safety -> String -> Name -> TypeQ -> DecQ
pragInlD :: Name -> InlineSpecQ -> DecQ
pragSpecD :: Name -> TypeQ -> DecQ
pragSpecInlD :: Name -> TypeQ -> InlineSpecQ -> DecQ
familyNoKindD :: FamFlavour -> Name -> [TyVarBndr] -> DecQ
familyKindD :: FamFlavour -> Name -> [TyVarBndr] -> Kind -> DecQ
dataInstD :: CxtQ -> Name -> [TypeQ] -> [ConQ] -> [Name] -> DecQ
newtypeInstD :: CxtQ -> Name -> [TypeQ] -> ConQ -> [Name] -> DecQ
tySynInstD :: Name -> [TypeQ] -> TypeQ -> DecQ
cxt :: [PredQ] -> CxtQ
classP :: Name -> [TypeQ] -> PredQ
equalP :: TypeQ -> TypeQ -> PredQ
normalC :: Name -> [StrictTypeQ] -> ConQ
recC :: Name -> [VarStrictTypeQ] -> ConQ
infixC :: Q (Strict, Type) -> Name -> Q (Strict, Type) -> ConQ
forallC :: [TyVarBndr] -> CxtQ -> ConQ -> ConQ
forallT :: [TyVarBndr] -> CxtQ -> TypeQ -> TypeQ
varT :: Name -> TypeQ
conT :: Name -> TypeQ
appT :: TypeQ -> TypeQ -> TypeQ
arrowT :: TypeQ
listT :: TypeQ
tupleT :: Int -> TypeQ
unboxedTupleT :: Int -> TypeQ
sigT :: TypeQ -> Kind -> TypeQ
isStrict :: Q Strict
unpacked :: Q Strict
notStrict :: Q Strict
strictType :: Q Strict -> TypeQ -> StrictTypeQ
varStrictType :: Name -> StrictTypeQ -> VarStrictTypeQ
plainTV :: Name -> TyVarBndr
kindedTV :: Name -> Kind -> TyVarBndr
starK :: Kind
arrowK :: Kind -> Kind -> Kind
cCall :: Callconv
stdCall :: Callconv
unsafe :: Safety
interruptible :: Safety
safe :: Safety
inlineSpecNoPhase :: Bool -> Bool -> InlineSpecQ
inlineSpecPhase :: Bool -> Bool -> Bool -> Int -> InlineSpecQ
funDep :: [Name] -> [Name] -> FunDep
typeFam :: FamFlavour
dataFam :: FamFlavour
appsE :: [ExpQ] -> ExpQ

module Language.Haskell.TH.Quote
data QuasiQuoter
QuasiQuoter :: (String -> Q Exp) -> (String -> Q Pat) -> (String -> Q Type) -> (String -> Q [Dec]) -> QuasiQuoter
quoteExp :: QuasiQuoter -> String -> Q Exp
quotePat :: QuasiQuoter -> String -> Q Pat
quoteType :: QuasiQuoter -> String -> Q Type
quoteDec :: QuasiQuoter -> String -> Q [Dec]
dataToQa :: Data a => (Name -> k) -> (Lit -> Q q) -> (k -> [Q q] -> Q q) -> (forall b. Data b => b -> Maybe (Q q)) -> a -> Q q

-- | <a>dataToExpQ</a> converts a value to a 'Q Exp' representation of the
--   same value. It takes a function to handle type-specific cases.
dataToExpQ :: Data a => (forall b. Data b => b -> Maybe (Q Exp)) -> a -> Q Exp

-- | <a>dataToPatQ</a> converts a value to a 'Q Pat' representation of the
--   same value. It takes a function to handle type-specific cases.
dataToPatQ :: Data a => (forall b. Data b => b -> Maybe (Q Pat)) -> a -> Q Pat

-- | <a>quoteFile</a> takes a <a>QuasiQuoter</a> and lifts it into one that
--   read the data out of a file. For example, suppose <tt>asmq</tt> is an
--   assembly-language quoter, so that you can write [asmq| ld r1, r2 |] as
--   an expression. Then if you define <tt>asmq_f = quoteFile asmq</tt>,
--   then the quote [asmq_f| foo.s |] will take input from file
--   <a>foo.s</a> instead of the inline text
quoteFile :: QuasiQuoter -> QuasiQuoter


-- | Monadic front-end to Text.PrettyPrint
module Language.Haskell.TH.PprLib
type Doc = PprM Doc
data PprM a

-- | An empty document
empty :: Doc

-- | A ';' character
semi :: Doc

-- | A ',' character
comma :: Doc

-- | A <tt>:</tt> character
colon :: Doc

-- | A space character
space :: Doc

-- | A '=' character
equals :: Doc

-- | A '(' character
lparen :: Doc

-- | A ')' character
rparen :: Doc

-- | A '[' character
lbrack :: Doc

-- | A ']' character
rbrack :: Doc

-- | A '{' character
lbrace :: Doc

-- | A '}' character
rbrace :: Doc
text :: String -> Doc
char :: Char -> Doc
ptext :: String -> Doc
int :: Int -> Doc
integer :: Integer -> Doc
float :: Float -> Doc
double :: Double -> Doc
rational :: Rational -> Doc

-- | Wrap document in <tt>(...)</tt>
parens :: Doc -> Doc

-- | Wrap document in <tt>[...]</tt>
brackets :: Doc -> Doc

-- | Wrap document in <tt>{...}</tt>
braces :: Doc -> Doc

-- | Wrap document in <tt>'...'</tt>
quotes :: Doc -> Doc

-- | Wrap document in <tt>"..."</tt>
doubleQuotes :: Doc -> Doc

-- | Beside
(<>) :: Doc -> Doc -> Doc

-- | Beside, separated by space
(<+>) :: Doc -> Doc -> Doc

-- | List version of <a>&lt;&gt;</a>
hcat :: [Doc] -> Doc

-- | List version of <a>&lt;+&gt;</a>
hsep :: [Doc] -> Doc

-- | Above; if there is no overlap it "dovetails" the two
($$) :: Doc -> Doc -> Doc

-- | Above, without dovetailing.
($+$) :: Doc -> Doc -> Doc

-- | List version of <a>$$</a>
vcat :: [Doc] -> Doc

-- | Either hsep or vcat
sep :: [Doc] -> Doc

-- | Either hcat or vcat
cat :: [Doc] -> Doc

-- | "Paragraph fill" version of sep
fsep :: [Doc] -> Doc

-- | "Paragraph fill" version of cat
fcat :: [Doc] -> Doc

-- | Nested
nest :: Int -> Doc -> Doc

-- | <pre>
--   hang d1 n d2 = sep [d1, nest n d2]
--   </pre>
hang :: Doc -> Int -> Doc -> Doc

-- | <pre>
--   punctuate p [d1, ... dn] = [d1 &lt;&gt; p, d2 &lt;&gt; p, ... dn-1 &lt;&gt; p, dn]
--   </pre>
punctuate :: Doc -> [Doc] -> [Doc]

-- | Returns <a>True</a> if the document is empty
isEmpty :: Doc -> PprM Bool
to_HPJ_Doc :: Doc -> Doc
pprName :: Name -> Doc
pprName' :: NameIs -> Name -> Doc
instance Monad PprM
instance Show Doc


-- | contains a prettyprinter for the Template Haskell datatypes
module Language.Haskell.TH.Ppr
nestDepth :: Int
type Precedence = Int
appPrec :: Precedence
noPrec :: Precedence
opPrec :: Precedence
unopPrec :: Precedence
parensIf :: Bool -> Doc -> Doc
pprint :: Ppr a => a -> String
class Ppr a where ppr_list = vcat . map ppr
ppr :: Ppr a => a -> Doc
ppr_list :: Ppr a => [a] -> Doc
ppr_sig :: Name -> Type -> Doc
pprFixity :: Name -> Fixity -> Doc
pprInfixExp :: Exp -> Doc
pprExp :: Precedence -> Exp -> Doc
pprFields :: [(Name, Exp)] -> Doc
pprMaybeExp :: Precedence -> Maybe Exp -> Doc
pprBody :: Bool -> Body -> Doc
pprLit :: Precedence -> Lit -> Doc
pprString :: String -> Doc
pprPat :: Precedence -> Pat -> Doc
ppr_dec :: Bool -> Dec -> Doc
ppr_data :: Doc -> Cxt -> Name -> Doc -> [Con] -> [Name] -> Doc
ppr_newtype :: Doc -> Cxt -> Name -> Doc -> Con -> [Name] -> Doc
ppr_tySyn :: Doc -> Name -> Doc -> Type -> Doc
ppr_activation :: Maybe (Bool, Int) -> Doc
pprVarStrictType :: (Name, Strict, Type) -> Doc
pprStrictType :: (Strict, Type) -> Doc
pprParendType :: Type -> Doc
pprTyApp :: (Type, [Type]) -> Doc
pprFunArgType :: Type -> Doc
split :: Type -> (Type, [Type])
pprArrowArgKind :: Kind -> Doc
pprCxt :: Cxt -> Doc
where_clause :: [Dec] -> Doc
showtextl :: Show a => a -> Doc
hashParens :: Doc -> Doc
instance Ppr Range
instance Ppr Pred
instance Ppr Kind
instance Ppr TyVarBndr
instance Ppr Type
instance Ppr Con
instance Ppr Clause
instance Ppr Pragma
instance Ppr Foreign
instance Ppr FamFlavour
instance Ppr FunDep
instance Ppr Dec
instance Ppr Pat
instance Ppr Match
instance Ppr Stmt
instance Ppr Exp
instance Ppr Info
instance Ppr Name
instance Ppr a => Ppr [a]


-- | The public face of Template Haskell
--   
--   For other documentation, refer to:
--   <a>http://www.haskell.org/haskellwiki/Template_Haskell</a>
module Language.Haskell.TH
data Q a
runQ :: Quasi m => Q a -> m a
report :: Bool -> String -> Q ()
recover :: Q a -> Q a -> Q a

-- | <a>reify</a> looks up information about the <a>Name</a>
reify :: Name -> Q Info

-- | <a>location</a> gives you the <tt>Location</tt> at which this
--   computation is spliced.
location :: Q Loc

-- | The <a>runIO</a> function lets you run an I/O computation in the
--   <a>Q</a> monad. Take care: you are guaranteed the ordering of calls to
--   <a>runIO</a> within a single <a>Q</a> computation, but not about the
--   order in which splices are run.
--   
--   Note: for various murky reasons, stdout and stderr handles are not
--   necesarily flushed when the compiler finishes running, so you should
--   flush them yourself.
runIO :: IO a -> Q a
lookupTypeName :: String -> Q (Maybe Name)
lookupValueName :: String -> Q (Maybe Name)
isInstance :: Name -> [Type] -> Q Bool

-- | <tt>classInstances</tt> looks up instaces of a class
reifyInstances :: Name -> [Type] -> Q [Dec]

-- | For <a>global</a> names (<a>NameG</a>) we need a totally unique name,
--   so we must include the name-space of the thing
--   
--   For unique-numbered things (<a>NameU</a>), we've got a unique
--   reference anyway, so no need for name space
--   
--   For dynamically bound thing (<a>NameS</a>) we probably want them to in
--   a context-dependent way, so again we don't want the name space. For
--   example:
--   
--   <pre>
--   let v = mkName "T" in [| data $v = $v |]
--   </pre>
--   
--   Here we use the same Name for both type constructor and data
--   constructor
--   
--   NameL and NameG are bound *outside* the TH syntax tree either globally
--   (NameG) or locally (NameL). Ex:
--   
--   <pre>
--   f x = $(h [| (map, x) |])
--   </pre>
--   
--   The <a>map</a> will be a NameG, and <tt>x</tt> wil be a NameL
--   
--   These Names should never appear in a binding position in a TH syntax
--   tree
data Name
data NameSpace

-- | The string can have a <a>.</a>, thus <a>Foo.baz</a>, giving a
--   dynamically-bound qualified name, in which case we want to generate a
--   NameQ
--   
--   Parse the string to see if it has a <a>.</a> in it so we know whether
--   to generate a qualified or unqualified name It's a bit tricky because
--   we need to parse
--   
--   <pre>
--   Foo.Baz.x   as    Qual Foo.Baz x
--   </pre>
--   
--   So we parse it from back to front
mkName :: String -> Name
newName :: String -> Q Name

-- | Base, unqualified name.
nameBase :: Name -> String
nameModule :: Name -> Maybe String
tupleTypeName :: Int -> Name
tupleDataName :: Int -> Name
data Dec

-- | <pre>
--   { f p1 p2 = b where decs }
--   </pre>
FunD :: Name -> [Clause] -> Dec

-- | <pre>
--   { p = b where decs }
--   </pre>
ValD :: Pat -> Body -> [Dec] -> Dec

-- | <pre>
--   { data Cxt x =&gt; T x = A x | B (T x)
--          deriving (Z,W)}
--   </pre>
DataD :: Cxt -> Name -> [TyVarBndr] -> [Con] -> [Name] -> Dec

-- | <pre>
--   { newtype Cxt x =&gt; T x = A (B x)
--          deriving (Z,W)}
--   </pre>
NewtypeD :: Cxt -> Name -> [TyVarBndr] -> Con -> [Name] -> Dec

-- | <pre>
--   { type T x = (x,x) }
--   </pre>
TySynD :: Name -> [TyVarBndr] -> Type -> Dec

-- | <pre>
--   { class Eq a =&gt; Ord a where ds }
--   </pre>
ClassD :: Cxt -> Name -> [TyVarBndr] -> [FunDep] -> [Dec] -> Dec

-- | <pre>
--   { instance Show w =&gt; Show [w]
--          where ds }
--   </pre>
InstanceD :: Cxt -> Type -> [Dec] -> Dec

-- | <pre>
--   { length :: [a] -&gt; Int }
--   </pre>
SigD :: Name -> Type -> Dec
ForeignD :: Foreign -> Dec

-- | <pre>
--   { {--} }
--   </pre>
PragmaD :: Pragma -> Dec

-- | <pre>
--   { type family T a b c :: * }
--   </pre>
FamilyD :: FamFlavour -> Name -> [TyVarBndr] -> (Maybe Kind) -> Dec

-- | <pre>
--   { data instance Cxt x =&gt; T [x] = A x 
--                                   | B (T x)
--          deriving (Z,W)}
--   </pre>
DataInstD :: Cxt -> Name -> [Type] -> [Con] -> [Name] -> Dec

-- | <pre>
--   { newtype instance Cxt x =&gt; T [x] = A (B x)
--          deriving (Z,W)}
--   </pre>
NewtypeInstD :: Cxt -> Name -> [Type] -> Con -> [Name] -> Dec

-- | <pre>
--   { type instance T (Maybe x) = (x,x) }
--   </pre>
TySynInstD :: Name -> [Type] -> Type -> Dec

-- | The <a>CompE</a> constructor represents a list comprehension, and
--   takes a [<a>Stmt</a>]. The result expression of the comprehension is
--   the *last* of these, and should be a <a>NoBindS</a>.
--   
--   E.g. translation:
--   
--   <pre>
--   [ f x | x &lt;- xs ]
--   </pre>
--   
--   <pre>
--   CompE [BindS (VarP x) (VarE xs), NoBindS (AppE (VarE f) (VarE x))]
--   </pre>
data Exp

-- | <pre>
--   { x }
--   </pre>
VarE :: Name -> Exp

-- | <pre>
--   data T1 = C1 t1 t2; p = {C1} e1 e2
--   </pre>
ConE :: Name -> Exp

-- | <pre>
--   { 5 or <tt>c</tt>}
--   </pre>
LitE :: Lit -> Exp

-- | <pre>
--   { f x }
--   </pre>
AppE :: Exp -> Exp -> Exp

-- | <pre>
--   {x + y} or {(x+)} or {(+ x)} or {(+)}
--   </pre>
--   
--   It's a bit gruesome to use an Exp as the operator, but how else can we
--   distinguish constructors from non-constructors? Maybe there should be
--   a var-or-con type? Or maybe we should leave it to the String itself?
InfixE :: (Maybe Exp) -> Exp -> (Maybe Exp) -> Exp

-- | <pre>
--   {x + y}
--   </pre>
--   
--   See Note [Unresolved infix] at <a>Language.Haskell.TH.Syntax#infix</a>
UInfixE :: Exp -> Exp -> Exp -> Exp

-- | <pre>
--   { (e) }
--   </pre>
--   
--   See Note [Unresolved infix] at <a>Language.Haskell.TH.Syntax#infix</a>
ParensE :: Exp -> Exp

-- | <pre>
--   {  p1 p2 -&gt; e }
--   </pre>
LamE :: [Pat] -> Exp -> Exp

-- | <pre>
--   { (e1,e2) }
--   </pre>
TupE :: [Exp] -> Exp

-- | <pre>
--   { () }
--   </pre>
UnboxedTupE :: [Exp] -> Exp

-- | <pre>
--   { if e1 then e2 else e3 }
--   </pre>
CondE :: Exp -> Exp -> Exp -> Exp

-- | <pre>
--   { let x=e1;   y=e2 in e3 }
--   </pre>
LetE :: [Dec] -> Exp -> Exp

-- | <pre>
--   { case e of m1; m2 }
--   </pre>
CaseE :: Exp -> [Match] -> Exp

-- | <pre>
--   { do { p &lt;- e1; e2 }  }
--   </pre>
DoE :: [Stmt] -> Exp

-- | <pre>
--   { [ (x,y) | x &lt;- xs, y &lt;- ys ] }
--   </pre>
CompE :: [Stmt] -> Exp

-- | <pre>
--   { [ 1 ,2 .. 10 ] }
--   </pre>
ArithSeqE :: Range -> Exp

-- | <pre>
--   { [1,2,3] }
--   </pre>
ListE :: [Exp] -> Exp

-- | <pre>
--   { e :: t }
--   </pre>
SigE :: Exp -> Type -> Exp

-- | <pre>
--   { T { x = y, z = w } }
--   </pre>
RecConE :: Name -> [FieldExp] -> Exp

-- | <pre>
--   { (f x) { z = w } }
--   </pre>
RecUpdE :: Exp -> [FieldExp] -> Exp
data Con

-- | <pre>
--   C Int a
--   </pre>
NormalC :: Name -> [StrictType] -> Con

-- | <pre>
--   C { v :: Int, w :: a }
--   </pre>
RecC :: Name -> [VarStrictType] -> Con

-- | <pre>
--   Int :+ a
--   </pre>
InfixC :: StrictType -> Name -> StrictType -> Con

-- | <pre>
--   forall a. Eq a =&gt; C [a]
--   </pre>
ForallC :: [TyVarBndr] -> Cxt -> Con -> Con
data Type

-- | <pre>
--   forall <a>vars</a>. <a>ctxt</a> -&gt; <a>type</a>
--   </pre>
ForallT :: [TyVarBndr] -> Cxt -> Type -> Type

-- | <pre>
--   a
--   </pre>
VarT :: Name -> Type

-- | <pre>
--   T
--   </pre>
ConT :: Name -> Type

-- | <pre>
--   (,), (,,), etc.
--   </pre>
TupleT :: Int -> Type

-- | <pre>
--   (), (), etc.
--   </pre>
UnboxedTupleT :: Int -> Type

-- | <pre>
--   -&gt;
--   </pre>
ArrowT :: Type

-- | <pre>
--   []
--   </pre>
ListT :: Type

-- | <pre>
--   T a b
--   </pre>
AppT :: Type -> Type -> Type

-- | <pre>
--   t :: k
--   </pre>
SigT :: Type -> Kind -> Type
data TyVarBndr

-- | <pre>
--   a
--   </pre>
PlainTV :: Name -> TyVarBndr

-- | <pre>
--   (a :: k)
--   </pre>
KindedTV :: Name -> Kind -> TyVarBndr
data Kind

-- | <pre>
--   <a>*</a>
--   </pre>
StarK :: Kind

-- | <pre>
--   k1 -&gt; k2
--   </pre>
ArrowK :: Kind -> Kind -> Kind
type Cxt = [Pred]
data Pred

-- | <pre>
--   Eq (Int, a)
--   </pre>
ClassP :: Name -> [Type] -> Pred

-- | <pre>
--   F a ~ Bool
--   </pre>
EqualP :: Type -> Type -> Pred
data Match

-- | <pre>
--   case e of { pat -&gt; body where decs }
--   </pre>
Match :: Pat -> Body -> [Dec] -> Match
data Clause

-- | <pre>
--   f { p1 p2 = body where decs }
--   </pre>
Clause :: [Pat] -> Body -> [Dec] -> Clause
data Body

-- | <pre>
--   f p { | e1 = e2 | e3 = e4 } where ds
--   </pre>
GuardedB :: [(Guard, Exp)] -> Body

-- | <pre>
--   f p { = e } where ds
--   </pre>
NormalB :: Exp -> Body
data Guard
NormalG :: Exp -> Guard
PatG :: [Stmt] -> Guard
data Stmt
BindS :: Pat -> Exp -> Stmt
LetS :: [Dec] -> Stmt
NoBindS :: Exp -> Stmt
ParS :: [[Stmt]] -> Stmt
data Range
FromR :: Exp -> Range
FromThenR :: Exp -> Exp -> Range
FromToR :: Exp -> Exp -> Range
FromThenToR :: Exp -> Exp -> Exp -> Range
data Lit
CharL :: Char -> Lit
StringL :: String -> Lit

-- | Used for overloaded and non-overloaded literals. We don't have a good
--   way to represent non-overloaded literals at the moment. Maybe that
--   doesn't matter?
IntegerL :: Integer -> Lit
RationalL :: Rational -> Lit
IntPrimL :: Integer -> Lit
WordPrimL :: Integer -> Lit
FloatPrimL :: Rational -> Lit
DoublePrimL :: Rational -> Lit

-- | A primitive C-style string, type Addr#
StringPrimL :: String -> Lit

-- | Pattern in Haskell given in <tt>{}</tt>
data Pat

-- | <pre>
--   { 5 or <tt>c</tt> }
--   </pre>
LitP :: Lit -> Pat

-- | <pre>
--   { x }
--   </pre>
VarP :: Name -> Pat

-- | <pre>
--   { (p1,p2) }
--   </pre>
TupP :: [Pat] -> Pat

-- | <pre>
--   { () }
--   </pre>
UnboxedTupP :: [Pat] -> Pat

-- | <pre>
--   data T1 = C1 t1 t2; {C1 p1 p1} = e
--   </pre>
ConP :: Name -> [Pat] -> Pat

-- | <pre>
--   foo ({x :+ y}) = e
--   </pre>
InfixP :: Pat -> Name -> Pat -> Pat

-- | <pre>
--   foo ({x :+ y}) = e
--   </pre>
--   
--   See Note [Unresolved infix] at <a>Language.Haskell.TH.Syntax#infix</a>
UInfixP :: Pat -> Name -> Pat -> Pat

-- | <pre>
--   {(p)}
--   </pre>
--   
--   See Note [Unresolved infix] at <a>Language.Haskell.TH.Syntax#infix</a>
ParensP :: Pat -> Pat

-- | <pre>
--   { ~p }
--   </pre>
TildeP :: Pat -> Pat

-- | <pre>
--   { !p }
--   </pre>
BangP :: Pat -> Pat

-- | <pre>
--   { x @ p }
--   </pre>
AsP :: Name -> Pat -> Pat

-- | <pre>
--   { _ }
--   </pre>
WildP :: Pat

-- | <pre>
--   f (Pt { pointx = x }) = g x
--   </pre>
RecP :: Name -> [FieldPat] -> Pat

-- | <pre>
--   { [1,2,3] }
--   </pre>
ListP :: [Pat] -> Pat

-- | <pre>
--   { p :: t }
--   </pre>
SigP :: Pat -> Type -> Pat

-- | <pre>
--   { e -&gt; p }
--   </pre>
ViewP :: Exp -> Pat -> Pat
type FieldExp = (Name, Exp)
type FieldPat = (Name, Pat)
data Strict
IsStrict :: Strict
NotStrict :: Strict
Unpacked :: Strict
data Foreign
ImportF :: Callconv -> Safety -> String -> Name -> Type -> Foreign
ExportF :: Callconv -> String -> Name -> Type -> Foreign
data Callconv
CCall :: Callconv
StdCall :: Callconv
data Safety
Unsafe :: Safety
Safe :: Safety
Interruptible :: Safety
data Pragma
InlineP :: Name -> InlineSpec -> Pragma
SpecialiseP :: Name -> Type -> (Maybe InlineSpec) -> Pragma
data InlineSpec
InlineSpec :: Bool -> Bool -> (Maybe (Bool, Int)) -> InlineSpec
data FunDep
FunDep :: [Name] -> [Name] -> FunDep
data FamFlavour
TypeFam :: FamFlavour
DataFam :: FamFlavour

-- | Obtained from <a>reify</a> in the <a>Q</a> Monad.
data Info

-- | A class is reified to its declaration and a list of its instances
ClassI :: Dec -> [InstanceDec] -> Info
ClassOpI :: Name -> Type -> Name -> Fixity -> Info
TyConI :: Dec -> Info
FamilyI :: Dec -> [InstanceDec] -> Info
PrimTyConI :: Name -> Int -> Bool -> Info
DataConI :: Name -> Type -> Name -> Fixity -> Info
VarI :: Name -> Type -> (Maybe Dec) -> Fixity -> Info
TyVarI :: Name -> Type -> Info
data Loc
Loc :: String -> String -> String -> CharPos -> CharPos -> Loc
loc_filename :: Loc -> String
loc_package :: Loc -> String
loc_module :: Loc -> String
loc_start :: Loc -> CharPos
loc_end :: Loc -> CharPos
data Fixity
Fixity :: Int -> FixityDirection -> Fixity
data FixityDirection
InfixL :: FixityDirection
InfixR :: FixityDirection
InfixN :: FixityDirection
defaultFixity :: Fixity
maxPrecedence :: Int
type InfoQ = Q Info
type ExpQ = Q Exp
type DecQ = Q Dec
type DecsQ = Q [Dec]
type ConQ = Q Con
type TypeQ = Q Type
type CxtQ = Q Cxt
type PredQ = Q Pred
type MatchQ = Q Match
type ClauseQ = Q Clause
type BodyQ = Q Body
type GuardQ = Q Guard
type StmtQ = Q Stmt
type RangeQ = Q Range
type StrictTypeQ = Q StrictType
type VarStrictTypeQ = Q VarStrictType
type PatQ = Q Pat
type FieldPatQ = Q FieldPat
type InlineSpecQ = Q InlineSpec
intPrimL :: Integer -> Lit
wordPrimL :: Integer -> Lit
floatPrimL :: Rational -> Lit
doublePrimL :: Rational -> Lit
integerL :: Integer -> Lit
rationalL :: Rational -> Lit
charL :: Char -> Lit
stringL :: String -> Lit
stringPrimL :: String -> Lit
litP :: Lit -> PatQ
varP :: Name -> PatQ
tupP :: [PatQ] -> PatQ
conP :: Name -> [PatQ] -> PatQ
uInfixP :: PatQ -> Name -> PatQ -> PatQ
parensP :: PatQ -> PatQ
infixP :: PatQ -> Name -> PatQ -> PatQ
tildeP :: PatQ -> PatQ
bangP :: PatQ -> PatQ
asP :: Name -> PatQ -> PatQ
wildP :: PatQ
recP :: Name -> [FieldPatQ] -> PatQ
listP :: [PatQ] -> PatQ
sigP :: PatQ -> TypeQ -> PatQ
viewP :: ExpQ -> PatQ -> PatQ
fieldPat :: Name -> PatQ -> FieldPatQ
normalB :: ExpQ -> BodyQ
guardedB :: [Q (Guard, Exp)] -> BodyQ
normalG :: ExpQ -> GuardQ
normalGE :: ExpQ -> ExpQ -> Q (Guard, Exp)
patG :: [StmtQ] -> GuardQ
patGE :: [StmtQ] -> ExpQ -> Q (Guard, Exp)

-- | Use with <a>caseE</a>
match :: PatQ -> BodyQ -> [DecQ] -> MatchQ

-- | Use with <a>funD</a>
clause :: [PatQ] -> BodyQ -> [DecQ] -> ClauseQ

-- | Dynamically binding a variable (unhygenic)
dyn :: String -> Q Exp
global :: Name -> ExpQ
varE :: Name -> ExpQ
conE :: Name -> ExpQ
litE :: Lit -> ExpQ
appE :: ExpQ -> ExpQ -> ExpQ
uInfixE :: ExpQ -> ExpQ -> ExpQ -> ExpQ
parensE :: ExpQ -> ExpQ
infixE :: Maybe ExpQ -> ExpQ -> Maybe ExpQ -> ExpQ
infixApp :: ExpQ -> ExpQ -> ExpQ -> ExpQ
sectionL :: ExpQ -> ExpQ -> ExpQ
sectionR :: ExpQ -> ExpQ -> ExpQ
lamE :: [PatQ] -> ExpQ -> ExpQ

-- | Single-arg lambda
lam1E :: PatQ -> ExpQ -> ExpQ
tupE :: [ExpQ] -> ExpQ
condE :: ExpQ -> ExpQ -> ExpQ -> ExpQ
letE :: [DecQ] -> ExpQ -> ExpQ
caseE :: ExpQ -> [MatchQ] -> ExpQ
appsE :: [ExpQ] -> ExpQ
listE :: [ExpQ] -> ExpQ
sigE :: ExpQ -> TypeQ -> ExpQ
recConE :: Name -> [Q (Name, Exp)] -> ExpQ
recUpdE :: ExpQ -> [Q (Name, Exp)] -> ExpQ
stringE :: String -> ExpQ
fieldExp :: Name -> ExpQ -> Q (Name, Exp)
fromE :: ExpQ -> ExpQ
fromThenE :: ExpQ -> ExpQ -> ExpQ
fromToE :: ExpQ -> ExpQ -> ExpQ
fromThenToE :: ExpQ -> ExpQ -> ExpQ -> ExpQ
arithSeqE :: RangeQ -> ExpQ
fromR :: ExpQ -> RangeQ
fromThenR :: ExpQ -> ExpQ -> RangeQ
fromToR :: ExpQ -> ExpQ -> RangeQ
fromThenToR :: ExpQ -> ExpQ -> ExpQ -> RangeQ
doE :: [StmtQ] -> ExpQ
compE :: [StmtQ] -> ExpQ
bindS :: PatQ -> ExpQ -> StmtQ
letS :: [DecQ] -> StmtQ
noBindS :: ExpQ -> StmtQ
parS :: [[StmtQ]] -> StmtQ
forallT :: [TyVarBndr] -> CxtQ -> TypeQ -> TypeQ
varT :: Name -> TypeQ
conT :: Name -> TypeQ
appT :: TypeQ -> TypeQ -> TypeQ
arrowT :: TypeQ
listT :: TypeQ
tupleT :: Int -> TypeQ
sigT :: TypeQ -> Kind -> TypeQ
isStrict :: Q Strict
notStrict :: Q Strict
strictType :: Q Strict -> TypeQ -> StrictTypeQ
varStrictType :: Name -> StrictTypeQ -> VarStrictTypeQ
cxt :: [PredQ] -> CxtQ
classP :: Name -> [TypeQ] -> PredQ
equalP :: TypeQ -> TypeQ -> PredQ
normalC :: Name -> [StrictTypeQ] -> ConQ
recC :: Name -> [VarStrictTypeQ] -> ConQ
infixC :: Q (Strict, Type) -> Name -> Q (Strict, Type) -> ConQ
valD :: PatQ -> BodyQ -> [DecQ] -> DecQ
funD :: Name -> [ClauseQ] -> DecQ
tySynD :: Name -> [TyVarBndr] -> TypeQ -> DecQ
dataD :: CxtQ -> Name -> [TyVarBndr] -> [ConQ] -> [Name] -> DecQ
newtypeD :: CxtQ -> Name -> [TyVarBndr] -> ConQ -> [Name] -> DecQ
classD :: CxtQ -> Name -> [TyVarBndr] -> [FunDep] -> [DecQ] -> DecQ
instanceD :: CxtQ -> TypeQ -> [DecQ] -> DecQ
sigD :: Name -> TypeQ -> DecQ
familyNoKindD :: FamFlavour -> Name -> [TyVarBndr] -> DecQ
familyKindD :: FamFlavour -> Name -> [TyVarBndr] -> Kind -> DecQ
dataInstD :: CxtQ -> Name -> [TypeQ] -> [ConQ] -> [Name] -> DecQ
newtypeInstD :: CxtQ -> Name -> [TypeQ] -> ConQ -> [Name] -> DecQ
tySynInstD :: Name -> [TypeQ] -> TypeQ -> DecQ
typeFam :: FamFlavour
dataFam :: FamFlavour
cCall :: Callconv
stdCall :: Callconv
unsafe :: Safety
safe :: Safety
forImpD :: Callconv -> Safety -> String -> Name -> TypeQ -> DecQ
inlineSpecNoPhase :: Bool -> Bool -> InlineSpecQ
inlineSpecPhase :: Bool -> Bool -> Bool -> Int -> InlineSpecQ
pragInlD :: Name -> InlineSpecQ -> DecQ
pragSpecD :: Name -> TypeQ -> DecQ
class Ppr a where ppr_list = vcat . map ppr
ppr :: Ppr a => a -> Doc
ppr_list :: Ppr a => [a] -> Doc
pprint :: Ppr a => a -> String
pprExp :: Precedence -> Exp -> Doc
pprLit :: Precedence -> Lit -> Doc
pprPat :: Precedence -> Pat -> Doc
pprParendType :: Type -> Doc
