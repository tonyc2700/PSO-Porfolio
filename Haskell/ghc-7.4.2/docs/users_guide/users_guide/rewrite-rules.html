<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>7.17. Rewrite rules</title><link rel="stylesheet" href="fptools.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"><link rel="home" href="index.html" title="The Parallel Haskell Compilation System User's Guide, Version 7.4.2"><link rel="up" href="ghc-language-features.html" title="Chapter 7. GHC Language Features"><link rel="prev" href="pragmas.html" title="7.16. Pragmas"><link rel="next" href="special-ids.html" title="7.18. Special built-in functions"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">7.17. Rewrite rules



</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="pragmas.html">Prev</a> </td><th width="60%" align="center">Chapter 7. GHC Language Features</th><td width="20%" align="right"> <a accesskey="n" href="special-ids.html">Next</a></td></tr></table><hr></div><div class="sect1" title="7.17. Rewrite rules"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="rewrite-rules"></a>7.17. Rewrite rules

<a class="indexterm" name="idp29673768"></a>
<a class="indexterm" name="idp29674184"></a>
<a class="indexterm" name="idp29674600"></a></h2></div></div></div><p>
The programmer can specify rewrite rules as part of the source program
(in a pragma).
Here is an example:

</p><pre class="programlisting">
  {-# RULES
  "map/map"    forall f g xs.  map f (map g xs) = map (f.g) xs
    #-}
</pre><p>
</p><p>
Use the debug flag <code class="option">-ddump-simpl-stats</code> to see what rules fired.
If you need more information, then <code class="option">-ddump-rule-firings</code> shows you
each individual rule firing and <code class="option">-ddump-rule-rewrites</code> also shows what the code looks like before and after the rewrite.
</p><div class="sect2" title="7.17.1. Syntax"><div class="titlepage"><div><div><h3 class="title"><a name="idp29676832"></a>7.17.1. Syntax</h3></div></div></div><p>
From a syntactic point of view:

</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
 There may be zero or more rules in a <code class="literal">RULES</code> pragma, separated by semicolons (which
 may be generated by the layout rule).
</p></li><li class="listitem"><p>
The layout rule applies in a pragma.
Currently no new indentation level
is set, so if you put several rules in single RULES pragma and wish to use layout to separate them,
you must lay out the starting in the same column as the enclosing definitions.
</p><pre class="programlisting">
  {-# RULES
  "map/map"    forall f g xs.  map f (map g xs) = map (f.g) xs
  "map/append" forall f xs ys. map f (xs ++ ys) = map f xs ++ map f ys
    #-}
</pre><p>
Furthermore, the closing <code class="literal">#-}</code>
should start in a column to the right of the opening <code class="literal">{-#</code>.
</p></li><li class="listitem"><p>
 Each rule has a name, enclosed in double quotes.  The name itself has
no significance at all.  It is only used when reporting how many times the rule fired.
</p></li><li class="listitem"><p>
A rule may optionally have a phase-control number (see <a class="xref" href="pragmas.html#phase-control" title="7.16.5.5. Phase control">Section 7.16.5.5, &#8220;Phase control&#8221;</a>),
immediately after the name of the rule.  Thus:
</p><pre class="programlisting">
  {-# RULES
        "map/map" [2]  forall f g xs. map f (map g xs) = map (f.g) xs
    #-}
</pre><p>
The "[2]" means that the rule is active in Phase 2 and subsequent phases.  The inverse
notation "[~2]" is also accepted, meaning that the rule is active up to, but not including,
Phase 2.
</p></li><li class="listitem"><p>
 Each variable mentioned in a rule must either be in scope (e.g. <code class="function">map</code>),
or bound by the <code class="literal">forall</code> (e.g. <code class="function">f</code>, <code class="function">g</code>, <code class="function">xs</code>).  The variables bound by
the <code class="literal">forall</code> are called the <span class="emphasis"><em>pattern</em></span> variables.  They are separated
by spaces, just like in a type <code class="literal">forall</code>.
</p></li><li class="listitem"><p>
 A pattern variable may optionally have a type signature.
If the type of the pattern variable is polymorphic, it <span class="emphasis"><em>must</em></span> have a type signature.
For example, here is the <code class="literal">foldr/build</code> rule:

</p><pre class="programlisting">
"fold/build"  forall k z (g::forall b. (a-&gt;b-&gt;b) -&gt; b -&gt; b) .
              foldr k z (build g) = g k z
</pre><p>

Since <code class="function">g</code> has a polymorphic type, it must have a type signature.

</p></li><li class="listitem"><p>
The left hand side of a rule must consist of a top-level variable applied
to arbitrary expressions.  For example, this is <span class="emphasis"><em>not</em></span> OK:

</p><pre class="programlisting">
"wrong1"   forall e1 e2.  case True of { True -&gt; e1; False -&gt; e2 } = e1
"wrong2"   forall f.      f True = True
</pre><p>

In <code class="literal">"wrong1"</code>, the LHS is not an application; in <code class="literal">"wrong2"</code>, the LHS has a pattern variable
in the head.
</p></li><li class="listitem"><p>
 A rule does not need to be in the same module as (any of) the
variables it mentions, though of course they need to be in scope.
</p></li><li class="listitem"><p>
 All rules are implicitly exported from the module, and are therefore
in force in any module that imports the module that defined the rule, directly
or indirectly.  (That is, if A imports B, which imports C, then C's rules are
in force when compiling A.)  The situation is very similar to that for instance
declarations.
</p></li><li class="listitem"><p>
Inside a RULE "<code class="literal">forall</code>" is treated as a keyword, regardless of
any other flag settings.  Furthermore, inside a RULE, the language extension
<code class="option">-XScopedTypeVariables</code> is automatically enabled; see
<a class="xref" href="other-type-extensions.html#scoped-type-variables" title="7.11.7. Lexically scoped type variables">Section 7.11.7, &#8220;Lexically scoped type variables
&#8221;</a>.
</p></li><li class="listitem"><p>
Like other pragmas, RULE pragmas are always checked for scope errors, and
are typechecked. Typechecking means that the LHS and RHS of a rule are typechecked,
and must have the same type.  However, rules are only <span class="emphasis"><em>enabled</em></span>
if the <code class="option">-fenable-rewrite-rules</code> flag is
on (see <a class="xref" href="rewrite-rules.html#rule-semantics" title="7.17.2. Semantics">Section 7.17.2, &#8220;Semantics&#8221;</a>).
</p></li></ul></div><p>

</p></div><div class="sect2" title="7.17.2. Semantics"><div class="titlepage"><div><div><h3 class="title"><a name="rule-semantics"></a>7.17.2. Semantics</h3></div></div></div><p>
From a semantic point of view:

</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
Rules are enabled (that is, used during optimisation)
by the <code class="option">-fenable-rewrite-rules</code> flag.
This flag is implied by <code class="option">-O</code>, and may be switched
off (as usual) by <code class="option">-fno-enable-rewrite-rules</code>.
(NB: enabling <code class="option">-fenable-rewrite-rules</code> without <code class="option">-O</code>
may not do what you expect, though, because without <code class="option">-O</code> GHC
ignores all optimisation information in interface files;
see <code class="option">-fignore-interface-pragmas</code>, <a class="xref" href="options-optimise.html#options-f" title="4.10.2. -f*: platform-independent flags">Section 4.10.2, &#8220;<code class="option">-f*</code>: platform-independent flags&#8221;</a>.)
Note that <code class="option">-fenable-rewrite-rules</code> is an <span class="emphasis"><em>optimisation</em></span> flag, and
has no effect on parsing or typechecking.
</p></li><li class="listitem"><p>
 Rules are regarded as left-to-right rewrite rules.
When GHC finds an expression that is a substitution instance of the LHS
of a rule, it replaces the expression by the (appropriately-substituted) RHS.
By "a substitution instance" we mean that the LHS can be made equal to the
expression by substituting for the pattern variables.

</p></li><li class="listitem"><p>
 GHC makes absolutely no attempt to verify that the LHS and RHS
of a rule have the same meaning.  That is undecidable in general, and
infeasible in most interesting cases.  The responsibility is entirely the programmer's!

</p></li><li class="listitem"><p>
 GHC makes no attempt to make sure that the rules are confluent or
terminating.  For example:

</p><pre class="programlisting">
  "loop"        forall x y.  f x y = f y x
</pre><p>

This rule will cause the compiler to go into an infinite loop.

</p></li><li class="listitem"><p>
 If more than one rule matches a call, GHC will choose one arbitrarily to apply.

</p></li><li class="listitem"><p>
 GHC currently uses a very simple, syntactic, matching algorithm
for matching a rule LHS with an expression.  It seeks a substitution
which makes the LHS and expression syntactically equal modulo alpha
conversion.  The pattern (rule), but not the expression, is eta-expanded if
necessary.  (Eta-expanding the expression can lead to laziness bugs.)
But not beta conversion (that's called higher-order matching).
</p><p>
Matching is carried out on GHC's intermediate language, which includes
type abstractions and applications.  So a rule only matches if the
types match too.  See <a class="xref" href="rewrite-rules.html#rule-spec" title="7.17.5. Specialisation">Section 7.17.5, &#8220;Specialisation
&#8221;</a> below.
</p></li><li class="listitem"><p>
 GHC keeps trying to apply the rules as it optimises the program.
For example, consider:

</p><pre class="programlisting">
  let s = map f
      t = map g
  in
  s (t xs)
</pre><p>

The expression <code class="literal">s (t xs)</code> does not match the rule <code class="literal">"map/map"</code>, but GHC
will substitute for <code class="varname">s</code> and <code class="varname">t</code>, giving an expression which does match.
If <code class="varname">s</code> or <code class="varname">t</code> was (a) used more than once, and (b) large or a redex, then it would
not be substituted, and the rule would not fire.

</p></li></ul></div><p>

</p></div><div class="sect2" title="7.17.3. How rules interact with INLINE/NOINLINE and CONLIKE pragmas"><div class="titlepage"><div><div><h3 class="title"><a name="conlike"></a>7.17.3. How rules interact with INLINE/NOINLINE and CONLIKE pragmas</h3></div></div></div><p>
Ordinary inlining happens at the same time as rule rewriting, which may lead to unexpected
results.  Consider this (artificial) example
</p><pre class="programlisting">
f x = x
g y = f y
h z = g True

{-# RULES "f" f True = False #-}
</pre><p>
Since <code class="literal">f</code>'s right-hand side is small, it is inlined into <code class="literal">g</code>,
to give
</p><pre class="programlisting">
g y = y
</pre><p>
Now <code class="literal">g</code> is inlined into <code class="literal">h</code>, but <code class="literal">f</code>'s RULE has
no chance to fire.
If instead GHC had first inlined <code class="literal">g</code> into <code class="literal">h</code> then there
would have been a better chance that <code class="literal">f</code>'s RULE might fire.
</p><p>
The way to get predictable behaviour is to use a NOINLINE
pragma, or an INLINE[<em class="replaceable"><code>phase</code></em>] pragma, on <code class="literal">f</code>, to ensure
that it is not inlined until its RULEs have had a chance to fire.
</p><p>
GHC is very cautious about duplicating work.  For example, consider
</p><pre class="programlisting">
f k z xs = let xs = build g
           in ...(foldr k z xs)...sum xs...
{-# RULES "foldr/build" forall k z g. foldr k z (build g) = g k z #-}
</pre><p>
Since <code class="literal">xs</code> is used twice, GHC does not fire the foldr/build rule.  Rightly
so, because it might take a lot of work to compute <code class="literal">xs</code>, which would be
duplicated if the rule fired.
</p><p>
Sometimes, however, this approach is over-cautious, and we <span class="emphasis"><em>do</em></span> want the
rule to fire, even though doing so would duplicate redex.  There is no way that GHC can work out
when this is a good idea, so we provide the CONLIKE pragma to declare it, thus:
</p><pre class="programlisting">
{-# INLINE[1] CONLIKE f #-}
f x = <em class="replaceable"><code>blah</code></em>
</pre><p>
CONLIKE is a modifier to an INLINE or NOINLINE pragma.  It specifies that an application
of f to one argument (in general, the number of arguments to the left of the '=' sign)
should be considered cheap enough to duplicate, if such a duplication would make rule
fire.  (The name "CONLIKE" is short for "constructor-like", because constructors certainly
have such a property.)
The CONLIKE pragma is a modifier to INLINE/NOINLINE because it really only makes sense to match
<code class="literal">f</code> on the LHS of a rule if you are sure that <code class="literal">f</code> is
not going to be inlined before the rule has a chance to fire.
</p></div><div class="sect2" title="7.17.4. List fusion"><div class="titlepage"><div><div><h3 class="title"><a name="idp29714560"></a>7.17.4. List fusion</h3></div></div></div><p>
The RULES mechanism is used to implement fusion (deforestation) of common list functions.
If a "good consumer" consumes an intermediate list constructed by a "good producer", the
intermediate list should be eliminated entirely.
</p><p>
The following are good producers:

</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
 List comprehensions
</p></li><li class="listitem"><p>
 Enumerations of <code class="literal">Int</code>, <code class="literal">Integer</code> and <code class="literal">Char</code> (e.g. <code class="literal">['a'..'z']</code>).
</p></li><li class="listitem"><p>
 Explicit lists (e.g. <code class="literal">[True, False]</code>)
</p></li><li class="listitem"><p>
 The cons constructor (e.g <code class="literal">3:4:[]</code>)
</p></li><li class="listitem"><p>
 <code class="function">++</code>
</p></li><li class="listitem"><p>
 <code class="function">map</code>
</p></li><li class="listitem"><p>
<code class="function">take</code>, <code class="function">filter</code>
</p></li><li class="listitem"><p>
 <code class="function">iterate</code>, <code class="function">repeat</code>
</p></li><li class="listitem"><p>
 <code class="function">zip</code>, <code class="function">zipWith</code>
</p></li></ul></div><p>

</p><p>
The following are good consumers:

</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
 List comprehensions
</p></li><li class="listitem"><p>
 <code class="function">array</code> (on its second argument)
</p></li><li class="listitem"><p>
 <code class="function">++</code> (on its first argument)
</p></li><li class="listitem"><p>
 <code class="function">foldr</code>
</p></li><li class="listitem"><p>
 <code class="function">map</code>
</p></li><li class="listitem"><p>
<code class="function">take</code>, <code class="function">filter</code>
</p></li><li class="listitem"><p>
 <code class="function">concat</code>
</p></li><li class="listitem"><p>
 <code class="function">unzip</code>, <code class="function">unzip2</code>, <code class="function">unzip3</code>, <code class="function">unzip4</code>
</p></li><li class="listitem"><p>
 <code class="function">zip</code>, <code class="function">zipWith</code> (but on one argument only; if both are good producers, <code class="function">zip</code>
will fuse with one but not the other)
</p></li><li class="listitem"><p>
 <code class="function">partition</code>
</p></li><li class="listitem"><p>
 <code class="function">head</code>
</p></li><li class="listitem"><p>
 <code class="function">and</code>, <code class="function">or</code>, <code class="function">any</code>, <code class="function">all</code>
</p></li><li class="listitem"><p>
 <code class="function">sequence_</code>
</p></li><li class="listitem"><p>
 <code class="function">msum</code>
</p></li></ul></div><p>

</p><p>
So, for example, the following should generate no intermediate lists:

</p><pre class="programlisting">
array (1,10) [(i,i*i) | i &lt;- map (+ 1) [0..9]]
</pre><p>

</p><p>
This list could readily be extended; if there are Prelude functions that you use
a lot which are not included, please tell us.
</p><p>
If you want to write your own good consumers or producers, look at the
Prelude definitions of the above functions to see how to do so.
</p></div><div class="sect2" title="7.17.5. Specialisation"><div class="titlepage"><div><div><h3 class="title"><a name="rule-spec"></a>7.17.5. Specialisation
</h3></div></div></div><p>
Rewrite rules can be used to get the same effect as a feature
present in earlier versions of GHC.
For example, suppose that:

</p><pre class="programlisting">
genericLookup :: Ord a =&gt; Table a b   -&gt; a   -&gt; b
intLookup     ::          Table Int b -&gt; Int -&gt; b
</pre><p>

where <code class="function">intLookup</code> is an implementation of
<code class="function">genericLookup</code> that works very fast for
keys of type <code class="literal">Int</code>.  You might wish
to tell GHC to use <code class="function">intLookup</code> instead of
<code class="function">genericLookup</code> whenever the latter was called with
type <code class="literal">Table Int b -&gt; Int -&gt; b</code>.
It used to be possible to write

</p><pre class="programlisting">
{-# SPECIALIZE genericLookup :: Table Int b -&gt; Int -&gt; b = intLookup #-}
</pre><p>

This feature is no longer in GHC, but rewrite rules let you do the same thing:

</p><pre class="programlisting">
{-# RULES "genericLookup/Int" genericLookup = intLookup #-}
</pre><p>

This slightly odd-looking rule instructs GHC to replace
<code class="function">genericLookup</code> by <code class="function">intLookup</code>
<span class="emphasis"><em>whenever the types match</em></span>.
What is more, this rule does not need to be in the same
file as <code class="function">genericLookup</code>, unlike the
<code class="literal">SPECIALIZE</code> pragmas which currently do (so that they
have an original definition available to specialise).
</p><p>It is <span class="emphasis"><em>Your Responsibility</em></span> to make sure that
<code class="function">intLookup</code> really behaves as a specialised version
of <code class="function">genericLookup</code>!!!</p><p>An example in which using <code class="literal">RULES</code> for
specialisation will Win Big:

</p><pre class="programlisting">
toDouble :: Real a =&gt; a -&gt; Double
toDouble = fromRational . toRational

{-# RULES "toDouble/Int" toDouble = i2d #-}
i2d (I# i) = D# (int2Double# i) -- uses Glasgow prim-op directly
</pre><p>

The <code class="function">i2d</code> function is virtually one machine
instruction; the default conversion&#8212;via an intermediate
<code class="literal">Rational</code>&#8212;is obscenely expensive by
comparison.
</p></div><div class="sect2" title="7.17.6. Controlling what's going on in rewrite rules"><div class="titlepage"><div><div><h3 class="title"><a name="controlling-rules"></a>7.17.6. Controlling what's going on in rewrite rules</h3></div></div></div><p>

</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
Use <code class="option">-ddump-rules</code> to see the rules that are defined
<span class="emphasis"><em>in this module</em></span>.
This includes rules generated by the specialisation pass, but excludes
rules imported from other modules.
</p></li><li class="listitem"><p>
 Use <code class="option">-ddump-simpl-stats</code> to see what rules are being fired.
If you add <code class="option">-dppr-debug</code> you get a more detailed listing.
</p></li><li class="listitem"><p>
 Use <code class="option">-ddump-rule-firings</code> or <code class="option">-ddump-rule-rewrites</code>
to see in great detail what rules are being fired.
If you add <code class="option">-dppr-debug</code> you get a still more detailed listing.
</p></li><li class="listitem"><p>
 The definition of (say) <code class="function">build</code> in <code class="filename">GHC/Base.lhs</code> looks like this:

</p><pre class="programlisting">
        build   :: forall a. (forall b. (a -&gt; b -&gt; b) -&gt; b -&gt; b) -&gt; [a]
        {-# INLINE build #-}
        build g = g (:) []
</pre><p>

Notice the <code class="literal">INLINE</code>!  That prevents <code class="literal">(:)</code> from being inlined when compiling
<code class="literal">PrelBase</code>, so that an importing module will &#8220;see&#8221; the <code class="literal">(:)</code>, and can
match it on the LHS of a rule.  <code class="literal">INLINE</code> prevents any inlining happening
in the RHS of the <code class="literal">INLINE</code> thing.  I regret the delicacy of this.

</p></li><li class="listitem"><p>
 In <code class="filename">libraries/base/GHC/Base.lhs</code> look at the rules for <code class="function">map</code> to
see how to write rules that will do fusion and yet give an efficient
program even if fusion doesn't happen.  More rules in <code class="filename">GHC/List.lhs</code>.
</p></li></ul></div><p>

</p></div><div class="sect2" title="7.17.7. CORE pragma"><div class="titlepage"><div><div><h3 class="title"><a name="core-pragma"></a>7.17.7. CORE pragma</h3></div></div></div><a class="indexterm" name="idp29759072"></a><a class="indexterm" name="idp29759480"></a><a class="indexterm" name="idp29759896"></a><p>
  The external core format supports <span class="quote">&#8220;<span class="quote">Note</span>&#8221;</span> annotations;
  the <code class="literal">CORE</code> pragma gives a way to specify what these
  should be in your Haskell source code.  Syntactically, core
  annotations are attached to expressions and take a Haskell string
  literal as an argument.  The following function definition shows an
  example:

</p><pre class="programlisting">
f x = ({-# CORE "foo" #-} show) ({-# CORE "bar" #-} x)
</pre><p>

  Semantically, this is equivalent to:

</p><pre class="programlisting">
g x = show x
</pre><p>
</p><p>
  However, when external core is generated (via
  <code class="option">-fext-core</code>), there will be Notes attached to the
  expressions <code class="function">show</code> and <code class="varname">x</code>.
  The core function declaration for <code class="function">f</code> is:
</p><pre class="programlisting">
  f :: %forall a . GHCziShow.ZCTShow a -&gt;
                   a -&gt; GHCziBase.ZMZN GHCziBase.Char =
    \ @ a (zddShow::GHCziShow.ZCTShow a) (eta::a) -&gt;
        (%note "foo"
         %case zddShow %of (tpl::GHCziShow.ZCTShow a)
           {GHCziShow.ZCDShow
            (tpl1::GHCziBase.Int -&gt;
                   a -&gt;
                   GHCziBase.ZMZN GHCziBase.Char -&gt; GHCziBase.ZMZN GHCziBase.Cha
r)
            (tpl2::a -&gt; GHCziBase.ZMZN GHCziBase.Char)
            (tpl3::GHCziBase.ZMZN a -&gt;
                   GHCziBase.ZMZN GHCziBase.Char -&gt; GHCziBase.ZMZN GHCziBase.Cha
r) -&gt;
              tpl2})
        (%note "bar"
         eta);
</pre><p>
  Here, we can see that the function <code class="function">show</code> (which
  has been expanded out to a case expression over the Show dictionary)
  has a <code class="literal">%note</code> attached to it, as does the
  expression <code class="varname">eta</code> (which used to be called
  <code class="varname">x</code>).
</p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="pragmas.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ghc-language-features.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="special-ids.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">7.16. Pragmas </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 7.18. Special built-in functions</td></tr></table></div></body></html>
