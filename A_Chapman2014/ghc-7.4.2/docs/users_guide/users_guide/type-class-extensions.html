<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>7.6. Class and instances declarations</title><link rel="stylesheet" href="fptools.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"><link rel="home" href="index.html" title="The Parallel Haskell Compilation System User's Guide, Version 7.4.2"><link rel="up" href="ghc-language-features.html" title="Chapter 7. GHC Language Features"><link rel="prev" href="deriving.html" title='7.5. Extensions to the "deriving" mechanism'><link rel="next" href="type-families.html" title="7.7. Type families"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">7.6. Class and instances declarations</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="deriving.html">Prev</a> </td><th width="60%" align="center">Chapter 7. GHC Language Features</th><td width="20%" align="right"> <a accesskey="n" href="type-families.html">Next</a></td></tr></table><hr></div><div class="sect1" title="7.6. Class and instances declarations"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="type-class-extensions"></a>7.6. Class and instances declarations</h2></div></div></div><div class="sect2" title="7.6.1. Class declarations"><div class="titlepage"><div><div><h3 class="title"><a name="multi-param-type-classes"></a>7.6.1. Class declarations</h3></div></div></div><p>
This section, and the next one, documents GHC's type-class extensions.
There's lots of background in the paper <a class="ulink" href="http://research.microsoft.com/~simonpj/Papers/type-class-design-space/" target="_top">Type
classes: exploring the design space</a> (Simon Peyton Jones, Mark
Jones, Erik Meijer).
</p><div class="sect3" title="7.6.1.1. Multi-parameter type classes"><div class="titlepage"><div><div><h4 class="title"><a name="idp28918256"></a>7.6.1.1. Multi-parameter type classes</h4></div></div></div><p>
Multi-parameter type classes are permitted, with flag <code class="option">-XMultiParamTypeClasses</code>.
For example:


</p><pre class="programlisting">
  class Collection c a where
    union :: c a -&gt; c a -&gt; c a
    ...etc.
</pre><p>

</p></div><div class="sect3" title="7.6.1.2. The superclasses of a class declaration"><div class="titlepage"><div><div><h4 class="title"><a name="superclass-rules"></a>7.6.1.2. The superclasses of a class declaration</h4></div></div></div><p>
In Haskell 98 the context of a class declaration (which introduces superclasses)
must be simple; that is, each predicate must consist of a class applied to
type variables.  The flag <code class="option">-XFlexibleContexts</code>
(<a class="xref" href="other-type-extensions.html#flexible-contexts" title="7.11.2. The context of a type signature">Section 7.11.2, &#8220;The context of a type signature&#8221;</a>)
lifts this restriction,
so that the only restriction on the context in a class declaration is
that the class hierarchy must be acyclic.  So these class declarations are OK:


</p><pre class="programlisting">
  class Functor (m k) =&gt; FiniteMap m k where
    ...

  class (Monad m, Monad (t m)) =&gt; Transform t m where
    lift :: m a -&gt; (t m) a
</pre><p>


</p><p>
As in Haskell 98, The class hierarchy must be acyclic.  However, the definition
of "acyclic" involves only the superclass relationships.  For example,
this is OK:


</p><pre class="programlisting">
  class C a where {
    op :: D b =&gt; a -&gt; b -&gt; b
  }

  class C a =&gt; D a where { ... }
</pre><p>


Here, <code class="literal">C</code> is a superclass of <code class="literal">D</code>, but it's OK for a
class operation <code class="literal">op</code> of <code class="literal">C</code> to mention <code class="literal">D</code>.  (It
would not be OK for <code class="literal">D</code> to be a superclass of <code class="literal">C</code>.)
</p><p>
With the extension that adds a <a class="link" href="constraint-kind.html" title="7.10. The Constraint kind">kind of constraints</a>,
you can write more exotic superclass definitions. The superclass cycle check is even more
liberal in these case. For example, this is OK:

</p><pre class="programlisting">
  class A cls c where
    meth :: cls c =&gt; c -&gt; c

  class A B c =&gt; B c where
</pre><p>

A superclass context for a class <code class="literal">C</code> is allowed if, after expanding
type synonyms to their right-hand-sides, and uses of classes (other than <code class="literal">C</code>)
to their superclasses, <code class="literal">C</code> does not occur syntactically in the context.
</p></div><div class="sect3" title="7.6.1.3. Class method types"><div class="titlepage"><div><div><h4 class="title"><a name="class-method-types"></a>7.6.1.3. Class method types</h4></div></div></div><p>
Haskell 98 prohibits class method types to mention constraints on the
class type variable, thus:
</p><pre class="programlisting">
  class Seq s a where
    fromList :: [a] -&gt; s a
    elem     :: Eq a =&gt; a -&gt; s a -&gt; Bool
</pre><p>
The type of <code class="literal">elem</code> is illegal in Haskell 98, because it
contains the constraint <code class="literal">Eq a</code>, constrains only the
class type variable (in this case <code class="literal">a</code>).
GHC lifts this restriction (flag <code class="option">-XConstrainedClassMethods</code>).
</p></div><div class="sect3" title="7.6.1.4. Default method signatures"><div class="titlepage"><div><div><h4 class="title"><a name="class-default-signatures"></a>7.6.1.4. Default method signatures</h4></div></div></div><p>
Haskell 98 allows you to define a default implementation when declaring a class:
</p><pre class="programlisting">
  class Enum a where
    enum :: [a]
    enum = []
</pre><p>
The type of the <code class="literal">enum</code> method is <code class="literal">[a]</code>, and
this is also the type of the default method. You can lift this restriction
and give another type to the default method using the flag
<code class="option">-XDefaultSignatures</code>. For instance, if you have written a
generic implementation of enumeration in a class <code class="literal">GEnum</code>
with method <code class="literal">genum</code> in terms of <code class="literal">GHC.Generics</code>,
you can specify a default method that uses that generic implementation:
</p><pre class="programlisting">
  class Enum a where
    enum :: [a]
    default enum :: (Generic a, GEnum (Rep a)) =&gt; [a]
    enum = map to genum
</pre><p>
We reuse the keyword <code class="literal">default</code> to signal that a signature
applies to the default method only; when defining instances of the
<code class="literal">Enum</code> class, the original type <code class="literal">[a]</code> of
<code class="literal">enum</code> still applies. When giving an empty instance, however,
the default implementation <code class="literal">map to0 genum</code> is filled-in,
and type-checked with the type
<code class="literal">(Generic a, GEnum (Rep a)) =&gt; [a]</code>.
</p><p>
We use default signatures to simplify generic programming in GHC
(<a class="xref" href="generic-programming.html" title="7.20. Generic programming">Section 7.20, &#8220;Generic programming&#8221;</a>).
</p></div></div><div class="sect2" title="7.6.2. Functional dependencies"><div class="titlepage"><div><div><h3 class="title"><a name="functional-dependencies"></a>7.6.2. Functional dependencies
</h3></div></div></div><p> Functional dependencies are implemented as described by Mark Jones
in &#8220;<a class="ulink" href="http://citeseer.ist.psu.edu/jones00type.html" target="_top">Type Classes with Functional Dependencies</a>&#8221;, Mark P. Jones,
In Proceedings of the 9th European Symposium on Programming,
ESOP 2000, Berlin, Germany, March 2000, Springer-Verlag LNCS 1782,
.
</p><p>
Functional dependencies are introduced by a vertical bar in the syntax of a
class declaration;  e.g.
</p><pre class="programlisting">
  class (Monad m) =&gt; MonadState s m | m -&gt; s where ...

  class Foo a b c | a b -&gt; c where ...
</pre><p>
There should be more documentation, but there isn't (yet).  Yell if you need it.
</p><div class="sect3" title="7.6.2.1. Rules for functional dependencies"><div class="titlepage"><div><div><h4 class="title"><a name="idp28939904"></a>7.6.2.1. Rules for functional dependencies </h4></div></div></div><p>
In a class declaration, all of the class type variables must be reachable (in the sense
mentioned in <a class="xref" href="other-type-extensions.html#flexible-contexts" title="7.11.2. The context of a type signature">Section 7.11.2, &#8220;The context of a type signature&#8221;</a>)
from the free variables of each method type.
For example:

</p><pre class="programlisting">
  class Coll s a where
    empty  :: s
    insert :: s -&gt; a -&gt; s
</pre><p>

is not OK, because the type of <code class="literal">empty</code> doesn't mention
<code class="literal">a</code>.  Functional dependencies can make the type variable
reachable:
</p><pre class="programlisting">
  class Coll s a | s -&gt; a where
    empty  :: s
    insert :: s -&gt; a -&gt; s
</pre><p>

Alternatively <code class="literal">Coll</code> might be rewritten

</p><pre class="programlisting">
  class Coll s a where
    empty  :: s a
    insert :: s a -&gt; a -&gt; s a
</pre><p>


which makes the connection between the type of a collection of
<code class="literal">a</code>'s (namely <code class="literal">(s a)</code>) and the element type <code class="literal">a</code>.
Occasionally this really doesn't work, in which case you can split the
class like this:


</p><pre class="programlisting">
  class CollE s where
    empty  :: s

  class CollE s =&gt; Coll s a where
    insert :: s -&gt; a -&gt; s
</pre><p>
</p></div><div class="sect3" title="7.6.2.2. Background on functional dependencies"><div class="titlepage"><div><div><h4 class="title"><a name="idp28945080"></a>7.6.2.2. Background on functional dependencies</h4></div></div></div><p>The following description of the motivation and use of functional dependencies is taken
from the Hugs user manual, reproduced here (with minor changes) by kind
permission of Mark Jones.
</p><p>
Consider the following class, intended as part of a
library for collection types:
</p><pre class="programlisting">
   class Collects e ce where
       empty  :: ce
       insert :: e -&gt; ce -&gt; ce
       member :: e -&gt; ce -&gt; Bool
</pre><p>
The type variable e used here represents the element type, while ce is the type
of the container itself. Within this framework, we might want to define
instances of this class for lists or characteristic functions (both of which
can be used to represent collections of any equality type), bit sets (which can
be used to represent collections of characters), or hash tables (which can be
used to represent any collection whose elements have a hash function). Omitting
standard implementation details, this would lead to the following declarations:
</p><pre class="programlisting">
   instance Eq e =&gt; Collects e [e] where ...
   instance Eq e =&gt; Collects e (e -&gt; Bool) where ...
   instance Collects Char BitSet where ...
   instance (Hashable e, Collects a ce)
              =&gt; Collects e (Array Int ce) where ...
</pre><p>
All this looks quite promising; we have a class and a range of interesting
implementations. Unfortunately, there are some serious problems with the class
declaration. First, the empty function has an ambiguous type:
</p><pre class="programlisting">
   empty :: Collects e ce =&gt; ce
</pre><p>
By "ambiguous" we mean that there is a type variable e that appears on the left
of the <code class="literal">=&gt;</code> symbol, but not on the right. The problem with
this is that, according to the theoretical foundations of Haskell overloading,
we cannot guarantee a well-defined semantics for any term with an ambiguous
type.
</p><p>
We can sidestep this specific problem by removing the empty member from the
class declaration. However, although the remaining members, insert and member,
do not have ambiguous types, we still run into problems when we try to use
them. For example, consider the following two functions:
</p><pre class="programlisting">
   f x y = insert x . insert y
   g     = f True 'a'
</pre><p>
for which GHC infers the following types:
</p><pre class="programlisting">
   f :: (Collects a c, Collects b c) =&gt; a -&gt; b -&gt; c -&gt; c
   g :: (Collects Bool c, Collects Char c) =&gt; c -&gt; c
</pre><p>
Notice that the type for f allows the two parameters x and y to be assigned
different types, even though it attempts to insert each of the two values, one
after the other, into the same collection. If we're trying to model collections
that contain only one type of value, then this is clearly an inaccurate
type. Worse still, the definition for g is accepted, without causing a type
error. As a result, the error in this code will not be flagged at the point
where it appears. Instead, it will show up only when we try to use g, which
might even be in a different module.
</p><div class="sect4" title="7.6.2.2.1. An attempt to use constructor classes"><div class="titlepage"><div><div><h5 class="title"><a name="idp28950936"></a>7.6.2.2.1. An attempt to use constructor classes</h5></div></div></div><p>
Faced with the problems described above, some Haskell programmers might be
tempted to use something like the following version of the class declaration:
</p><pre class="programlisting">
   class Collects e c where
      empty  :: c e
      insert :: e -&gt; c e -&gt; c e
      member :: e -&gt; c e -&gt; Bool
</pre><p>
The key difference here is that we abstract over the type constructor c that is
used to form the collection type c e, and not over that collection type itself,
represented by ce in the original class declaration. This avoids the immediate
problems that we mentioned above: empty has type <code class="literal">Collects e c =&gt; c
e</code>, which is not ambiguous.
</p><p>
The function f from the previous section has a more accurate type:
</p><pre class="programlisting">
   f :: (Collects e c) =&gt; e -&gt; e -&gt; c e -&gt; c e
</pre><p>
The function g from the previous section is now rejected with a type error as
we would hope because the type of f does not allow the two arguments to have
different types.
This, then, is an example of a multiple parameter class that does actually work
quite well in practice, without ambiguity problems.
There is, however, a catch. This version of the Collects class is nowhere near
as general as the original class seemed to be: only one of the four instances
for <code class="literal">Collects</code>
given above can be used with this version of Collects because only one of
them---the instance for lists---has a collection type that can be written in
the form c e, for some type constructor c, and element type e.
</p></div><div class="sect4" title="7.6.2.2.2. Adding functional dependencies"><div class="titlepage"><div><div><h5 class="title"><a name="idp28954496"></a>7.6.2.2.2. Adding functional dependencies</h5></div></div></div><p>
To get a more useful version of the Collects class, Hugs provides a mechanism
that allows programmers to specify dependencies between the parameters of a
multiple parameter class (For readers with an interest in theoretical
foundations and previous work: The use of dependency information can be seen
both as a generalization of the proposal for `parametric type classes' that was
put forward by Chen, Hudak, and Odersky, or as a special case of Mark Jones's
later framework for "improvement" of qualified types. The
underlying ideas are also discussed in a more theoretical and abstract setting
in a manuscript [implparam], where they are identified as one point in a
general design space for systems of implicit parameterization.).

To start with an abstract example, consider a declaration such as:
</p><pre class="programlisting">
   class C a b where ...
</pre><p>
which tells us simply that C can be thought of as a binary relation on types
(or type constructors, depending on the kinds of a and b). Extra clauses can be
included in the definition of classes to add information about dependencies
between parameters, as in the following examples:
</p><pre class="programlisting">
   class D a b | a -&gt; b where ...
   class E a b | a -&gt; b, b -&gt; a where ...
</pre><p>
The notation <code class="literal">a -&gt; b</code> used here between the | and where
symbols --- not to be
confused with a function type --- indicates that the a parameter uniquely
determines the b parameter, and might be read as "a determines b." Thus D is
not just a relation, but actually a (partial) function. Similarly, from the two
dependencies that are included in the definition of E, we can see that E
represents a (partial) one-one mapping between types.
</p><p>
More generally, dependencies take the form <code class="literal">x1 ... xn -&gt; y1 ... ym</code>,
where x1, ..., xn, and y1, ..., yn are type variables with n&gt;0 and
m&gt;=0, meaning that the y parameters are uniquely determined by the x
parameters. Spaces can be used as separators if more than one variable appears
on any single side of a dependency, as in <code class="literal">t -&gt; a b</code>. Note that a class may be
annotated with multiple dependencies using commas as separators, as in the
definition of E above. Some dependencies that we can write in this notation are
redundant, and will be rejected because they don't serve any useful
purpose, and may instead indicate an error in the program. Examples of
dependencies like this include  <code class="literal">a -&gt; a </code>,
<code class="literal">a -&gt; a a </code>,
<code class="literal">a -&gt; </code>, etc. There can also be
some redundancy if multiple dependencies are given, as in
<code class="literal">a-&gt;b</code>,
 <code class="literal">b-&gt;c </code>,  <code class="literal">a-&gt;c </code>, and
in which some subset implies the remaining dependencies. Examples like this are
not treated as errors. Note that dependencies appear only in class
declarations, and not in any other part of the language. In particular, the
syntax for instance declarations, class constraints, and types is completely
unchanged.
</p><p>
By including dependencies in a class declaration, we provide a mechanism for
the programmer to specify each multiple parameter class more precisely. The
compiler, on the other hand, is responsible for ensuring that the set of
instances that are in scope at any given point in the program is consistent
with any declared dependencies. For example, the following pair of instance
declarations cannot appear together in the same scope because they violate the
dependency for D, even though either one on its own would be acceptable:
</p><pre class="programlisting">
   instance D Bool Int where ...
   instance D Bool Char where ...
</pre><p>
Note also that the following declaration is not allowed, even by itself:
</p><pre class="programlisting">
   instance D [a] b where ...
</pre><p>
The problem here is that this instance would allow one particular choice of [a]
to be associated with more than one choice for b, which contradicts the
dependency specified in the definition of D. More generally, this means that,
in any instance of the form:
</p><pre class="programlisting">
   instance D t s where ...
</pre><p>
for some particular types t and s, the only variables that can appear in s are
the ones that appear in t, and hence, if the type t is known, then s will be
uniquely determined.
</p><p>
The benefit of including dependency information is that it allows us to define
more general multiple parameter classes, without ambiguity problems, and with
the benefit of more accurate types. To illustrate this, we return to the
collection class example, and annotate the original definition of <code class="literal">Collects</code>
with a simple dependency:
</p><pre class="programlisting">
   class Collects e ce | ce -&gt; e where
      empty  :: ce
      insert :: e -&gt; ce -&gt; ce
      member :: e -&gt; ce -&gt; Bool
</pre><p>
The dependency <code class="literal">ce -&gt; e</code> here specifies that the type e of elements is uniquely
determined by the type of the collection ce. Note that both parameters of
Collects are of kind *; there are no constructor classes here. Note too that
all of the instances of Collects that we gave earlier can be used
together with this new definition.
</p><p>
What about the ambiguity problems that we encountered with the original
definition? The empty function still has type Collects e ce =&gt; ce, but it is no
longer necessary to regard that as an ambiguous type: Although the variable e
does not appear on the right of the =&gt; symbol, the dependency for class
Collects tells us that it is uniquely determined by ce, which does appear on
the right of the =&gt; symbol. Hence the context in which empty is used can still
give enough information to determine types for both ce and e, without
ambiguity. More generally, we need only regard a type as ambiguous if it
contains a variable on the left of the =&gt; that is not uniquely determined
(either directly or indirectly) by the variables on the right.
</p><p>
Dependencies also help to produce more accurate types for user defined
functions, and hence to provide earlier detection of errors, and less cluttered
types for programmers to work with. Recall the previous definition for a
function f:
</p><pre class="programlisting">
   f x y = insert x y = insert x . insert y
</pre><p>
for which we originally obtained a type:
</p><pre class="programlisting">
   f :: (Collects a c, Collects b c) =&gt; a -&gt; b -&gt; c -&gt; c
</pre><p>
Given the dependency information that we have for Collects, however, we can
deduce that a and b must be equal because they both appear as the second
parameter in a Collects constraint with the same first parameter c. Hence we
can infer a shorter and more accurate type for f:
</p><pre class="programlisting">
   f :: (Collects a c) =&gt; a -&gt; a -&gt; c -&gt; c
</pre><p>
In a similar way, the earlier definition of g will now be flagged as a type error.
</p><p>
Although we have given only a few examples here, it should be clear that the
addition of dependency information can help to make multiple parameter classes
more useful in practice, avoiding ambiguity problems, and allowing more general
sets of instance declarations.
</p></div></div></div><div class="sect2" title="7.6.3. Instance declarations"><div class="titlepage"><div><div><h3 class="title"><a name="instance-decls"></a>7.6.3. Instance declarations</h3></div></div></div><p>An instance declaration has the form
</p><pre class="screen">
  instance ( <em class="replaceable"><code>assertion</code></em><sub>1</sub>, ..., <em class="replaceable"><code>assertion</code></em><sub>n</sub>) =&gt; <em class="replaceable"><code>class</code></em> <em class="replaceable"><code>type</code></em><sub>1</sub> ... <em class="replaceable"><code>type</code></em><sub>m</sub> where ...
</pre><p>
The part before the "<code class="literal">=&gt;</code>" is the
<span class="emphasis"><em>context</em></span>, while the part after the
"<code class="literal">=&gt;</code>" is the <span class="emphasis"><em>head</em></span> of the instance declaration.
</p><div class="sect3" title="7.6.3.1. Relaxed rules for the instance head"><div class="titlepage"><div><div><h4 class="title"><a name="flexible-instance-head"></a>7.6.3.1. Relaxed rules for the instance head</h4></div></div></div><p>
In Haskell 98 the head of an instance declaration
must be of the form <code class="literal">C (T a1 ... an)</code>, where
<code class="literal">C</code> is the class, <code class="literal">T</code> is a data type constructor,
and the <code class="literal">a1 ... an</code> are distinct type variables.
GHC relaxes these rules in two ways.
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
The <code class="option">-XFlexibleInstances</code> flag allows the head of the instance
declaration to mention arbitrary nested types.
For example, this becomes a legal instance declaration
</p><pre class="programlisting">
  instance C (Maybe Int) where ...
</pre><p>
See also the <a class="link" href="type-class-extensions.html#instance-overlap" title="7.6.3.4. Overlapping instances">rules on overlap</a>.
</p></li><li class="listitem"><p>
With the <code class="option">-XTypeSynonymInstances</code> flag, instance heads may use type
synonyms. As always, using a type synonym is just shorthand for
writing the RHS of the type synonym definition.  For example:


</p><pre class="programlisting">
  type Point = (Int,Int)
  instance C Point   where ...
  instance C [Point] where ...
</pre><p>


is legal.  However, if you added


</p><pre class="programlisting">
  instance C (Int,Int) where ...
</pre><p>


as well, then the compiler will complain about the overlapping
(actually, identical) instance declarations.  As always, type synonyms
must be fully applied.  You cannot, for example, write:

</p><pre class="programlisting">
  type P a = [[a]]
  instance Monad P where ...
</pre><p>

</p></li></ul></div><p>
</p></div><div class="sect3" title="7.6.3.2. Relaxed rules for instance contexts"><div class="titlepage"><div><div><h4 class="title"><a name="instance-rules"></a>7.6.3.2. Relaxed rules for instance contexts</h4></div></div></div><p>In Haskell 98, the assertions in the context of the instance declaration
must be of the form <code class="literal">C a</code> where <code class="literal">a</code>
is a type variable that occurs in the head.
</p><p>
The <code class="option">-XFlexibleContexts</code> flag relaxes this rule, as well
as the corresponding rule for type signatures (see <a class="xref" href="other-type-extensions.html#flexible-contexts" title="7.11.2. The context of a type signature">Section 7.11.2, &#8220;The context of a type signature&#8221;</a>).
With this flag the context of the instance declaration can each consist of arbitrary
(well-kinded) assertions <code class="literal">(C t1 ... tn)</code> subject only to the
following rules:
</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
The Paterson Conditions: for each assertion in the context
</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p>No type variable has more occurrences in the assertion than in the head</p></li><li class="listitem"><p>The assertion has fewer constructors and variables (taken together
      and counting repetitions) than the head</p></li></ol></div><p>
</p></li><li class="listitem"><p>The Coverage Condition.  For each functional dependency,
<em class="replaceable"><code>tvs</code></em><sub>left</sub> <code class="literal">-&gt;</code>
<em class="replaceable"><code>tvs</code></em><sub>right</sub>,  of the class,
every type variable in
S(<em class="replaceable"><code>tvs</code></em><sub>right</sub>) must appear in
S(<em class="replaceable"><code>tvs</code></em><sub>left</sub>), where S is the
substitution mapping each type variable in the class declaration to the
corresponding type in the instance declaration.
</p></li></ol></div><p>
These restrictions ensure that context reduction terminates: each reduction
step makes the problem smaller by at least one
constructor.  Both the Paterson Conditions and the Coverage Condition are lifted
if you give the <code class="option">-XUndecidableInstances</code>
flag (<a class="xref" href="type-class-extensions.html#undecidable-instances" title="7.6.3.3. Undecidable instances">Section 7.6.3.3, &#8220;Undecidable instances&#8221;</a>).
You can find lots of background material about the reason for these
restrictions in the paper <a class="ulink" href="http://research.microsoft.com/%7Esimonpj/papers/fd%2Dchr/" target="_top">
Understanding functional dependencies via Constraint Handling Rules</a>.
</p><p>
For example, these are OK:
</p><pre class="programlisting">
  instance C Int [a]          -- Multiple parameters
  instance Eq (S [a])         -- Structured type in head

      -- Repeated type variable in head
  instance C4 a a =&gt; C4 [a] [a]
  instance Stateful (ST s) (MutVar s)

      -- Head can consist of type variables only
  instance C a
  instance (Eq a, Show b) =&gt; C2 a b

      -- Non-type variables in context
  instance Show (s a) =&gt; Show (Sized s a)
  instance C2 Int a =&gt; C3 Bool [a]
  instance C2 Int a =&gt; C3 [a] b
</pre><p>
But these are not:
</p><pre class="programlisting">
      -- Context assertion no smaller than head
  instance C a =&gt; C a where ...
      -- (C b b) has more occurrences of b than the head
  instance C b b =&gt; Foo [b] where ...
</pre><p>
</p><p>
The same restrictions apply to instances generated by
<code class="literal">deriving</code> clauses.  Thus the following is accepted:
</p><pre class="programlisting">
  data MinHeap h a = H a (h a)
    deriving (Show)
</pre><p>
because the derived instance
</p><pre class="programlisting">
  instance (Show a, Show (h a)) =&gt; Show (MinHeap h a)
</pre><p>
conforms to the above rules.
</p><p>
A useful idiom permitted by the above rules is as follows.
If one allows overlapping instance declarations then it's quite
convenient to have a "default instance" declaration that applies if
something more specific does not:
</p><pre class="programlisting">
  instance C a where
    op = ... -- Default
</pre><p>
</p></div><div class="sect3" title="7.6.3.3. Undecidable instances"><div class="titlepage"><div><div><h4 class="title"><a name="undecidable-instances"></a>7.6.3.3. Undecidable instances</h4></div></div></div><p>
Sometimes even the rules of <a class="xref" href="type-class-extensions.html#instance-rules" title="7.6.3.2. Relaxed rules for instance contexts">Section 7.6.3.2, &#8220;Relaxed rules for instance contexts&#8221;</a> are too onerous.
For example, sometimes you might want to use the following to get the
effect of a "class synonym":
</p><pre class="programlisting">
  class (C1 a, C2 a, C3 a) =&gt; C a where { }

  instance (C1 a, C2 a, C3 a) =&gt; C a where { }
</pre><p>
This allows you to write shorter signatures:
</p><pre class="programlisting">
  f :: C a =&gt; ...
</pre><p>
instead of
</p><pre class="programlisting">
  f :: (C1 a, C2 a, C3 a) =&gt; ...
</pre><p>
The restrictions on functional dependencies (<a class="xref" href="type-class-extensions.html#functional-dependencies" title="7.6.2. Functional dependencies">Section 7.6.2, &#8220;Functional dependencies
&#8221;</a>) are particularly troublesome.
It is tempting to introduce type variables in the context that do not appear in
the head, something that is excluded by the normal rules. For example:
</p><pre class="programlisting">
  class HasConverter a b | a -&gt; b where
     convert :: a -&gt; b

  data Foo a = MkFoo a

  instance (HasConverter a b,Show b) =&gt; Show (Foo a) where
     show (MkFoo value) = show (convert value)
</pre><p>
This is dangerous territory, however. Here, for example, is a program that would make the
typechecker loop:
</p><pre class="programlisting">
  class D a
  class F a b | a-&gt;b
  instance F [a] [[a]]
  instance (D c, F a c) =&gt; D [a]   -- 'c' is not mentioned in the head
</pre><p>
Similarly, it can be tempting to lift the coverage condition:
</p><pre class="programlisting">
  class Mul a b c | a b -&gt; c where
  	(.*.) :: a -&gt; b -&gt; c

  instance Mul Int Int Int where (.*.) = (*)
  instance Mul Int Float Float where x .*. y = fromIntegral x * y
  instance Mul a b c =&gt; Mul a [b] [c] where x .*. v = map (x.*.) v
</pre><p>
The third instance declaration does not obey the coverage condition;
and indeed the (somewhat strange) definition:
</p><pre class="programlisting">
  f = \ b x y -&gt; if b then x .*. [y] else y
</pre><p>
makes instance inference go into a loop, because it requires the constraint
<code class="literal">(Mul a [b] b)</code>.
</p><p>
Nevertheless, GHC allows you to experiment with more liberal rules.  If you use
the experimental flag <code class="option">-XUndecidableInstances</code>
<a class="indexterm" name="idp28999464"></a>,
both the Paterson Conditions and the Coverage Condition
(described in <a class="xref" href="type-class-extensions.html#instance-rules" title="7.6.3.2. Relaxed rules for instance contexts">Section 7.6.3.2, &#8220;Relaxed rules for instance contexts&#8221;</a>) are lifted.  Termination is ensured by having a
fixed-depth recursion stack.  If you exceed the stack depth you get a
sort of backtrace, and the opportunity to increase the stack depth
with <code class="option">-fcontext-stack=</code><span class="emphasis"><em>N</em></span>.
</p></div><div class="sect3" title="7.6.3.4. Overlapping instances"><div class="titlepage"><div><div><h4 class="title"><a name="instance-overlap"></a>7.6.3.4. Overlapping instances</h4></div></div></div><p>
In general, <span class="emphasis"><em>GHC requires that that it be unambiguous which instance
declaration
should be used to resolve a type-class constraint</em></span>. This behaviour
can be modified by two flags: <code class="option">-XOverlappingInstances</code>
<a class="indexterm" name="idp29002312"></a>
and <code class="option">-XIncoherentInstances</code>
<a class="indexterm" name="idp29002976"></a>, as this section discusses.  Both these
flags are dynamic flags, and can be set on a per-module basis, using
an <code class="literal">OPTIONS_GHC</code> pragma if desired (<a class="xref" href="ch04s02.html#source-file-options" title="4.2.2. Command line options in source files">Section 4.2.2, &#8220;Command line options in source files&#8221;</a>).</p><p>
When GHC tries to resolve, say, the constraint <code class="literal">C Int Bool</code>,
it tries to match every instance declaration against the
constraint,
by instantiating the head of the instance declaration.  For example, consider
these declarations:
</p><pre class="programlisting">
  instance context1 =&gt; C Int a     where ...  -- (A)
  instance context2 =&gt; C a   Bool  where ...  -- (B)
  instance context3 =&gt; C Int [a]   where ...  -- (C)
  instance context4 =&gt; C Int [Int] where ...  -- (D)
</pre><p>
The instances (A) and (B) match the constraint <code class="literal">C Int Bool</code>,
but (C) and (D) do not.  When matching, GHC takes
no account of the context of the instance declaration
(<code class="literal">context1</code> etc).
GHC's default behaviour is that <span class="emphasis"><em>exactly one instance must match the
constraint it is trying to resolve</em></span>.
It is fine for there to be a <span class="emphasis"><em>potential</em></span> of overlap (by
including both declarations (A) and (B), say); an error is only reported if a
particular constraint matches more than one.
</p><p>
The <code class="option">-XOverlappingInstances</code> flag instructs GHC to allow
more than one instance to match, provided there is a most specific one.  For
example, the constraint <code class="literal">C Int [Int]</code> matches instances (A),
(C) and (D), but the last is more specific, and hence is chosen.  If there is no
most-specific match, the program is rejected.
</p><p>
However, GHC is conservative about committing to an overlapping instance.  For example:
</p><pre class="programlisting">
  f :: [b] -&gt; [b]
  f x = ...
</pre><p>
Suppose that from the RHS of <code class="literal">f</code> we get the constraint
<code class="literal">C Int [b]</code>.  But
GHC does not commit to instance (C), because in a particular
call of <code class="literal">f</code>, <code class="literal">b</code> might be instantiate
to <code class="literal">Int</code>, in which case instance (D) would be more specific still.
So GHC rejects the program.
(If you add the flag <code class="option">-XIncoherentInstances</code>,
GHC will instead pick (C), without complaining about
the problem of subsequent instantiations.)
</p><p>
Notice that we gave a type signature to <code class="literal">f</code>, so GHC had to
<span class="emphasis"><em>check</em></span> that <code class="literal">f</code> has the specified type.
Suppose instead we do not give a type signature, asking GHC to <span class="emphasis"><em>infer</em></span>
it instead.  In this case, GHC will refrain from
simplifying the constraint <code class="literal">C Int [b]</code> (for the same reason
as before) but, rather than rejecting the program, it will infer the type
</p><pre class="programlisting">
  f :: C Int [b] =&gt; [b] -&gt; [b]
</pre><p>
That postpones the question of which instance to pick to the
call site for <code class="literal">f</code>
by which time more is known about the type <code class="literal">b</code>.
You can write this type signature yourself if you use the
<a class="link" href="other-type-extensions.html#flexible-contexts" title="7.11.2. The context of a type signature"><code class="option">-XFlexibleContexts</code></a>
flag.
</p><p>
Exactly the same situation can arise in instance declarations themselves.  Suppose we have
</p><pre class="programlisting">
  class Foo a where
     f :: a -&gt; a
  instance Foo [b] where
     f x = ...
</pre><p>
and, as before, the constraint <code class="literal">C Int [b]</code> arises from <code class="literal">f</code>'s
right hand side.  GHC will reject the instance, complaining as before that it does not know how to resolve
the constraint <code class="literal">C Int [b]</code>, because it matches more than one instance
declaration.  The solution is to postpone the choice by adding the constraint to the context
of the instance declaration, thus:
</p><pre class="programlisting">
  instance C Int [b] =&gt; Foo [b] where
     f x = ...
</pre><p>
(You need <a class="link" href="type-class-extensions.html#instance-rules" title="7.6.3.2. Relaxed rules for instance contexts"><code class="option">-XFlexibleInstances</code></a> to do this.)
</p><p>
Warning: overlapping instances must be used with care.  They
can give rise to incoherence (i.e. different instance choices are made
in different parts of the program) even without <code class="option">-XIncoherentInstances</code>. Consider:
</p><pre class="programlisting">
{-# LANGUAGE OverlappingInstances #-}
module Help where

    class MyShow a where
      myshow :: a -&gt; String

    instance MyShow a =&gt; MyShow [a] where
      myshow xs = concatMap myshow xs

    showHelp :: MyShow a =&gt; [a] -&gt; String
    showHelp xs = myshow xs

{-# LANGUAGE FlexibleInstances, OverlappingInstances #-}
module Main where
    import Help

    data T = MkT

    instance MyShow T where
      myshow x = "Used generic instance"

    instance MyShow [T] where
      myshow xs = "Used more specific instance"

    main = do { print (myshow [MkT]); print (showHelp [MkT]) }
</pre><p>
In function <code class="literal">showHelp</code> GHC sees no overlapping
instances, and so uses the <code class="literal">MyShow [a]</code> instance
without complaint.  In the call to <code class="literal">myshow</code> in <code class="literal">main</code>,
GHC resolves the <code class="literal">MyShow [T]</code> constraint using the overlapping
instance declaration in module <code class="literal">Main</code>. As a result,
the program prints
</p><pre class="programlisting">
  "Used more specific instance"
  "Used generic instance"
</pre><p>
(An alternative possible behaviour, not currently implemented,
would be to reject module <code class="literal">Help</code>
on the grounds that a later instance declaration might overlap the local one.)
</p><p>
The willingness to be overlapped or incoherent is a property of
the <span class="emphasis"><em>instance declaration</em></span> itself, controlled by the
presence or otherwise of the <code class="option">-XOverlappingInstances</code>
and <code class="option">-XIncoherentInstances</code> flags when that module is
being defined.  Specifically, during the lookup process:
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
If the constraint being looked up matches two instance declarations IA and IB,
and
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>IB is a substitution instance of IA (but not vice versa);
that is, IB is strictly more specific than IA</p></li><li class="listitem"><p>either IA or IB was compiled with <code class="option">-XOverlappingInstances</code></p></li></ul></div><p>
then the less-specific instance IA is ignored.
</p></li><li class="listitem"><p>
Suppose an instance declaration does not match the constraint being looked up, but
does <span class="emphasis"><em>unify</em></span> with it, so that it might match when the constraint is further
instantiated.  Usually GHC will regard this as a reason for not committing to
some other constraint.  But if the instance declaration was compiled with
<code class="option">-XIncoherentInstances</code>, GHC will skip the "does-it-unify?"
check for that declaration.
</p></li></ul></div><p>
These rules make it possible for a library author to design a library that relies on
overlapping instances without the library client having to know.
</p><p>The <code class="option">-XIncoherentInstances</code> flag implies the
<code class="option">-XOverlappingInstances</code> flag, but not vice versa.
</p></div></div><div class="sect2" title="7.6.4. Overloaded string literals"><div class="titlepage"><div><div><h3 class="title"><a name="overloaded-strings"></a>7.6.4. Overloaded string literals
</h3></div></div></div><p>
GHC supports <span class="emphasis"><em>overloaded string literals</em></span>.  Normally a
string literal has type <code class="literal">String</code>, but with overloaded string
literals enabled (with <code class="literal">-XOverloadedStrings</code>)
 a string literal has type <code class="literal">(IsString a) =&gt; a</code>.
</p><p>
  This means that the usual string syntax can be used, e.g.,
  for <code class="literal">ByteString</code>, <code class="literal">Text</code>,
and other variations of string like types.  String literals behave very much
like integer literals, i.e., they can be used in both expressions and patterns.
If used in a pattern the literal with be replaced by an equality test, in the same
way as an integer literal is.
</p><p>
The class <code class="literal">IsString</code> is defined as:
</p><pre class="programlisting">
class IsString a where
    fromString :: String -&gt; a
</pre><p>
The only predefined instance is the obvious one to make strings work as usual:
</p><pre class="programlisting">
instance IsString [Char] where
    fromString cs = cs
</pre><p>
The class <code class="literal">IsString</code> is not in scope by default.  If you want to mention
it explicitly (for example, to give an instance declaration for it), you can import it
from module <code class="literal">GHC.Exts</code>.
</p><p>
Haskell's defaulting mechanism is extended to cover string literals, when <code class="option">-XOverloadedStrings</code> is specified.
Specifically:
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
Each type in a default declaration must be an
instance of <code class="literal">Num</code> <span class="emphasis"><em>or</em></span> of <code class="literal">IsString</code>.
</p></li><li class="listitem"><p>
The standard defaulting rule (<a class="ulink" href="http://www.haskell.org/onlinereport/decls.html#sect4.3.4" target="_top">Haskell Report, Section 4.3.4</a>)
is extended thus: defaulting applies when all the unresolved constraints involve standard classes
<span class="emphasis"><em>or</em></span> <code class="literal">IsString</code>; and at least one is a numeric class
<span class="emphasis"><em>or</em></span> <code class="literal">IsString</code>.
</p></li></ul></div><p>
</p><p>
A small example:
</p><pre class="programlisting">
module Main where

import GHC.Exts( IsString(..) )

newtype MyString = MyString String deriving (Eq, Show)
instance IsString MyString where
    fromString = MyString

greet :: MyString -&gt; MyString
greet "hello" = "world"
greet other = other

main = do
    print $ greet "hello"
    print $ greet "fool"
</pre><p>
</p><p>
Note that deriving <code class="literal">Eq</code> is necessary for the pattern matching
to work since it gets translated into an equality comparison.
</p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="deriving.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ghc-language-features.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="type-families.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">7.5. Extensions to the "deriving" mechanism </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 7.7. Type families</td></tr></table></div></body></html>
