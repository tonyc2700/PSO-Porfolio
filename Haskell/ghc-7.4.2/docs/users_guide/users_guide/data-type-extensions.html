<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>7.4. Extensions to data types and type synonyms</title><link rel="stylesheet" href="fptools.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"><link rel="home" href="index.html" title="The Parallel Haskell Compilation System User's Guide, Version 7.4.2"><link rel="up" href="ghc-language-features.html" title="Chapter 7. GHC Language Features"><link rel="prev" href="syntax-extns.html" title="7.3. Syntactic extensions"><link rel="next" href="deriving.html" title='7.5. Extensions to the "deriving" mechanism'></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">7.4. Extensions to data types and type synonyms</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="syntax-extns.html">Prev</a> </td><th width="60%" align="center">Chapter 7. GHC Language Features</th><td width="20%" align="right"> <a accesskey="n" href="deriving.html">Next</a></td></tr></table><hr></div><div class="sect1" title="7.4. Extensions to data types and type synonyms"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="data-type-extensions"></a>7.4. Extensions to data types and type synonyms</h2></div></div></div><div class="sect2" title="7.4.1. Data types with no constructors"><div class="titlepage"><div><div><h3 class="title"><a name="nullary-types"></a>7.4.1. Data types with no constructors</h3></div></div></div><p>With the <code class="option">-XEmptyDataDecls</code> flag (or equivalent LANGUAGE pragma),
GHC lets you declare a data type with no constructors.  For example:</p><pre class="programlisting">
  data S      -- S :: *
  data T a    -- T :: * -&gt; *
</pre><p>Syntactically, the declaration lacks the "= constrs" part.  The
type can be parameterised over types of any kind, but if the kind is
not <code class="literal">*</code> then an explicit kind annotation must be used
(see <a class="xref" href="other-type-extensions.html#kinding" title="7.11.4. Explicitly-kinded quantification">Section 7.11.4, &#8220;Explicitly-kinded quantification&#8221;</a>).</p><p>Such data types have only one value, namely bottom.
Nevertheless, they can be useful when defining "phantom types".</p></div><div class="sect2" title="7.4.2. Data type contexts"><div class="titlepage"><div><div><h3 class="title"><a name="datatype-contexts"></a>7.4.2. Data type contexts</h3></div></div></div><p>Haskell allows datatypes to be given contexts, e.g.</p><pre class="programlisting">
data Eq a =&gt; Set a = NilSet | ConsSet a (Set a)
</pre><p>give constructors with types:</p><pre class="programlisting">
NilSet :: Set a
ConsSet :: Eq a =&gt; a -&gt; Set a -&gt; Set a
</pre><p>This is widely considered a misfeature, and is going to be removed from
the language.  In GHC, it is controlled by the deprecated extension
<code class="literal">DatatypeContexts</code>.</p></div><div class="sect2" title="7.4.3. Infix type constructors, classes, and type variables"><div class="titlepage"><div><div><h3 class="title"><a name="infix-tycons"></a>7.4.3. Infix type constructors, classes, and type variables</h3></div></div></div><p>
GHC allows type constructors, classes, and type variables to be operators, and
to be written infix, very much like expressions.  More specifically:
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
  A type constructor or class can be an operator, beginning with a colon; e.g. <code class="literal">:*:</code>.
  The lexical syntax is the same as that for data constructors.
  </p></li><li class="listitem"><p>
  Data type and type-synonym declarations can be written infix, parenthesised
  if you want further arguments.  E.g.
</p><pre class="screen">
  data a :*: b = Foo a b
  type a :+: b = Either a b
  class a :=: b where ...

  data (a :**: b) x = Baz a b x
  type (a :++: b) y = Either (a,b) y
</pre><p>
  </p></li><li class="listitem"><p>
  Types, and class constraints, can be written infix.  For example
  </p><pre class="screen">
	x :: Int :*: Bool
        f :: (a :=: b) =&gt; a -&gt; b
  </pre><p>
  </p></li><li class="listitem"><p>
  A type variable can be an (unqualified) operator e.g. <code class="literal">+</code>.
  The lexical syntax is the same as that for variable operators, excluding "(.)",
  "(!)", and "(*)".  In a binding position, the operator must be
  parenthesised.  For example:
</p><pre class="programlisting">
   type T (+) = Int + Int
   f :: T Either
   f = Left 3

   liftA2 :: Arrow (~&gt;)
	  =&gt; (a -&gt; b -&gt; c) -&gt; (e ~&gt; a) -&gt; (e ~&gt; b) -&gt; (e ~&gt; c)
   liftA2 = ...
</pre><p>
  </p></li><li class="listitem"><p>
  Back-quotes work
  as for expressions, both for type constructors and type variables;  e.g. <code class="literal">Int `Either` Bool</code>, or
  <code class="literal">Int `a` Bool</code>.  Similarly, parentheses work the same; e.g.  <code class="literal">(:*:) Int Bool</code>.
  </p></li><li class="listitem"><p>
  Fixities may be declared for type constructors, or classes, just as for data constructors.  However,
  one cannot distinguish between the two in a fixity declaration; a fixity declaration
  sets the fixity for a data constructor and the corresponding type constructor.  For example:
</p><pre class="screen">
  infixl 7 T, :*:
</pre><p>
  sets the fixity for both type constructor <code class="literal">T</code> and data constructor <code class="literal">T</code>,
  and similarly for <code class="literal">:*:</code>.
  <code class="literal">Int `a` Bool</code>.
  </p></li><li class="listitem"><p>
  Function arrow is <code class="literal">infixr</code> with fixity 0.  (This might change; I'm not sure what it should be.)
  </p></li></ul></div><p>
</p></div><div class="sect2" title="7.4.4. Liberalised type synonyms"><div class="titlepage"><div><div><h3 class="title"><a name="type-synonyms"></a>7.4.4. Liberalised type synonyms</h3></div></div></div><p>
Type synonyms are like macros at the type level, but Haskell 98 imposes many rules
on individual synonym declarations.
With the <code class="option">-XLiberalTypeSynonyms</code> extension,
GHC does validity checking on types <span class="emphasis"><em>only after expanding type synonyms</em></span>.
That means that GHC can be very much more liberal about type synonyms than Haskell 98.

</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>You can write a <code class="literal">forall</code> (including overloading)
in a type synonym, thus:
</p><pre class="programlisting">
  type Discard a = forall b. Show b =&gt; a -&gt; b -&gt; (a, String)

  f :: Discard a
  f x y = (x, show y)

  g :: Discard Int -&gt; (Int,String)    -- A rank-2 type
  g f = f 3 True
</pre><p>
</p></li><li class="listitem"><p>
If you also use <code class="option">-XUnboxedTuples</code>,
you can write an unboxed tuple in a type synonym:
</p><pre class="programlisting">
  type Pr = (# Int, Int #)

  h :: Int -&gt; Pr
  h x = (# x, x #)
</pre><p>
</p></li><li class="listitem"><p>
You can apply a type synonym to a forall type:
</p><pre class="programlisting">
  type Foo a = a -&gt; a -&gt; Bool

  f :: Foo (forall b. b-&gt;b)
</pre><p>
After expanding the synonym, <code class="literal">f</code> has the legal (in GHC) type:
</p><pre class="programlisting">
  f :: (forall b. b-&gt;b) -&gt; (forall b. b-&gt;b) -&gt; Bool
</pre><p>
</p></li><li class="listitem"><p>
You can apply a type synonym to a partially applied type synonym:
</p><pre class="programlisting">
  type Generic i o = forall x. i x -&gt; o x
  type Id x = x

  foo :: Generic Id []
</pre><p>
After expanding the synonym, <code class="literal">foo</code> has the legal (in GHC) type:
</p><pre class="programlisting">
  foo :: forall x. x -&gt; [x]
</pre><p>
</p></li></ul></div><p>
</p><p>
GHC currently does kind checking before expanding synonyms (though even that
could be changed.)
</p><p>
After expanding type synonyms, GHC does validity checking on types, looking for
the following mal-formedness which isn't detected simply by kind checking:
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
Type constructor applied to a type involving for-alls.
</p></li><li class="listitem"><p>
Unboxed tuple on left of an arrow.
</p></li><li class="listitem"><p>
Partially-applied type synonym.
</p></li></ul></div><p>
So, for example,
this will be rejected:
</p><pre class="programlisting">
  type Pr = (# Int, Int #)

  h :: Pr -&gt; Int
  h x = ...
</pre><p>
because GHC does not allow  unboxed tuples on the left of a function arrow.
</p></div><div class="sect2" title="7.4.5. Existentially quantified data constructors"><div class="titlepage"><div><div><h3 class="title"><a name="existential-quantification"></a>7.4.5. Existentially quantified data constructors
</h3></div></div></div><p>
The idea of using existential quantification in data type declarations
was suggested by Perry, and implemented in Hope+ (Nigel Perry, <span class="emphasis"><em>The Implementation
of Practical Functional Programming Languages</em></span>, PhD Thesis, University of
London, 1991). It was later formalised by Laufer and Odersky
(<span class="emphasis"><em>Polymorphic type inference and abstract data types</em></span>,
TOPLAS, 16(5), pp1411-1430, 1994).
It's been in Lennart
Augustsson's <span class="command"><strong>hbc</strong></span> Haskell compiler for several years, and
proved very useful.  Here's the idea.  Consider the declaration:
</p><p>

</p><pre class="programlisting">
  data Foo = forall a. MkFoo a (a -&gt; Bool)
           | Nil
</pre><p>

</p><p>
The data type <code class="literal">Foo</code> has two constructors with types:
</p><p>

</p><pre class="programlisting">
  MkFoo :: forall a. a -&gt; (a -&gt; Bool) -&gt; Foo
  Nil   :: Foo
</pre><p>

</p><p>
Notice that the type variable <code class="literal">a</code> in the type of <code class="function">MkFoo</code>
does not appear in the data type itself, which is plain <code class="literal">Foo</code>.
For example, the following expression is fine:
</p><p>

</p><pre class="programlisting">
  [MkFoo 3 even, MkFoo 'c' isUpper] :: [Foo]
</pre><p>

</p><p>
Here, <code class="literal">(MkFoo 3 even)</code> packages an integer with a function
<code class="function">even</code> that maps an integer to <code class="literal">Bool</code>; and <code class="function">MkFoo 'c'
isUpper</code> packages a character with a compatible function.  These
two things are each of type <code class="literal">Foo</code> and can be put in a list.
</p><p>
What can we do with a value of type <code class="literal">Foo</code>?.  In particular,
what happens when we pattern-match on <code class="function">MkFoo</code>?
</p><p>

</p><pre class="programlisting">
  f (MkFoo val fn) = ???
</pre><p>

</p><p>
Since all we know about <code class="literal">val</code> and <code class="function">fn</code> is that they
are compatible, the only (useful) thing we can do with them is to
apply <code class="function">fn</code> to <code class="literal">val</code> to get a boolean.  For example:
</p><p>

</p><pre class="programlisting">
  f :: Foo -&gt; Bool
  f (MkFoo val fn) = fn val
</pre><p>

</p><p>
What this allows us to do is to package heterogeneous values
together with a bunch of functions that manipulate them, and then treat
that collection of packages in a uniform manner.  You can express
quite a bit of object-oriented-like programming this way.
</p><div class="sect3" title="7.4.5.1. Why existential?"><div class="titlepage"><div><div><h4 class="title"><a name="existential"></a>7.4.5.1. Why existential?
</h4></div></div></div><p>
What has this to do with <span class="emphasis"><em>existential</em></span> quantification?
Simply that <code class="function">MkFoo</code> has the (nearly) isomorphic type
</p><p>

</p><pre class="programlisting">
  MkFoo :: (exists a . (a, a -&gt; Bool)) -&gt; Foo
</pre><p>

</p><p>
But Haskell programmers can safely think of the ordinary
<span class="emphasis"><em>universally</em></span> quantified type given above, thereby avoiding
adding a new existential quantification construct.
</p></div><div class="sect3" title="7.4.5.2. Existentials and type classes"><div class="titlepage"><div><div><h4 class="title"><a name="existential-with-context"></a>7.4.5.2. Existentials and type classes</h4></div></div></div><p>
An easy extension is to allow
arbitrary contexts before the constructor.  For example:
</p><p>

</p><pre class="programlisting">
data Baz = forall a. Eq a =&gt; Baz1 a a
         | forall b. Show b =&gt; Baz2 b (b -&gt; b)
</pre><p>

</p><p>
The two constructors have the types you'd expect:
</p><p>

</p><pre class="programlisting">
Baz1 :: forall a. Eq a =&gt; a -&gt; a -&gt; Baz
Baz2 :: forall b. Show b =&gt; b -&gt; (b -&gt; b) -&gt; Baz
</pre><p>

</p><p>
But when pattern matching on <code class="function">Baz1</code> the matched values can be compared
for equality, and when pattern matching on <code class="function">Baz2</code> the first matched
value can be converted to a string (as well as applying the function to it).
So this program is legal:
</p><p>

</p><pre class="programlisting">
  f :: Baz -&gt; String
  f (Baz1 p q) | p == q    = "Yes"
               | otherwise = "No"
  f (Baz2 v fn)            = show (fn v)
</pre><p>

</p><p>
Operationally, in a dictionary-passing implementation, the
constructors <code class="function">Baz1</code> and <code class="function">Baz2</code> must store the
dictionaries for <code class="literal">Eq</code> and <code class="literal">Show</code> respectively, and
extract it on pattern matching.
</p></div><div class="sect3" title="7.4.5.3. Record Constructors"><div class="titlepage"><div><div><h4 class="title"><a name="existential-records"></a>7.4.5.3. Record Constructors</h4></div></div></div><p>
GHC allows existentials to be used with records syntax as well.  For example:

</p><pre class="programlisting">
data Counter a = forall self. NewCounter
    { _this    :: self
    , _inc     :: self -&gt; self
    , _display :: self -&gt; IO ()
    , tag      :: a
    }
</pre><p>
Here <code class="literal">tag</code> is a public field, with a well-typed selector
function <code class="literal">tag :: Counter a -&gt; a</code>.  The <code class="literal">self</code>
type is hidden from the outside; any attempt to apply <code class="literal">_this</code>,
<code class="literal">_inc</code> or <code class="literal">_display</code> as functions will raise a
compile-time error.  In other words, <span class="emphasis"><em>GHC defines a record selector function
only for fields whose type does not mention the existentially-quantified variables</em></span>.
(This example used an underscore in the fields for which record selectors
will not be defined, but that is only programming style; GHC ignores them.)
</p><p>
To make use of these hidden fields, we need to create some helper functions:

</p><pre class="programlisting">
inc :: Counter a -&gt; Counter a
inc (NewCounter x i d t) = NewCounter
    { _this = i x, _inc = i, _display = d, tag = t }

display :: Counter a -&gt; IO ()
display NewCounter{ _this = x, _display = d } = d x
</pre><p>

Now we can define counters with different underlying implementations:

</p><pre class="programlisting">
counterA :: Counter String
counterA = NewCounter
    { _this = 0, _inc = (1+), _display = print, tag = "A" }

counterB :: Counter String
counterB = NewCounter
    { _this = "", _inc = ('#':), _display = putStrLn, tag = "B" }

main = do
    display (inc counterA)         -- prints "1"
    display (inc (inc counterB))   -- prints "##"
</pre><p>

Record update syntax is supported for existentials (and GADTs):
</p><pre class="programlisting">
setTag :: Counter a -&gt; a -&gt; Counter a
setTag obj t = obj{ tag = t }
</pre><p>
The rule for record update is this: <span class="emphasis"><em>
the types of the updated fields may
mention only the universally-quantified type variables
of the data constructor.  For GADTs, the field may mention only types
that appear as a simple type-variable argument in the constructor's result
type</em></span>.  For example:
</p><pre class="programlisting">
data T a b where { T1 { f1::a, f2::b, f3::(b,c) } :: T a b } -- c is existential
upd1 t x = t { f1=x }   -- OK:   upd1 :: T a b -&gt; a' -&gt; T a' b
upd2 t x = t { f3=x }   -- BAD   (f3's type mentions c, which is
                        --        existentially quantified)

data G a b where { G1 { g1::a, g2::c } :: G a [c] }
upd3 g x = g { g1=x }   -- OK:   upd3 :: G a b -&gt; c -&gt; G c b
upd4 g x = g { g2=x }   -- BAD (f2's type mentions c, which is not a simple
                        --      type-variable argument in G1's result type)
</pre><p>
</p></div><div class="sect3" title="7.4.5.4. Restrictions"><div class="titlepage"><div><div><h4 class="title"><a name="idp28764488"></a>7.4.5.4. Restrictions</h4></div></div></div><p>
There are several restrictions on the ways in which existentially-quantified
constructors can be use.
</p><p>

</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
 When pattern matching, each pattern match introduces a new,
distinct, type for each existential type variable.  These types cannot
be unified with any other type, nor can they escape from the scope of
the pattern match.  For example, these fragments are incorrect:


</p><pre class="programlisting">
f1 (MkFoo a f) = a
</pre><p>


Here, the type bound by <code class="function">MkFoo</code> "escapes", because <code class="literal">a</code>
is the result of <code class="function">f1</code>.  One way to see why this is wrong is to
ask what type <code class="function">f1</code> has:


</p><pre class="programlisting">
  f1 :: Foo -&gt; a             -- Weird!
</pre><p>


What is this "<code class="literal">a</code>" in the result type? Clearly we don't mean
this:


</p><pre class="programlisting">
  f1 :: forall a. Foo -&gt; a   -- Wrong!
</pre><p>


The original program is just plain wrong.  Here's another sort of error


</p><pre class="programlisting">
  f2 (Baz1 a b) (Baz1 p q) = a==q
</pre><p>


It's ok to say <code class="literal">a==b</code> or <code class="literal">p==q</code>, but
<code class="literal">a==q</code> is wrong because it equates the two distinct types arising
from the two <code class="function">Baz1</code> constructors.


</p></li><li class="listitem"><p>
You can't pattern-match on an existentially quantified
constructor in a <code class="literal">let</code> or <code class="literal">where</code> group of
bindings. So this is illegal:


</p><pre class="programlisting">
  f3 x = a==b where { Baz1 a b = x }
</pre><p>

Instead, use a <code class="literal">case</code> expression:

</p><pre class="programlisting">
  f3 x = case x of Baz1 a b -&gt; a==b
</pre><p>

In general, you can only pattern-match
on an existentially-quantified constructor in a <code class="literal">case</code> expression or
in the patterns of a function definition.

The reason for this restriction is really an implementation one.
Type-checking binding groups is already a nightmare without
existentials complicating the picture.  Also an existential pattern
binding at the top level of a module doesn't make sense, because it's
not clear how to prevent the existentially-quantified type "escaping".
So for now, there's a simple-to-state restriction.  We'll see how
annoying it is.

</p></li><li class="listitem"><p>
You can't use existential quantification for <code class="literal">newtype</code>
declarations.  So this is illegal:


</p><pre class="programlisting">
  newtype T = forall a. Ord a =&gt; MkT a
</pre><p>


Reason: a value of type <code class="literal">T</code> must be represented as a
pair of a dictionary for <code class="literal">Ord t</code> and a value of type
<code class="literal">t</code>.  That contradicts the idea that
<code class="literal">newtype</code> should have no concrete representation.
You can get just the same efficiency and effect by using
<code class="literal">data</code> instead of <code class="literal">newtype</code>.  If
there is no overloading involved, then there is more of a case for
allowing an existentially-quantified <code class="literal">newtype</code>,
because the <code class="literal">data</code> version does carry an
implementation cost, but single-field existentially quantified
constructors aren't much use.  So the simple restriction (no
existential stuff on <code class="literal">newtype</code>) stands, unless there
are convincing reasons to change it.


</p></li><li class="listitem"><p>
 You can't use <code class="literal">deriving</code> to define instances of a
data type with existentially quantified data constructors.

Reason: in most cases it would not make sense. For example:;

</p><pre class="programlisting">
data T = forall a. MkT [a] deriving( Eq )
</pre><p>

To derive <code class="literal">Eq</code> in the standard way we would need to have equality
between the single component of two <code class="function">MkT</code> constructors:

</p><pre class="programlisting">
instance Eq T where
  (MkT a) == (MkT b) = ???
</pre><p>

But <code class="varname">a</code> and <code class="varname">b</code> have distinct types, and so can't be compared.
It's just about possible to imagine examples in which the derived instance
would make sense, but it seems altogether simpler simply to prohibit such
declarations.  Define your own instances!
</p></li></ul></div><p>

</p></div></div><div class="sect2" title="7.4.6. Declaring data types with explicit constructor signatures"><div class="titlepage"><div><div><h3 class="title"><a name="gadt-style"></a>7.4.6. Declaring data types with explicit constructor signatures</h3></div></div></div><p>When the <code class="literal">GADTSyntax</code> extension is enabled,
GHC allows you to declare an algebraic data type by
giving the type signatures of constructors explicitly.  For example:
</p><pre class="programlisting">
  data Maybe a where
      Nothing :: Maybe a
      Just    :: a -&gt; Maybe a
</pre><p>
The form is called a "GADT-style declaration"
because Generalised Algebraic Data Types, described in <a class="xref" href="data-type-extensions.html#gadt" title="7.4.7. Generalised Algebraic Data Types (GADTs)">Section 7.4.7, &#8220;Generalised Algebraic Data Types (GADTs)&#8221;</a>,
can only be declared using this form.</p><p>Notice that GADT-style syntax generalises existential types (<a class="xref" href="data-type-extensions.html#existential-quantification" title="7.4.5. Existentially quantified data constructors">Section 7.4.5, &#8220;Existentially quantified data constructors
&#8221;</a>).
For example, these two declarations are equivalent:
</p><pre class="programlisting">
  data Foo = forall a. MkFoo a (a -&gt; Bool)
  data Foo' where { MKFoo :: a -&gt; (a-&gt;Bool) -&gt; Foo' }
</pre><p>
</p><p>Any data type that can be declared in standard Haskell-98 syntax
can also be declared using GADT-style syntax.
The choice is largely stylistic, but GADT-style declarations differ in one important respect:
they treat class constraints on the data constructors differently.
Specifically, if the constructor is given a type-class context, that
context is made available by pattern matching.  For example:
</p><pre class="programlisting">
  data Set a where
    MkSet :: Eq a =&gt; [a] -&gt; Set a

  makeSet :: Eq a =&gt; [a] -&gt; Set a
  makeSet xs = MkSet (nub xs)

  insert :: a -&gt; Set a -&gt; Set a
  insert a (MkSet as) | a `elem` as = MkSet as
                      | otherwise   = MkSet (a:as)
</pre><p>
A use of <code class="literal">MkSet</code> as a constructor (e.g. in the definition of <code class="literal">makeSet</code>)
gives rise to a <code class="literal">(Eq a)</code>
constraint, as you would expect.  The new feature is that pattern-matching on <code class="literal">MkSet</code>
(as in the definition of <code class="literal">insert</code>) makes <span class="emphasis"><em>available</em></span> an <code class="literal">(Eq a)</code>
context.  In implementation terms, the <code class="literal">MkSet</code> constructor has a hidden field that stores
the <code class="literal">(Eq a)</code> dictionary that is passed to <code class="literal">MkSet</code>; so
when pattern-matching that dictionary becomes available for the right-hand side of the match.
In the example, the equality dictionary is used to satisfy the equality constraint
generated by the call to <code class="literal">elem</code>, so that the type of
<code class="literal">insert</code> itself has no <code class="literal">Eq</code> constraint.
</p><p>
For example, one possible application is to reify dictionaries:
</p><pre class="programlisting">
   data NumInst a where
     MkNumInst :: Num a =&gt; NumInst a

   intInst :: NumInst Int
   intInst = MkNumInst

   plus :: NumInst a -&gt; a -&gt; a -&gt; a
   plus MkNumInst p q = p + q
</pre><p>
Here, a value of type <code class="literal">NumInst a</code> is equivalent
to an explicit <code class="literal">(Num a)</code> dictionary.
</p><p>
All this applies to constructors declared using the syntax of <a class="xref" href="data-type-extensions.html#existential-with-context" title="7.4.5.2. Existentials and type classes">Section 7.4.5.2, &#8220;Existentials and type classes&#8221;</a>.
For example, the <code class="literal">NumInst</code> data type above could equivalently be declared
like this:
</p><pre class="programlisting">
   data NumInst a
      = Num a =&gt; MkNumInst (NumInst a)
</pre><p>
Notice that, unlike the situation when declaring an existential, there is
no <code class="literal">forall</code>, because the <code class="literal">Num</code> constrains the
data type's universally quantified type variable <code class="literal">a</code>.
A constructor may have both universal and existential type variables: for example,
the following two declarations are equivalent:
</p><pre class="programlisting">
   data T1 a
	= forall b. (Num a, Eq b) =&gt; MkT1 a b
   data T2 a where
	MkT2 :: (Num a, Eq b) =&gt; a -&gt; b -&gt; T2 a
</pre><p>
</p><p>All this behaviour contrasts with Haskell 98's peculiar treatment of
contexts on a data type declaration (Section 4.2.1 of the Haskell 98 Report).
In Haskell 98 the definition
</p><pre class="programlisting">
  data Eq a =&gt; Set' a = MkSet' [a]
</pre><p>
gives <code class="literal">MkSet'</code> the same type as <code class="literal">MkSet</code> above.  But instead of
<span class="emphasis"><em>making available</em></span> an <code class="literal">(Eq a)</code> constraint, pattern-matching
on <code class="literal">MkSet'</code> <span class="emphasis"><em>requires</em></span> an <code class="literal">(Eq a)</code> constraint!
GHC faithfully implements this behaviour, odd though it is.  But for GADT-style declarations,
GHC's behaviour is much more useful, as well as much more intuitive.
</p><p>
The rest of this section gives further details about GADT-style data
type declarations.

</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
The result type of each data constructor must begin with the type constructor being defined.
If the result type of all constructors
has the form <code class="literal">T a1 ... an</code>, where <code class="literal">a1 ... an</code>
are distinct type variables, then the data type is <span class="emphasis"><em>ordinary</em></span>;
otherwise is a <span class="emphasis"><em>generalised</em></span> data type (<a class="xref" href="data-type-extensions.html#gadt" title="7.4.7. Generalised Algebraic Data Types (GADTs)">Section 7.4.7, &#8220;Generalised Algebraic Data Types (GADTs)&#8221;</a>).
</p></li><li class="listitem"><p>
As with other type signatures, you can give a single signature for several data constructors.
In this example we give a single signature for <code class="literal">T1</code> and <code class="literal">T2</code>:
</p><pre class="programlisting">
  data T a where
    T1,T2 :: a -&gt; T a
    T3 :: T a
</pre><p>
</p></li><li class="listitem"><p>
The type signature of
each constructor is independent, and is implicitly universally quantified as usual.
In particular, the type variable(s) in the "<code class="literal">data T a where</code>" header
have no scope, and different constructors may have different universally-quantified type variables:
</p><pre class="programlisting">
  data T a where        -- The 'a' has no scope
    T1,T2 :: b -&gt; T b   -- Means forall b. b -&gt; T b
    T3 :: T a           -- Means forall a. T a
</pre><p>
</p></li><li class="listitem"><p>
A constructor signature may mention type class constraints, which can differ for
different constructors.  For example, this is fine:
</p><pre class="programlisting">
  data T a where
    T1 :: Eq b =&gt; b -&gt; b -&gt; T b
    T2 :: (Show c, Ix c) =&gt; c -&gt; [c] -&gt; T c
</pre><p>
When pattern matching, these constraints are made available to discharge constraints
in the body of the match. For example:
</p><pre class="programlisting">
  f :: T a -&gt; String
  f (T1 x y) | x==y      = "yes"
             | otherwise = "no"
  f (T2 a b)             = show a
</pre><p>
Note that <code class="literal">f</code> is not overloaded; the <code class="literal">Eq</code> constraint arising
from the use of <code class="literal">==</code> is discharged by the pattern match on <code class="literal">T1</code>
and similarly the <code class="literal">Show</code> constraint arising from the use of <code class="literal">show</code>.
</p></li><li class="listitem"><p>
Unlike a Haskell-98-style
data type declaration, the type variable(s) in the "<code class="literal">data Set a where</code>" header
have no scope.  Indeed, one can write a kind signature instead:
</p><pre class="programlisting">
  data Set :: * -&gt; * where ...
</pre><p>
or even a mixture of the two:
</p><pre class="programlisting">
  data Bar a :: (* -&gt; *) -&gt; * where ...
</pre><p>
The type variables (if given) may be explicitly kinded, so we could also write the header for <code class="literal">Foo</code>
like this:
</p><pre class="programlisting">
  data Bar a (b :: * -&gt; *) where ...
</pre><p>
</p></li><li class="listitem"><p>
You can use strictness annotations, in the obvious places
in the constructor type:
</p><pre class="programlisting">
  data Term a where
      Lit    :: !Int -&gt; Term Int
      If     :: Term Bool -&gt; !(Term a) -&gt; !(Term a) -&gt; Term a
      Pair   :: Term a -&gt; Term b -&gt; Term (a,b)
</pre><p>
</p></li><li class="listitem"><p>
You can use a <code class="literal">deriving</code> clause on a GADT-style data type
declaration.   For example, these two declarations are equivalent
</p><pre class="programlisting">
  data Maybe1 a where {
      Nothing1 :: Maybe1 a ;
      Just1    :: a -&gt; Maybe1 a
    } deriving( Eq, Ord )

  data Maybe2 a = Nothing2 | Just2 a
       deriving( Eq, Ord )
</pre><p>
</p></li><li class="listitem"><p>
The type signature may have quantified type variables that do not appear
in the result type:
</p><pre class="programlisting">
  data Foo where
     MkFoo :: a -&gt; (a-&gt;Bool) -&gt; Foo
     Nil   :: Foo
</pre><p>
Here the type variable <code class="literal">a</code> does not appear in the result type
of either constructor.
Although it is universally quantified in the type of the constructor, such
a type variable is often called "existential".
Indeed, the above declaration declares precisely the same type as
the <code class="literal">data Foo</code> in <a class="xref" href="data-type-extensions.html#existential-quantification" title="7.4.5. Existentially quantified data constructors">Section 7.4.5, &#8220;Existentially quantified data constructors
&#8221;</a>.
</p><p>
The type may contain a class context too, of course:
</p><pre class="programlisting">
  data Showable where
    MkShowable :: Show a =&gt; a -&gt; Showable
</pre><p>
</p></li><li class="listitem"><p>
You can use record syntax on a GADT-style data type declaration:

</p><pre class="programlisting">
  data Person where
      Adult :: { name :: String, children :: [Person] } -&gt; Person
      Child :: Show a =&gt; { name :: !String, funny :: a } -&gt; Person
</pre><p>
As usual, for every constructor that has a field <code class="literal">f</code>, the type of
field <code class="literal">f</code> must be the same (modulo alpha conversion).
The <code class="literal">Child</code> constructor above shows that the signature
may have a context, existentially-quantified variables, and strictness annotations,
just as in the non-record case.  (NB: the "type" that follows the double-colon
is not really a type, because of the record syntax and strictness annotations.
A "type" of this form can appear only in a constructor signature.)
</p></li><li class="listitem"><p>
Record updates are allowed with GADT-style declarations,
only fields that have the following property: the type of the field
mentions no existential type variables.
</p></li><li class="listitem"><p>
As in the case of existentials declared using the Haskell-98-like record syntax
(<a class="xref" href="data-type-extensions.html#existential-records" title="7.4.5.3. Record Constructors">Section 7.4.5.3, &#8220;Record Constructors&#8221;</a>),
record-selector functions are generated only for those fields that have well-typed
selectors.
Here is the example of that section, in GADT-style syntax:
</p><pre class="programlisting">
data Counter a where
    NewCounter { _this    :: self
               , _inc     :: self -&gt; self
               , _display :: self -&gt; IO ()
               , tag      :: a
               }
        :: Counter a
</pre><p>
As before, only one selector function is generated here, that for <code class="literal">tag</code>.
Nevertheless, you can still use all the field names in pattern matching and record construction.
</p></li></ul></div></div><div class="sect2" title="7.4.7. Generalised Algebraic Data Types (GADTs)"><div class="titlepage"><div><div><h3 class="title"><a name="gadt"></a>7.4.7. Generalised Algebraic Data Types (GADTs)</h3></div></div></div><p>Generalised Algebraic Data Types generalise ordinary algebraic data types
by allowing constructors to have richer return types.  Here is an example:
</p><pre class="programlisting">
  data Term a where
      Lit    :: Int -&gt; Term Int
      Succ   :: Term Int -&gt; Term Int
      IsZero :: Term Int -&gt; Term Bool
      If     :: Term Bool -&gt; Term a -&gt; Term a -&gt; Term a
      Pair   :: Term a -&gt; Term b -&gt; Term (a,b)
</pre><p>
Notice that the return type of the constructors is not always <code class="literal">Term a</code>, as is the
case with ordinary data types.  This generality allows us to
write a well-typed <code class="literal">eval</code> function
for these <code class="literal">Terms</code>:
</p><pre class="programlisting">
  eval :: Term a -&gt; a
  eval (Lit i) 	    = i
  eval (Succ t)     = 1 + eval t
  eval (IsZero t)   = eval t == 0
  eval (If b e1 e2) = if eval b then eval e1 else eval e2
  eval (Pair e1 e2) = (eval e1, eval e2)
</pre><p>
The key point about GADTs is that <span class="emphasis"><em>pattern matching causes type refinement</em></span>.
For example, in the right hand side of the equation
</p><pre class="programlisting">
  eval :: Term a -&gt; a
  eval (Lit i) =  ...
</pre><p>
the type <code class="literal">a</code> is refined to <code class="literal">Int</code>.  That's the whole point!
A precise specification of the type rules is beyond what this user manual aspires to,
but the design closely follows that described in
the paper <a class="ulink" href="http://research.microsoft.com/%7Esimonpj/papers/gadt/" target="_top">Simple
unification-based type inference for GADTs</a>,
(ICFP 2006).
The general principle is this: <span class="emphasis"><em>type refinement is only carried out
based on user-supplied type annotations</em></span>.
So if no type signature is supplied for <code class="literal">eval</code>, no type refinement happens,
and lots of obscure error messages will
occur.  However, the refinement is quite general.  For example, if we had:
</p><pre class="programlisting">
  eval :: Term a -&gt; a -&gt; a
  eval (Lit i) j =  i+j
</pre><p>
the pattern match causes the type <code class="literal">a</code> to be refined to <code class="literal">Int</code> (because of the type
of the constructor <code class="literal">Lit</code>), and that refinement also applies to the type of <code class="literal">j</code>, and
the result type of the <code class="literal">case</code> expression.  Hence the addition <code class="literal">i+j</code> is legal.
</p><p>
These and many other examples are given in papers by Hongwei Xi, and
Tim Sheard. There is a longer introduction
<a class="ulink" href="http://www.haskell.org/haskellwiki/GADT" target="_top">on the wiki</a>,
and Ralf Hinze's
<a class="ulink" href="http://www.informatik.uni-bonn.de/~ralf/publications/With.pdf" target="_top">Fun with phantom types</a> also has a number of examples. Note that papers
may use different notation to that implemented in GHC.
</p><p>
The rest of this section outlines the extensions to GHC that support GADTs.   The extension is enabled with
<code class="option">-XGADTs</code>.  The <code class="option">-XGADTs</code> flag also sets <code class="option">-XRelaxedPolyRec</code>.
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
A GADT can only be declared using GADT-style syntax (<a class="xref" href="data-type-extensions.html#gadt-style" title="7.4.6. Declaring data types with explicit constructor signatures">Section 7.4.6, &#8220;Declaring data types with explicit constructor signatures&#8221;</a>);
the old Haskell-98 syntax for data declarations always declares an ordinary data type.
The result type of each constructor must begin with the type constructor being defined,
but for a GADT the arguments to the type constructor can be arbitrary monotypes.
For example, in the <code class="literal">Term</code> data
type above, the type of each constructor must end with <code class="literal">Term ty</code>, but
the <code class="literal">ty</code> need not be a type variable (e.g. the <code class="literal">Lit</code>
constructor).
</p></li><li class="listitem"><p>
It is permitted to declare an ordinary algebraic data type using GADT-style syntax.
What makes a GADT into a GADT is not the syntax, but rather the presence of data constructors
whose result type is not just <code class="literal">T a b</code>.
</p></li><li class="listitem"><p>
You cannot use a <code class="literal">deriving</code> clause for a GADT; only for
an ordinary data type.
</p></li><li class="listitem"><p>
As mentioned in <a class="xref" href="data-type-extensions.html#gadt-style" title="7.4.6. Declaring data types with explicit constructor signatures">Section 7.4.6, &#8220;Declaring data types with explicit constructor signatures&#8221;</a>, record syntax is supported.
For example:
</p><pre class="programlisting">
  data Term a where
      Lit    { val  :: Int }      :: Term Int
      Succ   { num  :: Term Int } :: Term Int
      Pred   { num  :: Term Int } :: Term Int
      IsZero { arg  :: Term Int } :: Term Bool
      Pair   { arg1 :: Term a
             , arg2 :: Term b
             }                    :: Term (a,b)
      If     { cnd  :: Term Bool
             , tru  :: Term a
             , fls  :: Term a
             }                    :: Term a
</pre><p>
However, for GADTs there is the following additional constraint:
every constructor that has a field <code class="literal">f</code> must have
the same result type (modulo alpha conversion)
Hence, in the above example, we cannot merge the <code class="literal">num</code>
and <code class="literal">arg</code> fields above into a
single name.  Although their field types are both <code class="literal">Term Int</code>,
their selector functions actually have different types:

</p><pre class="programlisting">
  num :: Term Int -&gt; Term Int
  arg :: Term Bool -&gt; Term Int
</pre><p>
</p></li><li class="listitem"><p>
When pattern-matching against data constructors drawn from a GADT,
for example in a <code class="literal">case</code> expression, the following rules apply:
</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>The type of the scrutinee must be rigid.</p></li><li class="listitem"><p>The type of the entire <code class="literal">case</code> expression must be rigid.</p></li><li class="listitem"><p>The type of any free variable mentioned in any of
the <code class="literal">case</code> alternatives must be rigid.</p></li></ul></div><p>
A type is "rigid" if it is completely known to the compiler at its binding site.  The easiest
way to ensure that a variable a rigid type is to give it a type signature.
For more precise details see <a class="ulink" href="http://research.microsoft.com/%7Esimonpj/papers/gadt" target="_top">
Simple unification-based type inference for GADTs
</a>. The criteria implemented by GHC are given in the Appendix.

</p></li></ul></div><p>
</p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="syntax-extns.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ghc-language-features.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="deriving.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">7.3. Syntactic extensions </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 7.5. Extensions to the "deriving" mechanism</td></tr></table></div></body></html>
