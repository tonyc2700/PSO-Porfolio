-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | GHC primitives
--   
--   GHC primitives.
@package ghc-prim


-- | GHC type definitions. Use GHC.Exts from the base package instead of
--   importing this module directly.
module GHC.Types
data Bool
False :: Bool
True :: Bool

-- | The character type <a>Char</a> is an enumeration whose values
--   represent Unicode (or equivalently ISO/IEC 10646) characters (see
--   <a>http://www.unicode.org/</a> for details). This set extends the ISO
--   8859-1 (Latin-1) character set (the first 256 characters), which is
--   itself an extension of the ASCII character set (the first 128
--   characters). A character literal in Haskell has type <a>Char</a>.
--   
--   To convert a <a>Char</a> to or from the corresponding <a>Int</a> value
--   defined by Unicode, use <a>toEnum</a> and <a>fromEnum</a> from the
--   <a>Enum</a> class respectively (or equivalently <tt>ord</tt> and
--   <tt>chr</tt>).
data Char
C# :: Char# -> Char

-- | A fixed-precision integer type with at least the range <tt>[-2^29 ..
--   2^29-1]</tt>. The exact range for a given implementation can be
--   determined by using <a>minBound</a> and <a>maxBound</a> from the
--   <a>Bounded</a> class.
data Int
I# :: Int# -> Int

-- | Single-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   single-precision type.
data Float
F# :: Float# -> Float

-- | Double-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   double-precision type.
data Double
D# :: Double# -> Double
data Ordering
LT :: Ordering
EQ :: Ordering
GT :: Ordering

-- | A value of type <tt><a>IO</a> a</tt> is a computation which, when
--   performed, does some I/O before returning a value of type <tt>a</tt>.
--   
--   There is really only one way to "perform" an I/O action: bind it to
--   <tt>Main.main</tt> in your program. When your program is run, the I/O
--   will be performed. It isn't possible to perform I/O from an arbitrary
--   function, unless that function is itself in the <a>IO</a> monad and
--   called at some point, directly or indirectly, from <tt>Main.main</tt>.
--   
--   <a>IO</a> is a monad, so <a>IO</a> actions can be combined using
--   either the do-notation or the <tt>&gt;&gt;</tt> and <tt>&gt;&gt;=</tt>
--   operations from the <tt>Monad</tt> class.
newtype IO a
IO :: (State# RealWorld -> (# State# RealWorld, a #)) -> IO a


-- | GHC C strings definitions (previously in GHC.Base). Use GHC.Exts from
--   the base package instead of importing this module directly.
module GHC.CString
unpackCString# :: Addr# -> [Char]
unpackAppendCString# :: Addr# -> [Char] -> [Char]
unpackFoldrCString# :: Addr# -> (Char -> a -> a) -> a -> a
unpackCStringUtf8# :: Addr# -> [Char]
unpackNBytes# :: Addr# -> Int# -> [Char]

module GHC.Generics

-- | Void: used for datatypes without constructors
data V1 p

-- | Unit: used for constructors without arguments
data U1 p
U1 :: U1 p

-- | Used for marking occurrences of the parameter
newtype Par1 p
Par1 :: p -> Par1 p
unPar1 :: Par1 p -> p

-- | Recursive calls of kind * -&gt; *
newtype Rec1 f p
Rec1 :: f p -> Rec1 f p
unRec1 :: Rec1 f p -> f p

-- | Constants, additional parameters and recursion of kind *
newtype K1 i c p
K1 :: c -> K1 i c p
unK1 :: K1 i c p -> c

-- | Meta-information (constructor names, etc.)
newtype M1 i c f p
M1 :: f p -> M1 i c f p
unM1 :: M1 i c f p -> f p

-- | Sums: encode choice between constructors
data (:+:) f g p
L1 :: (f p) -> :+: f g p
R1 :: (g p) -> :+: f g p

-- | Products: encode multiple arguments to constructors
data (:*:) f g p
(:*:) :: f p -> g p -> :*: f g p

-- | Composition of functors
newtype (:.:) f g p
Comp1 :: f (g p) -> :.: f g p
unComp1 :: :.: f g p -> f (g p)

-- | Type synonym for encoding recursion (of kind *)
type Rec0 = K1 R

-- | Type synonym for encoding parameters (other than the last)
type Par0 = K1 P

-- | Tag for K1: recursion (of kind *)
data R

-- | Tag for K1: parameters (other than the last)
data P

-- | Type synonym for encoding meta-information for datatypes
type D1 = M1 D

-- | Type synonym for encoding meta-information for constructors
type C1 = M1 C

-- | Type synonym for encoding meta-information for record selectors
type S1 = M1 S

-- | Tag for M1: datatype
data D

-- | Tag for M1: constructor
data C

-- | Tag for M1: record selector
data S

-- | Class for datatypes that represent datatypes
class Datatype d
datatypeName :: Datatype d => t d (f :: * -> *) a -> [Char]
moduleName :: Datatype d => t d (f :: * -> *) a -> [Char]

-- | Class for datatypes that represent data constructors
class Constructor c where conFixity _ = Prefix conIsRecord _ = False
conName :: Constructor c => t c (f :: * -> *) a -> [Char]
conFixity :: Constructor c => t c (f :: * -> *) a -> Fixity
conIsRecord :: Constructor c => t c (f :: * -> *) a -> Bool

-- | Class for datatypes that represent records
class Selector s
selName :: Selector s => t s (f :: * -> *) a -> [Char]

-- | Used for constructor fields without a name
data NoSelector

-- | Datatype to represent the fixity of a constructor. An infix |
--   declaration directly corresponds to an application of <a>Infix</a>.
data Fixity
Prefix :: Fixity
Infix :: Associativity -> Int -> Fixity

-- | Datatype to represent the associativity of a constructor
data Associativity
LeftAssociative :: Associativity
RightAssociative :: Associativity
NotAssociative :: Associativity

-- | Datatype to represent the arity of a tuple.
data Arity
NoArity :: Arity
Arity :: Int -> Arity

-- | Get the precedence of a fixity value.
prec :: Fixity -> Int

-- | Representable types of kind *. This class is derivable in GHC with the
--   DeriveRepresentable flag on.
class Generic a where type family Rep a :: * -> *
from :: Generic a => a -> (Rep a) x
to :: Generic a => (Rep a) x -> a

-- | Representable types of kind * -&gt; * (not yet derivable)
class Generic1 f where type family Rep1 f :: * -> *
from1 :: Generic1 f => f a -> (Rep1 f) a
to1 :: Generic1 f => (Rep1 f) a -> f a
instance Generic Ordering
instance Generic Bool
instance Generic [a]
instance Datatype D1Ordering
instance Constructor C1_0Ordering
instance Constructor C1_1Ordering
instance Constructor C1_2Ordering
instance Datatype D1Bool
instance Constructor C1_0Bool
instance Constructor C1_1Bool
instance Datatype D1[]
instance Constructor C1_0[]
instance Constructor C1_1[]
instance Generic Char
instance Constructor C_Char
instance Datatype D_Char
instance Generic Double
instance Constructor C_Double
instance Datatype D_Double
instance Generic Float
instance Constructor C_Float
instance Datatype D_Float
instance Generic Int
instance Constructor C_Int
instance Datatype D_Int
instance Selector NoSelector


-- | The tuple data types
module GHC.Tuple

-- | The unit datatype <tt>()</tt> has one non-undefined member, the
--   nullary constructor <tt>()</tt>.
data ()
() :: ()
data (,) a b
(,) :: a -> b -> (,) a b
data (,,) a b c
(,,) :: a -> b -> c -> (,,) a b c
data (,,,) a b c d
(,,,) :: a -> b -> c -> d -> (,,,) a b c d
data (,,,,) a b c d e
(,,,,) :: a -> b -> c -> d -> e -> (,,,,) a b c d e
data (,,,,,) a b c d e f
(,,,,,) :: a -> b -> c -> d -> e -> f -> (,,,,,) a b c d e f
data (,,,,,,) a b c d e f g
(,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> (,,,,,,) a b c d e f g
data (,,,,,,,) a b c d e f g h
(,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> (,,,,,,,) a b c d e f g h
data (,,,,,,,,) a b c d e f g h i
(,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> (,,,,,,,,) a b c d e f g h i
data (,,,,,,,,,) a b c d e f g h i j
(,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> (,,,,,,,,,) a b c d e f g h i j
data (,,,,,,,,,,) a b c d e f g h i j k
(,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> (,,,,,,,,,,) a b c d e f g h i j k
data (,,,,,,,,,,,) a b c d e f g h i j k l
(,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> (,,,,,,,,,,,) a b c d e f g h i j k l
data (,,,,,,,,,,,,) a b c d e f g h i j k l m
(,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> (,,,,,,,,,,,,) a b c d e f g h i j k l m
data (,,,,,,,,,,,,,) a b c d e f g h i j k l m n
(,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> (,,,,,,,,,,,,,) a b c d e f g h i j k l m n
data (,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o
(,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> (,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o
data (,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p
(,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> (,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p
data (,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q
(,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> (,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q
data (,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r
(,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> (,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r
data (,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s
(,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> (,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s
data (,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t
(,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> (,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t
data (,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u
(,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> (,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u
data (,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v
(,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> (,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v
data (,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w
(,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> (,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w
data (,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x
(,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> (,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x
data (,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y
(,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> (,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y
data (,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z
(,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> (,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z
data (,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_
(,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_
(,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> f_ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> f_ -> g_ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> f_ -> g_ -> h_ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> f_ -> g_ -> h_ -> i_ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> f_ -> g_ -> h_ -> i_ -> j_ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> f_ -> g_ -> h_ -> i_ -> j_ -> k_ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> f_ -> g_ -> h_ -> i_ -> j_ -> k_ -> l_ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> f_ -> g_ -> h_ -> i_ -> j_ -> k_ -> l_ -> m_ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> f_ -> g_ -> h_ -> i_ -> j_ -> k_ -> l_ -> m_ -> n_ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> f_ -> g_ -> h_ -> i_ -> j_ -> k_ -> l_ -> m_ -> n_ -> o_ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> f_ -> g_ -> h_ -> i_ -> j_ -> k_ -> l_ -> m_ -> n_ -> o_ -> p_ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> f_ -> g_ -> h_ -> i_ -> j_ -> k_ -> l_ -> m_ -> n_ -> o_ -> p_ -> q_ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> f_ -> g_ -> h_ -> i_ -> j_ -> k_ -> l_ -> m_ -> n_ -> o_ -> p_ -> q_ -> r_ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> f_ -> g_ -> h_ -> i_ -> j_ -> k_ -> l_ -> m_ -> n_ -> o_ -> p_ -> q_ -> r_ -> s_ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> f_ -> g_ -> h_ -> i_ -> j_ -> k_ -> l_ -> m_ -> n_ -> o_ -> p_ -> q_ -> r_ -> s_ -> t_ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> f_ -> g_ -> h_ -> i_ -> j_ -> k_ -> l_ -> m_ -> n_ -> o_ -> p_ -> q_ -> r_ -> s_ -> t_ -> u_ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> f_ -> g_ -> h_ -> i_ -> j_ -> k_ -> l_ -> m_ -> n_ -> o_ -> p_ -> q_ -> r_ -> s_ -> t_ -> u_ -> v_ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> f_ -> g_ -> h_ -> i_ -> j_ -> k_ -> l_ -> m_ -> n_ -> o_ -> p_ -> q_ -> r_ -> s_ -> t_ -> u_ -> v_ -> w_ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> f_ -> g_ -> h_ -> i_ -> j_ -> k_ -> l_ -> m_ -> n_ -> o_ -> p_ -> q_ -> r_ -> s_ -> t_ -> u_ -> v_ -> w_ -> x_ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> f_ -> g_ -> h_ -> i_ -> j_ -> k_ -> l_ -> m_ -> n_ -> o_ -> p_ -> q_ -> r_ -> s_ -> t_ -> u_ -> v_ -> w_ -> x_ -> y_ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_ z_
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> f_ -> g_ -> h_ -> i_ -> j_ -> k_ -> l_ -> m_ -> n_ -> o_ -> p_ -> q_ -> r_ -> s_ -> t_ -> u_ -> v_ -> w_ -> x_ -> y_ -> z_ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_ z_
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_ z_ a__
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> f_ -> g_ -> h_ -> i_ -> j_ -> k_ -> l_ -> m_ -> n_ -> o_ -> p_ -> q_ -> r_ -> s_ -> t_ -> u_ -> v_ -> w_ -> x_ -> y_ -> z_ -> a__ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_ z_ a__
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_ z_ a__ b__
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> f_ -> g_ -> h_ -> i_ -> j_ -> k_ -> l_ -> m_ -> n_ -> o_ -> p_ -> q_ -> r_ -> s_ -> t_ -> u_ -> v_ -> w_ -> x_ -> y_ -> z_ -> a__ -> b__ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_ z_ a__ b__
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_ z_ a__ b__ c__
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> f_ -> g_ -> h_ -> i_ -> j_ -> k_ -> l_ -> m_ -> n_ -> o_ -> p_ -> q_ -> r_ -> s_ -> t_ -> u_ -> v_ -> w_ -> x_ -> y_ -> z_ -> a__ -> b__ -> c__ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_ z_ a__ b__ c__
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_ z_ a__ b__ c__ d__
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> f_ -> g_ -> h_ -> i_ -> j_ -> k_ -> l_ -> m_ -> n_ -> o_ -> p_ -> q_ -> r_ -> s_ -> t_ -> u_ -> v_ -> w_ -> x_ -> y_ -> z_ -> a__ -> b__ -> c__ -> d__ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_ z_ a__ b__ c__ d__
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_ z_ a__ b__ c__ d__ e__
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> f_ -> g_ -> h_ -> i_ -> j_ -> k_ -> l_ -> m_ -> n_ -> o_ -> p_ -> q_ -> r_ -> s_ -> t_ -> u_ -> v_ -> w_ -> x_ -> y_ -> z_ -> a__ -> b__ -> c__ -> d__ -> e__ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_ z_ a__ b__ c__ d__ e__
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_ z_ a__ b__ c__ d__ e__ f__
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> f_ -> g_ -> h_ -> i_ -> j_ -> k_ -> l_ -> m_ -> n_ -> o_ -> p_ -> q_ -> r_ -> s_ -> t_ -> u_ -> v_ -> w_ -> x_ -> y_ -> z_ -> a__ -> b__ -> c__ -> d__ -> e__ -> f__ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_ z_ a__ b__ c__ d__ e__ f__
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_ z_ a__ b__ c__ d__ e__ f__ g__
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> f_ -> g_ -> h_ -> i_ -> j_ -> k_ -> l_ -> m_ -> n_ -> o_ -> p_ -> q_ -> r_ -> s_ -> t_ -> u_ -> v_ -> w_ -> x_ -> y_ -> z_ -> a__ -> b__ -> c__ -> d__ -> e__ -> f__ -> g__ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_ z_ a__ b__ c__ d__ e__ f__ g__
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_ z_ a__ b__ c__ d__ e__ f__ g__ h__
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> f_ -> g_ -> h_ -> i_ -> j_ -> k_ -> l_ -> m_ -> n_ -> o_ -> p_ -> q_ -> r_ -> s_ -> t_ -> u_ -> v_ -> w_ -> x_ -> y_ -> z_ -> a__ -> b__ -> c__ -> d__ -> e__ -> f__ -> g__ -> h__ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_ z_ a__ b__ c__ d__ e__ f__ g__ h__
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_ z_ a__ b__ c__ d__ e__ f__ g__ h__ i__
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> f_ -> g_ -> h_ -> i_ -> j_ -> k_ -> l_ -> m_ -> n_ -> o_ -> p_ -> q_ -> r_ -> s_ -> t_ -> u_ -> v_ -> w_ -> x_ -> y_ -> z_ -> a__ -> b__ -> c__ -> d__ -> e__ -> f__ -> g__ -> h__ -> i__ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_ z_ a__ b__ c__ d__ e__ f__ g__ h__ i__
data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_ z_ a__ b__ c__ d__ e__ f__ g__ h__ i__ j__
(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> a_ -> b_ -> c_ -> d_ -> e_ -> f_ -> g_ -> h_ -> i_ -> j_ -> k_ -> l_ -> m_ -> n_ -> o_ -> p_ -> q_ -> r_ -> s_ -> t_ -> u_ -> v_ -> w_ -> x_ -> y_ -> z_ -> a__ -> b__ -> c__ -> d__ -> e__ -> f__ -> g__ -> h__ -> i__ -> j__ -> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_ z_ a__ b__ c__ d__ e__ f__ g__ h__ i__ j__
instance Generic ((,,,,,,) a b c d e f g)
instance Generic ((,,,,,) a b c d e f)
instance Generic ((,,,,) a b c d e)
instance Generic ((,,,) a b c d)
instance Generic ((,,) a b c)
instance Generic ((,) a b)
instance Generic ()
instance Datatype D1(,,,,,,)
instance Constructor C1_0(,,,,,,)
instance Datatype D1(,,,,,)
instance Constructor C1_0(,,,,,)
instance Datatype D1(,,,,)
instance Constructor C1_0(,,,,)
instance Datatype D1(,,,)
instance Constructor C1_0(,,,)
instance Datatype D1(,,)
instance Constructor C1_0(,,)
instance Datatype D1(,)
instance Constructor C1_0(,)
instance Datatype D1()
instance Constructor C1_0()

module GHC.Debug
debugLn :: [Char] -> IO ()
debugErrLn :: [Char] -> IO ()

module GHC.PrimopWrappers
gtChar# :: Char# -> Char# -> Bool
geChar# :: Char# -> Char# -> Bool
eqChar# :: Char# -> Char# -> Bool
neChar# :: Char# -> Char# -> Bool
ltChar# :: Char# -> Char# -> Bool
leChar# :: Char# -> Char# -> Bool
ord# :: Char# -> Int#
(+#) :: Int# -> Int# -> Int#
(-#) :: Int# -> Int# -> Int#
(*#) :: Int# -> Int# -> Int#
mulIntMayOflo# :: Int# -> Int# -> Int#
quotInt# :: Int# -> Int# -> Int#
remInt# :: Int# -> Int# -> Int#
negateInt# :: Int# -> Int#
addIntC# :: Int# -> Int# -> (# Int#, Int# #)
subIntC# :: Int# -> Int# -> (# Int#, Int# #)
(>#) :: Int# -> Int# -> Bool
(>=#) :: Int# -> Int# -> Bool
(==#) :: Int# -> Int# -> Bool
(/=#) :: Int# -> Int# -> Bool
(<#) :: Int# -> Int# -> Bool
(<=#) :: Int# -> Int# -> Bool
chr# :: Int# -> Char#
int2Word# :: Int# -> Word#
int2Float# :: Int# -> Float#
int2Double# :: Int# -> Double#
uncheckedIShiftL# :: Int# -> Int# -> Int#
uncheckedIShiftRA# :: Int# -> Int# -> Int#
uncheckedIShiftRL# :: Int# -> Int# -> Int#
plusWord# :: Word# -> Word# -> Word#
minusWord# :: Word# -> Word# -> Word#
timesWord# :: Word# -> Word# -> Word#
quotWord# :: Word# -> Word# -> Word#
remWord# :: Word# -> Word# -> Word#
and# :: Word# -> Word# -> Word#
or# :: Word# -> Word# -> Word#
xor# :: Word# -> Word# -> Word#
not# :: Word# -> Word#
uncheckedShiftL# :: Word# -> Int# -> Word#
uncheckedShiftRL# :: Word# -> Int# -> Word#
word2Int# :: Word# -> Int#
gtWord# :: Word# -> Word# -> Bool
geWord# :: Word# -> Word# -> Bool
eqWord# :: Word# -> Word# -> Bool
neWord# :: Word# -> Word# -> Bool
ltWord# :: Word# -> Word# -> Bool
leWord# :: Word# -> Word# -> Bool
popCnt8# :: Word# -> Word#
popCnt16# :: Word# -> Word#
popCnt32# :: Word# -> Word#
popCnt64# :: Word64# -> Word#
popCnt# :: Word# -> Word#
narrow8Int# :: Int# -> Int#
narrow16Int# :: Int# -> Int#
narrow32Int# :: Int# -> Int#
narrow8Word# :: Word# -> Word#
narrow16Word# :: Word# -> Word#
narrow32Word# :: Word# -> Word#
(>##) :: Double# -> Double# -> Bool
(>=##) :: Double# -> Double# -> Bool
(==##) :: Double# -> Double# -> Bool
(/=##) :: Double# -> Double# -> Bool
(<##) :: Double# -> Double# -> Bool
(<=##) :: Double# -> Double# -> Bool
(+##) :: Double# -> Double# -> Double#
(-##) :: Double# -> Double# -> Double#
(*##) :: Double# -> Double# -> Double#
(/##) :: Double# -> Double# -> Double#
negateDouble# :: Double# -> Double#
double2Int# :: Double# -> Int#
double2Float# :: Double# -> Float#
expDouble# :: Double# -> Double#
logDouble# :: Double# -> Double#
sqrtDouble# :: Double# -> Double#
sinDouble# :: Double# -> Double#
cosDouble# :: Double# -> Double#
tanDouble# :: Double# -> Double#
asinDouble# :: Double# -> Double#
acosDouble# :: Double# -> Double#
atanDouble# :: Double# -> Double#
sinhDouble# :: Double# -> Double#
coshDouble# :: Double# -> Double#
tanhDouble# :: Double# -> Double#
(**##) :: Double# -> Double# -> Double#
decodeDouble_2Int# :: Double# -> (# Int#, Word#, Word#, Int# #)
gtFloat# :: Float# -> Float# -> Bool
geFloat# :: Float# -> Float# -> Bool
eqFloat# :: Float# -> Float# -> Bool
neFloat# :: Float# -> Float# -> Bool
ltFloat# :: Float# -> Float# -> Bool
leFloat# :: Float# -> Float# -> Bool
plusFloat# :: Float# -> Float# -> Float#
minusFloat# :: Float# -> Float# -> Float#
timesFloat# :: Float# -> Float# -> Float#
divideFloat# :: Float# -> Float# -> Float#
negateFloat# :: Float# -> Float#
float2Int# :: Float# -> Int#
expFloat# :: Float# -> Float#
logFloat# :: Float# -> Float#
sqrtFloat# :: Float# -> Float#
sinFloat# :: Float# -> Float#
cosFloat# :: Float# -> Float#
tanFloat# :: Float# -> Float#
asinFloat# :: Float# -> Float#
acosFloat# :: Float# -> Float#
atanFloat# :: Float# -> Float#
sinhFloat# :: Float# -> Float#
coshFloat# :: Float# -> Float#
tanhFloat# :: Float# -> Float#
powerFloat# :: Float# -> Float# -> Float#
float2Double# :: Float# -> Double#
decodeFloat_Int# :: Float# -> (# Int#, Int# #)
newArray# :: Int# -> a -> State# s -> (# State# s, MutableArray# s a #)
sameMutableArray# :: MutableArray# s a -> MutableArray# s a -> Bool
readArray# :: MutableArray# s a -> Int# -> State# s -> (# State# s, a #)
writeArray# :: MutableArray# s a -> Int# -> a -> State# s -> State# s
sizeofArray# :: Array# a -> Int#
sizeofMutableArray# :: MutableArray# s a -> Int#
indexArray# :: Array# a -> Int# -> (# a #)
unsafeFreezeArray# :: MutableArray# s a -> State# s -> (# State# s, Array# a #)
unsafeThawArray# :: Array# a -> State# s -> (# State# s, MutableArray# s a #)
copyArray# :: Array# a -> Int# -> MutableArray# s a -> Int# -> Int# -> State# s -> State# s
copyMutableArray# :: MutableArray# s a -> Int# -> MutableArray# s a -> Int# -> Int# -> State# s -> State# s
cloneArray# :: Array# a -> Int# -> Int# -> Array# a
cloneMutableArray# :: MutableArray# s a -> Int# -> Int# -> State# s -> (# State# s, MutableArray# s a #)
freezeArray# :: MutableArray# s a -> Int# -> Int# -> State# s -> (# State# s, Array# a #)
thawArray# :: Array# a -> Int# -> Int# -> State# s -> (# State# s, MutableArray# s a #)
newByteArray# :: Int# -> State# s -> (# State# s, MutableByteArray# s #)
newPinnedByteArray# :: Int# -> State# s -> (# State# s, MutableByteArray# s #)
newAlignedPinnedByteArray# :: Int# -> Int# -> State# s -> (# State# s, MutableByteArray# s #)
byteArrayContents# :: ByteArray# -> Addr#
sameMutableByteArray# :: MutableByteArray# s -> MutableByteArray# s -> Bool
unsafeFreezeByteArray# :: MutableByteArray# s -> State# s -> (# State# s, ByteArray# #)
sizeofByteArray# :: ByteArray# -> Int#
sizeofMutableByteArray# :: MutableByteArray# s -> Int#
indexCharArray# :: ByteArray# -> Int# -> Char#
indexWideCharArray# :: ByteArray# -> Int# -> Char#
indexIntArray# :: ByteArray# -> Int# -> Int#
indexWordArray# :: ByteArray# -> Int# -> Word#
indexAddrArray# :: ByteArray# -> Int# -> Addr#
indexFloatArray# :: ByteArray# -> Int# -> Float#
indexDoubleArray# :: ByteArray# -> Int# -> Double#
indexStablePtrArray# :: ByteArray# -> Int# -> StablePtr# a
indexInt8Array# :: ByteArray# -> Int# -> Int#
indexInt16Array# :: ByteArray# -> Int# -> Int#
indexInt32Array# :: ByteArray# -> Int# -> Int#
indexInt64Array# :: ByteArray# -> Int# -> Int64#
indexWord8Array# :: ByteArray# -> Int# -> Word#
indexWord16Array# :: ByteArray# -> Int# -> Word#
indexWord32Array# :: ByteArray# -> Int# -> Word#
indexWord64Array# :: ByteArray# -> Int# -> Word64#
readCharArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Char# #)
readWideCharArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Char# #)
readIntArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)
readWordArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word# #)
readAddrArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Addr# #)
readFloatArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Float# #)
readDoubleArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Double# #)
readStablePtrArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, StablePtr# a #)
readInt8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)
readInt16Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)
readInt32Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)
readInt64Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int64# #)
readWord8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word# #)
readWord16Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word# #)
readWord32Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word# #)
readWord64Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word64# #)
writeCharArray# :: MutableByteArray# s -> Int# -> Char# -> State# s -> State# s
writeWideCharArray# :: MutableByteArray# s -> Int# -> Char# -> State# s -> State# s
writeIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
writeWordArray# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s
writeAddrArray# :: MutableByteArray# s -> Int# -> Addr# -> State# s -> State# s
writeFloatArray# :: MutableByteArray# s -> Int# -> Float# -> State# s -> State# s
writeDoubleArray# :: MutableByteArray# s -> Int# -> Double# -> State# s -> State# s
writeStablePtrArray# :: MutableByteArray# s -> Int# -> StablePtr# a -> State# s -> State# s
writeInt8Array# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
writeInt16Array# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
writeInt32Array# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
writeInt64Array# :: MutableByteArray# s -> Int# -> Int64# -> State# s -> State# s
writeWord8Array# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s
writeWord16Array# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s
writeWord32Array# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s
writeWord64Array# :: MutableByteArray# s -> Int# -> Word64# -> State# s -> State# s
copyByteArray# :: ByteArray# -> Int# -> MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
copyMutableByteArray# :: MutableByteArray# s -> Int# -> MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
newArrayArray# :: Int# -> State# s -> (# State# s, MutableArrayArray# s #)
sameMutableArrayArray# :: MutableArrayArray# s -> MutableArrayArray# s -> Bool
unsafeFreezeArrayArray# :: MutableArrayArray# s -> State# s -> (# State# s, ArrayArray# #)
sizeofArrayArray# :: ArrayArray# -> Int#
sizeofMutableArrayArray# :: MutableArrayArray# s -> Int#
indexByteArrayArray# :: ArrayArray# -> Int# -> ByteArray#
indexArrayArrayArray# :: ArrayArray# -> Int# -> ArrayArray#
readByteArrayArray# :: MutableArrayArray# s -> Int# -> State# s -> (# State# s, ByteArray# #)
readMutableByteArrayArray# :: MutableArrayArray# s -> Int# -> State# s -> (# State# s, MutableByteArray# s #)
readArrayArrayArray# :: MutableArrayArray# s -> Int# -> State# s -> (# State# s, ArrayArray# #)
readMutableArrayArrayArray# :: MutableArrayArray# s -> Int# -> State# s -> (# State# s, MutableArrayArray# s #)
writeByteArrayArray# :: MutableArrayArray# s -> Int# -> ByteArray# -> State# s -> State# s
writeMutableByteArrayArray# :: MutableArrayArray# s -> Int# -> MutableByteArray# s -> State# s -> State# s
writeArrayArrayArray# :: MutableArrayArray# s -> Int# -> ArrayArray# -> State# s -> State# s
writeMutableArrayArrayArray# :: MutableArrayArray# s -> Int# -> MutableArrayArray# s -> State# s -> State# s
copyArrayArray# :: ArrayArray# -> Int# -> MutableArrayArray# s -> Int# -> Int# -> State# s -> State# s
copyMutableArrayArray# :: MutableArrayArray# s -> Int# -> MutableArrayArray# s -> Int# -> Int# -> State# s -> State# s
plusAddr# :: Addr# -> Int# -> Addr#
minusAddr# :: Addr# -> Addr# -> Int#
remAddr# :: Addr# -> Int# -> Int#
addr2Int# :: Addr# -> Int#
int2Addr# :: Int# -> Addr#
gtAddr# :: Addr# -> Addr# -> Bool
geAddr# :: Addr# -> Addr# -> Bool
eqAddr# :: Addr# -> Addr# -> Bool
neAddr# :: Addr# -> Addr# -> Bool
ltAddr# :: Addr# -> Addr# -> Bool
leAddr# :: Addr# -> Addr# -> Bool
indexCharOffAddr# :: Addr# -> Int# -> Char#
indexWideCharOffAddr# :: Addr# -> Int# -> Char#
indexIntOffAddr# :: Addr# -> Int# -> Int#
indexWordOffAddr# :: Addr# -> Int# -> Word#
indexAddrOffAddr# :: Addr# -> Int# -> Addr#
indexFloatOffAddr# :: Addr# -> Int# -> Float#
indexDoubleOffAddr# :: Addr# -> Int# -> Double#
indexStablePtrOffAddr# :: Addr# -> Int# -> StablePtr# a
indexInt8OffAddr# :: Addr# -> Int# -> Int#
indexInt16OffAddr# :: Addr# -> Int# -> Int#
indexInt32OffAddr# :: Addr# -> Int# -> Int#
indexInt64OffAddr# :: Addr# -> Int# -> Int64#
indexWord8OffAddr# :: Addr# -> Int# -> Word#
indexWord16OffAddr# :: Addr# -> Int# -> Word#
indexWord32OffAddr# :: Addr# -> Int# -> Word#
indexWord64OffAddr# :: Addr# -> Int# -> Word64#
readCharOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Char# #)
readWideCharOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Char# #)
readIntOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int# #)
readWordOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word# #)
readAddrOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Addr# #)
readFloatOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Float# #)
readDoubleOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Double# #)
readStablePtrOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, StablePtr# a #)
readInt8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int# #)
readInt16OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int# #)
readInt32OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int# #)
readInt64OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int64# #)
readWord8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word# #)
readWord16OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word# #)
readWord32OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word# #)
readWord64OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word64# #)
writeCharOffAddr# :: Addr# -> Int# -> Char# -> State# s -> State# s
writeWideCharOffAddr# :: Addr# -> Int# -> Char# -> State# s -> State# s
writeIntOffAddr# :: Addr# -> Int# -> Int# -> State# s -> State# s
writeWordOffAddr# :: Addr# -> Int# -> Word# -> State# s -> State# s
writeAddrOffAddr# :: Addr# -> Int# -> Addr# -> State# s -> State# s
writeFloatOffAddr# :: Addr# -> Int# -> Float# -> State# s -> State# s
writeDoubleOffAddr# :: Addr# -> Int# -> Double# -> State# s -> State# s
writeStablePtrOffAddr# :: Addr# -> Int# -> StablePtr# a -> State# s -> State# s
writeInt8OffAddr# :: Addr# -> Int# -> Int# -> State# s -> State# s
writeInt16OffAddr# :: Addr# -> Int# -> Int# -> State# s -> State# s
writeInt32OffAddr# :: Addr# -> Int# -> Int# -> State# s -> State# s
writeInt64OffAddr# :: Addr# -> Int# -> Int64# -> State# s -> State# s
writeWord8OffAddr# :: Addr# -> Int# -> Word# -> State# s -> State# s
writeWord16OffAddr# :: Addr# -> Int# -> Word# -> State# s -> State# s
writeWord32OffAddr# :: Addr# -> Int# -> Word# -> State# s -> State# s
writeWord64OffAddr# :: Addr# -> Int# -> Word64# -> State# s -> State# s
newMutVar# :: a -> State# s -> (# State# s, MutVar# s a #)
readMutVar# :: MutVar# s a -> State# s -> (# State# s, a #)
writeMutVar# :: MutVar# s a -> a -> State# s -> State# s
sameMutVar# :: MutVar# s a -> MutVar# s a -> Bool
atomicModifyMutVar# :: MutVar# s a -> (a -> b) -> State# s -> (# State# s, c #)
casMutVar# :: MutVar# s a -> a -> a -> State# s -> (# State# s, Int#, a #)
catch# :: (State# (RealWorld) -> (# State# (RealWorld), a #)) -> (b -> State# (RealWorld) -> (# State# (RealWorld), a #)) -> State# (RealWorld) -> (# State# (RealWorld), a #)
raise# :: a -> b
raiseIO# :: a -> State# (RealWorld) -> (# State# (RealWorld), b #)
maskAsyncExceptions# :: (State# (RealWorld) -> (# State# (RealWorld), a #)) -> State# (RealWorld) -> (# State# (RealWorld), a #)
maskUninterruptible# :: (State# (RealWorld) -> (# State# (RealWorld), a #)) -> State# (RealWorld) -> (# State# (RealWorld), a #)
unmaskAsyncExceptions# :: (State# (RealWorld) -> (# State# (RealWorld), a #)) -> State# (RealWorld) -> (# State# (RealWorld), a #)
getMaskingState# :: State# (RealWorld) -> (# State# (RealWorld), Int# #)
atomically# :: (State# (RealWorld) -> (# State# (RealWorld), a #)) -> State# (RealWorld) -> (# State# (RealWorld), a #)
retry# :: State# (RealWorld) -> (# State# (RealWorld), a #)
catchRetry# :: (State# (RealWorld) -> (# State# (RealWorld), a #)) -> (State# (RealWorld) -> (# State# (RealWorld), a #)) -> State# (RealWorld) -> (# State# (RealWorld), a #)
catchSTM# :: (State# (RealWorld) -> (# State# (RealWorld), a #)) -> (b -> State# (RealWorld) -> (# State# (RealWorld), a #)) -> State# (RealWorld) -> (# State# (RealWorld), a #)
check# :: (State# (RealWorld) -> (# State# (RealWorld), a #)) -> State# (RealWorld) -> (# State# (RealWorld), () #)
newTVar# :: a -> State# s -> (# State# s, TVar# s a #)
readTVar# :: TVar# s a -> State# s -> (# State# s, a #)
readTVarIO# :: TVar# s a -> State# s -> (# State# s, a #)
writeTVar# :: TVar# s a -> a -> State# s -> State# s
sameTVar# :: TVar# s a -> TVar# s a -> Bool
newMVar# :: State# s -> (# State# s, MVar# s a #)
takeMVar# :: MVar# s a -> State# s -> (# State# s, a #)
tryTakeMVar# :: MVar# s a -> State# s -> (# State# s, Int#, a #)
putMVar# :: MVar# s a -> a -> State# s -> State# s
tryPutMVar# :: MVar# s a -> a -> State# s -> (# State# s, Int# #)
sameMVar# :: MVar# s a -> MVar# s a -> Bool
isEmptyMVar# :: MVar# s a -> State# s -> (# State# s, Int# #)
delay# :: Int# -> State# s -> State# s
waitRead# :: Int# -> State# s -> State# s
waitWrite# :: Int# -> State# s -> State# s
fork# :: a -> State# (RealWorld) -> (# State# (RealWorld), ThreadId# #)
forkOn# :: Int# -> a -> State# (RealWorld) -> (# State# (RealWorld), ThreadId# #)
killThread# :: ThreadId# -> a -> State# (RealWorld) -> State# (RealWorld)
yield# :: State# (RealWorld) -> State# (RealWorld)
myThreadId# :: State# (RealWorld) -> (# State# (RealWorld), ThreadId# #)
labelThread# :: ThreadId# -> Addr# -> State# (RealWorld) -> State# (RealWorld)
isCurrentThreadBound# :: State# (RealWorld) -> (# State# (RealWorld), Int# #)
noDuplicate# :: State# (RealWorld) -> State# (RealWorld)
threadStatus# :: ThreadId# -> State# (RealWorld) -> (# State# (RealWorld), Int#, Int#, Int# #)
mkWeak# :: o -> b -> c -> State# (RealWorld) -> (# State# (RealWorld), Weak# b #)
mkWeakForeignEnv# :: o -> b -> Addr# -> Addr# -> Int# -> Addr# -> State# (RealWorld) -> (# State# (RealWorld), Weak# b #)
deRefWeak# :: Weak# a -> State# (RealWorld) -> (# State# (RealWorld), Int#, a #)
finalizeWeak# :: Weak# a -> State# (RealWorld) -> (# State# (RealWorld), Int#, State# (RealWorld) -> (# State# (RealWorld), () #) #)
touch# :: o -> State# (RealWorld) -> State# (RealWorld)
makeStablePtr# :: a -> State# (RealWorld) -> (# State# (RealWorld), StablePtr# a #)
deRefStablePtr# :: StablePtr# a -> State# (RealWorld) -> (# State# (RealWorld), a #)
eqStablePtr# :: StablePtr# a -> StablePtr# a -> Int#
makeStableName# :: a -> State# (RealWorld) -> (# State# (RealWorld), StableName# a #)
eqStableName# :: StableName# a -> StableName# a -> Int#
stableNameToInt# :: StableName# a -> Int#
reallyUnsafePtrEquality# :: a -> a -> Int#
duplicate# :: a -> State# (RealWorld) -> (# State# (RealWorld), a #)
serialize# :: a -> State# s -> (# State# s, ByteArray# #)
deserialize# :: ByteArray# -> State# s -> (# State# s, a #)
expectData# :: State# (RealWorld) -> (# State# (RealWorld), Int#, Int#, a #)
connectToPort# :: Int# -> Int# -> Int# -> State# (RealWorld) -> State# (RealWorld)
sendData# :: Int# -> a -> State# (RealWorld) -> State# (RealWorld)
labelProcess# :: Addr# -> State# (RealWorld) -> State# (RealWorld)
myProcess# :: State# (RealWorld) -> (# State# (RealWorld), Int# #)
spark# :: a -> State# s -> (# State# s, a #)
getSpark# :: State# s -> (# State# s, Int#, a #)
numSparks# :: State# s -> (# State# s, Int# #)
dataToTag# :: a -> Int#
addrToAny# :: Addr# -> (# a #)
mkApUpd0# :: BCO# -> (# a #)
newBCO# :: ByteArray# -> ByteArray# -> Array# a -> Int# -> ByteArray# -> State# s -> (# State# s, BCO# #)
unpackClosure# :: a -> (# Addr#, Array# b, ByteArray# #)
getApStackVal# :: a -> Int# -> (# Int#, b #)
getCCSOf# :: a -> State# s -> (# State# s, Addr# #)
getCurrentCCS# :: a -> State# s -> (# State# s, Addr# #)
traceEvent# :: Addr# -> State# s -> State# s


-- | GHC's primitive types and operations. Use GHC.Exts from the base
--   package instead of importing this module directly.
module GHC.Prim
data Char#
gtChar# :: Char# -> Char# -> Bool
geChar# :: Char# -> Char# -> Bool
eqChar# :: Char# -> Char# -> Bool
neChar# :: Char# -> Char# -> Bool
ltChar# :: Char# -> Char# -> Bool
leChar# :: Char# -> Char# -> Bool
ord# :: Char# -> Int#
data Int#
(+#) :: Int# -> Int# -> Int#
(-#) :: Int# -> Int# -> Int#

-- | Low word of signed integer multiply.
(*#) :: Int# -> Int# -> Int#

-- | Return non-zero if there is any possibility that the upper word of a
--   signed integer multiply might contain useful information. Return zero
--   only if you are completely sure that no overflow can occur. On a
--   32-bit platform, the recommmended implementation is to do a 32 x 32
--   -&gt; 64 signed multiply, and subtract result[63:32] from (result[31]
--   &gt;&gt;signed 31). If this is zero, meaning that the upper word is
--   merely a sign extension of the lower one, no overflow can occur.
--   
--   On a 64-bit platform it is not always possible to acquire the top 64
--   bits of the result. Therefore, a recommended implementation is to take
--   the absolute value of both operands, and return 0 iff bits[63:31] of
--   them are zero, since that means that their magnitudes fit within 31
--   bits, so the magnitude of the product must fit into 62 bits.
--   
--   If in doubt, return non-zero, but do make an effort to create the
--   correct answer for small args, since otherwise the performance of
--   <tt>(*) :: Integer -&gt; Integer -&gt; Integer</tt> will be poor.
mulIntMayOflo# :: Int# -> Int# -> Int#

-- | Rounds towards zero.
quotInt# :: Int# -> Int# -> Int#

-- | Satisfies <tt>(quotInt# x y) *# y +# (remInt# x y) == x</tt>.
remInt# :: Int# -> Int# -> Int#
negateInt# :: Int# -> Int#

-- | Add with carry. First member of result is (wrapped) sum; second member
--   is 0 iff no overflow occured.
addIntC# :: Int# -> Int# -> (# Int#, Int# #)

-- | Subtract with carry. First member of result is (wrapped) difference;
--   second member is 0 iff no overflow occured.
subIntC# :: Int# -> Int# -> (# Int#, Int# #)
(>#) :: Int# -> Int# -> Bool
(>=#) :: Int# -> Int# -> Bool
(==#) :: Int# -> Int# -> Bool
(/=#) :: Int# -> Int# -> Bool
(<#) :: Int# -> Int# -> Bool
(<=#) :: Int# -> Int# -> Bool
chr# :: Int# -> Char#
int2Word# :: Int# -> Word#
int2Float# :: Int# -> Float#
int2Double# :: Int# -> Double#

-- | Shift left. Result undefined if shift amount is not in the range 0 to
--   word size - 1 inclusive.
uncheckedIShiftL# :: Int# -> Int# -> Int#

-- | Shift right arithmetic. Result undefined if shift amount is not in the
--   range 0 to word size - 1 inclusive.
uncheckedIShiftRA# :: Int# -> Int# -> Int#

-- | Shift right logical. Result undefined if shift amount is not in the
--   range 0 to word size - 1 inclusive.
uncheckedIShiftRL# :: Int# -> Int# -> Int#
data Word#
plusWord# :: Word# -> Word# -> Word#
minusWord# :: Word# -> Word# -> Word#
timesWord# :: Word# -> Word# -> Word#
quotWord# :: Word# -> Word# -> Word#
remWord# :: Word# -> Word# -> Word#
and# :: Word# -> Word# -> Word#
or# :: Word# -> Word# -> Word#
xor# :: Word# -> Word# -> Word#
not# :: Word# -> Word#

-- | Shift left logical. Result undefined if shift amount is not in the
--   range 0 to word size - 1 inclusive.
uncheckedShiftL# :: Word# -> Int# -> Word#

-- | Shift right logical. Result undefined if shift amount is not in the
--   range 0 to word size - 1 inclusive.
uncheckedShiftRL# :: Word# -> Int# -> Word#
word2Int# :: Word# -> Int#
gtWord# :: Word# -> Word# -> Bool
geWord# :: Word# -> Word# -> Bool
eqWord# :: Word# -> Word# -> Bool
neWord# :: Word# -> Word# -> Bool
ltWord# :: Word# -> Word# -> Bool
leWord# :: Word# -> Word# -> Bool

-- | Count the number of set bits in the lower 8 bits of a word.
popCnt8# :: Word# -> Word#

-- | Count the number of set bits in the lower 16 bits of a word.
popCnt16# :: Word# -> Word#

-- | Count the number of set bits in the lower 32 bits of a word.
popCnt32# :: Word# -> Word#

-- | Count the number of set bits in a 64-bit word.
popCnt64# :: Word64# -> Word#

-- | Count the number of set bits in a word.
popCnt# :: Word# -> Word#
narrow8Int# :: Int# -> Int#
narrow16Int# :: Int# -> Int#
narrow32Int# :: Int# -> Int#
narrow8Word# :: Word# -> Word#
narrow16Word# :: Word# -> Word#
narrow32Word# :: Word# -> Word#
data Int64#
data Word64#
data Double#
(>##) :: Double# -> Double# -> Bool
(>=##) :: Double# -> Double# -> Bool
(==##) :: Double# -> Double# -> Bool
(/=##) :: Double# -> Double# -> Bool
(<##) :: Double# -> Double# -> Bool
(<=##) :: Double# -> Double# -> Bool
(+##) :: Double# -> Double# -> Double#
(-##) :: Double# -> Double# -> Double#
(*##) :: Double# -> Double# -> Double#
(/##) :: Double# -> Double# -> Double#
negateDouble# :: Double# -> Double#

-- | Truncates a <tt>Double</tt>. Results are undefined if the truncation
--   if truncation yields a value outside the range of <tt>Int#</tt>.
double2Int# :: Double# -> Int#
double2Float# :: Double# -> Float#
expDouble# :: Double# -> Double#
logDouble# :: Double# -> Double#
sqrtDouble# :: Double# -> Double#
sinDouble# :: Double# -> Double#
cosDouble# :: Double# -> Double#
tanDouble# :: Double# -> Double#
asinDouble# :: Double# -> Double#
acosDouble# :: Double# -> Double#
atanDouble# :: Double# -> Double#
sinhDouble# :: Double# -> Double#
coshDouble# :: Double# -> Double#
tanhDouble# :: Double# -> Double#

-- | Exponentiation.
(**##) :: Double# -> Double# -> Double#

-- | Convert to integer. First component of the result is -1 or 1,
--   indicating the sign of the mantissa. The next two are the high and low
--   32 bits of the mantissa respectively, and the last is the exponent.
decodeDouble_2Int# :: Double# -> (# Int#, Word#, Word#, Int# #)
data Float#
gtFloat# :: Float# -> Float# -> Bool
geFloat# :: Float# -> Float# -> Bool
eqFloat# :: Float# -> Float# -> Bool
neFloat# :: Float# -> Float# -> Bool
ltFloat# :: Float# -> Float# -> Bool
leFloat# :: Float# -> Float# -> Bool
plusFloat# :: Float# -> Float# -> Float#
minusFloat# :: Float# -> Float# -> Float#
timesFloat# :: Float# -> Float# -> Float#
divideFloat# :: Float# -> Float# -> Float#
negateFloat# :: Float# -> Float#

-- | Truncates a <tt>Float</tt>. Results are undefined if the truncation if
--   truncation yields a value outside the range of <tt>Int#</tt>.
float2Int# :: Float# -> Int#
expFloat# :: Float# -> Float#
logFloat# :: Float# -> Float#
sqrtFloat# :: Float# -> Float#
sinFloat# :: Float# -> Float#
cosFloat# :: Float# -> Float#
tanFloat# :: Float# -> Float#
asinFloat# :: Float# -> Float#
acosFloat# :: Float# -> Float#
atanFloat# :: Float# -> Float#
sinhFloat# :: Float# -> Float#
coshFloat# :: Float# -> Float#
tanhFloat# :: Float# -> Float#
powerFloat# :: Float# -> Float# -> Float#
float2Double# :: Float# -> Double#

-- | Convert to integers. First <tt>Int#</tt> in result is the mantissa;
--   second is the exponent.
decodeFloat_Int# :: Float# -> (# Int#, Int# #)
data Array# a
data MutableArray# s a

-- | Create a new mutable array with the specified number of elements, in
--   the specified state thread, with each element containing the specified
--   initial value.
newArray# :: Int# -> a -> State# s -> (# State# s, MutableArray# s a #)
sameMutableArray# :: MutableArray# s a -> MutableArray# s a -> Bool

-- | Read from specified index of mutable array. Result is not yet
--   evaluated.
readArray# :: MutableArray# s a -> Int# -> State# s -> (# State# s, a #)

-- | Write to specified index of mutable array.
writeArray# :: MutableArray# s a -> Int# -> a -> State# s -> State# s

-- | Return the number of elements in the array.
sizeofArray# :: Array# a -> Int#

-- | Return the number of elements in the array.
sizeofMutableArray# :: MutableArray# s a -> Int#

-- | Read from specified index of immutable array. Result is packaged into
--   an unboxed singleton; the result itself is not yet evaluated.
indexArray# :: Array# a -> Int# -> (# a #)

-- | Make a mutable array immutable, without copying.
unsafeFreezeArray# :: MutableArray# s a -> State# s -> (# State# s, Array# a #)

-- | Make an immutable array mutable, without copying.
unsafeThawArray# :: Array# a -> State# s -> (# State# s, MutableArray# s a #)

-- | Copy a range of the Array. Both arrays must fully contain the
--   specified ranges, but this is not checked. The two arrays must not be
--   the same array in different states, but this is not checked either.
copyArray# :: Array# a -> Int# -> MutableArray# s a -> Int# -> Int# -> State# s -> State# s

-- | Copy a range of the first MutableArray. Both arrays must fully contain
--   the specified ranges, but this is not checked.
copyMutableArray# :: MutableArray# s a -> Int# -> MutableArray# s a -> Int# -> Int# -> State# s -> State# s

-- | Return a newly allocated Array. The provided Arrays, but this is not
--   checked.
cloneArray# :: Array# a -> Int# -> Int# -> Array# a

-- | Return a newly allocated Array. The provided MutableArrays, but this
--   is not checked.
cloneMutableArray# :: MutableArray# s a -> Int# -> Int# -> State# s -> (# State# s, MutableArray# s a #)

-- | Return a newly allocated Array. The provided MutableArrays, but this
--   is not checked.
freezeArray# :: MutableArray# s a -> Int# -> Int# -> State# s -> (# State# s, Array# a #)

-- | Return a newly allocated Array. The provided Arrays, but this is not
--   checked.
thawArray# :: Array# a -> Int# -> Int# -> State# s -> (# State# s, MutableArray# s a #)
data ByteArray#
data MutableByteArray# s

-- | Create a new mutable byte array of specified size (in bytes), in the
--   specified state thread.
newByteArray# :: Int# -> State# s -> (# State# s, MutableByteArray# s #)

-- | Create a mutable byte array that the GC guarantees not to move.
newPinnedByteArray# :: Int# -> State# s -> (# State# s, MutableByteArray# s #)

-- | Create a mutable byte array, aligned by the specified amount, that the
--   GC guarantees not to move.
newAlignedPinnedByteArray# :: Int# -> Int# -> State# s -> (# State# s, MutableByteArray# s #)

-- | Intended for use with pinned arrays; otherwise very unsafe!
byteArrayContents# :: ByteArray# -> Addr#
sameMutableByteArray# :: MutableByteArray# s -> MutableByteArray# s -> Bool

-- | Make a mutable byte array immutable, without copying.
unsafeFreezeByteArray# :: MutableByteArray# s -> State# s -> (# State# s, ByteArray# #)

-- | Return the size of the array in bytes.
sizeofByteArray# :: ByteArray# -> Int#

-- | Return the size of the array in bytes.
sizeofMutableByteArray# :: MutableByteArray# s -> Int#

-- | Read 8-bit character; offset in bytes.
indexCharArray# :: ByteArray# -> Int# -> Char#

-- | Read 31-bit character; offset in 4-byte words.
indexWideCharArray# :: ByteArray# -> Int# -> Char#
indexIntArray# :: ByteArray# -> Int# -> Int#
indexWordArray# :: ByteArray# -> Int# -> Word#
indexAddrArray# :: ByteArray# -> Int# -> Addr#
indexFloatArray# :: ByteArray# -> Int# -> Float#
indexDoubleArray# :: ByteArray# -> Int# -> Double#
indexStablePtrArray# :: ByteArray# -> Int# -> StablePtr# a
indexInt8Array# :: ByteArray# -> Int# -> Int#
indexInt16Array# :: ByteArray# -> Int# -> Int#
indexInt32Array# :: ByteArray# -> Int# -> Int#
indexInt64Array# :: ByteArray# -> Int# -> Int64#
indexWord8Array# :: ByteArray# -> Int# -> Word#
indexWord16Array# :: ByteArray# -> Int# -> Word#
indexWord32Array# :: ByteArray# -> Int# -> Word#
indexWord64Array# :: ByteArray# -> Int# -> Word64#

-- | Read 8-bit character; offset in bytes.
readCharArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Char# #)

-- | Read 31-bit character; offset in 4-byte words.
readWideCharArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Char# #)
readIntArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)
readWordArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word# #)
readAddrArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Addr# #)
readFloatArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Float# #)
readDoubleArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Double# #)
readStablePtrArray# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, StablePtr# a #)
readInt8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)
readInt16Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)
readInt32Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int# #)
readInt64Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Int64# #)
readWord8Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word# #)
readWord16Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word# #)
readWord32Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word# #)
readWord64Array# :: MutableByteArray# s -> Int# -> State# s -> (# State# s, Word64# #)

-- | Write 8-bit character; offset in bytes.
writeCharArray# :: MutableByteArray# s -> Int# -> Char# -> State# s -> State# s

-- | Write 31-bit character; offset in 4-byte words.
writeWideCharArray# :: MutableByteArray# s -> Int# -> Char# -> State# s -> State# s
writeIntArray# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
writeWordArray# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s
writeAddrArray# :: MutableByteArray# s -> Int# -> Addr# -> State# s -> State# s
writeFloatArray# :: MutableByteArray# s -> Int# -> Float# -> State# s -> State# s
writeDoubleArray# :: MutableByteArray# s -> Int# -> Double# -> State# s -> State# s
writeStablePtrArray# :: MutableByteArray# s -> Int# -> StablePtr# a -> State# s -> State# s
writeInt8Array# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
writeInt16Array# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
writeInt32Array# :: MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
writeInt64Array# :: MutableByteArray# s -> Int# -> Int64# -> State# s -> State# s
writeWord8Array# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s
writeWord16Array# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s
writeWord32Array# :: MutableByteArray# s -> Int# -> Word# -> State# s -> State# s
writeWord64Array# :: MutableByteArray# s -> Int# -> Word64# -> State# s -> State# s

-- | Copy a range of the ByteArray. Both arrays must fully contain the
--   specified ranges, but this is not checked. The two arrays must not be
--   the same array in different states, but this is not checked either.
copyByteArray# :: ByteArray# -> Int# -> MutableByteArray# s -> Int# -> Int# -> State# s -> State# s

-- | Copy a range of the first MutableByteArray. Both arrays must fully
--   contain the specified ranges, but this is not checked.
copyMutableByteArray# :: MutableByteArray# s -> Int# -> MutableByteArray# s -> Int# -> Int# -> State# s -> State# s
data ArrayArray#
data MutableArrayArray# s

-- | Create a new mutable array of arrays with the specified number of
--   elements, in the specified state thread, with each element recursively
--   referring to the newly created array.
newArrayArray# :: Int# -> State# s -> (# State# s, MutableArrayArray# s #)
sameMutableArrayArray# :: MutableArrayArray# s -> MutableArrayArray# s -> Bool

-- | Make a mutable array of arrays immutable, without copying.
unsafeFreezeArrayArray# :: MutableArrayArray# s -> State# s -> (# State# s, ArrayArray# #)

-- | Return the number of elements in the array.
sizeofArrayArray# :: ArrayArray# -> Int#

-- | Return the number of elements in the array.
sizeofMutableArrayArray# :: MutableArrayArray# s -> Int#
indexByteArrayArray# :: ArrayArray# -> Int# -> ByteArray#
indexArrayArrayArray# :: ArrayArray# -> Int# -> ArrayArray#
readByteArrayArray# :: MutableArrayArray# s -> Int# -> State# s -> (# State# s, ByteArray# #)
readMutableByteArrayArray# :: MutableArrayArray# s -> Int# -> State# s -> (# State# s, MutableByteArray# s #)
readArrayArrayArray# :: MutableArrayArray# s -> Int# -> State# s -> (# State# s, ArrayArray# #)
readMutableArrayArrayArray# :: MutableArrayArray# s -> Int# -> State# s -> (# State# s, MutableArrayArray# s #)
writeByteArrayArray# :: MutableArrayArray# s -> Int# -> ByteArray# -> State# s -> State# s
writeMutableByteArrayArray# :: MutableArrayArray# s -> Int# -> MutableByteArray# s -> State# s -> State# s
writeArrayArrayArray# :: MutableArrayArray# s -> Int# -> ArrayArray# -> State# s -> State# s
writeMutableArrayArrayArray# :: MutableArrayArray# s -> Int# -> MutableArrayArray# s -> State# s -> State# s

-- | Copy a range of the ArrayArray. Both arrays must fully contain the
--   specified ranges, but this is not checked. The two arrays must not be
--   the same array in different states, but this is not checked either.
copyArrayArray# :: ArrayArray# -> Int# -> MutableArrayArray# s -> Int# -> Int# -> State# s -> State# s

-- | Copy a range of the first MutableArrayArray# to the specified region
--   in the second MutableArrayArray#. Both arrays must fully contain the
--   specified ranges, but this is not checked.
copyMutableArrayArray# :: MutableArrayArray# s -> Int# -> MutableArrayArray# s -> Int# -> Int# -> State# s -> State# s

-- | An arbitrary machine address assumed to point outside the
--   garbage-collected heap.
data Addr#

-- | The null address.
nullAddr# :: Addr#
plusAddr# :: Addr# -> Int# -> Addr#

-- | Result is meaningless if two <tt>Addr#</tt>s are so far apart that
--   their difference doesn't fit in an <tt>Int#</tt>.
minusAddr# :: Addr# -> Addr# -> Int#

-- | Return the remainder when the <tt>Addr#</tt> arg, treated like an
--   <tt>Int#</tt>, is divided by the <tt>Int#</tt> arg.
remAddr# :: Addr# -> Int# -> Int#

-- | Coerce directly from address to int. Strongly deprecated.
addr2Int# :: Addr# -> Int#

-- | Coerce directly from int to address. Strongly deprecated.
int2Addr# :: Int# -> Addr#
gtAddr# :: Addr# -> Addr# -> Bool
geAddr# :: Addr# -> Addr# -> Bool
eqAddr# :: Addr# -> Addr# -> Bool
neAddr# :: Addr# -> Addr# -> Bool
ltAddr# :: Addr# -> Addr# -> Bool
leAddr# :: Addr# -> Addr# -> Bool

-- | Reads 8-bit character; offset in bytes.
indexCharOffAddr# :: Addr# -> Int# -> Char#

-- | Reads 31-bit character; offset in 4-byte words.
indexWideCharOffAddr# :: Addr# -> Int# -> Char#
indexIntOffAddr# :: Addr# -> Int# -> Int#
indexWordOffAddr# :: Addr# -> Int# -> Word#
indexAddrOffAddr# :: Addr# -> Int# -> Addr#
indexFloatOffAddr# :: Addr# -> Int# -> Float#
indexDoubleOffAddr# :: Addr# -> Int# -> Double#
indexStablePtrOffAddr# :: Addr# -> Int# -> StablePtr# a
indexInt8OffAddr# :: Addr# -> Int# -> Int#
indexInt16OffAddr# :: Addr# -> Int# -> Int#
indexInt32OffAddr# :: Addr# -> Int# -> Int#
indexInt64OffAddr# :: Addr# -> Int# -> Int64#
indexWord8OffAddr# :: Addr# -> Int# -> Word#
indexWord16OffAddr# :: Addr# -> Int# -> Word#
indexWord32OffAddr# :: Addr# -> Int# -> Word#
indexWord64OffAddr# :: Addr# -> Int# -> Word64#

-- | Reads 8-bit character; offset in bytes.
readCharOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Char# #)

-- | Reads 31-bit character; offset in 4-byte words.
readWideCharOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Char# #)
readIntOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int# #)
readWordOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word# #)
readAddrOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Addr# #)
readFloatOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Float# #)
readDoubleOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Double# #)
readStablePtrOffAddr# :: Addr# -> Int# -> State# s -> (# State# s, StablePtr# a #)
readInt8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int# #)
readInt16OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int# #)
readInt32OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int# #)
readInt64OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Int64# #)
readWord8OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word# #)
readWord16OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word# #)
readWord32OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word# #)
readWord64OffAddr# :: Addr# -> Int# -> State# s -> (# State# s, Word64# #)
writeCharOffAddr# :: Addr# -> Int# -> Char# -> State# s -> State# s
writeWideCharOffAddr# :: Addr# -> Int# -> Char# -> State# s -> State# s
writeIntOffAddr# :: Addr# -> Int# -> Int# -> State# s -> State# s
writeWordOffAddr# :: Addr# -> Int# -> Word# -> State# s -> State# s
writeAddrOffAddr# :: Addr# -> Int# -> Addr# -> State# s -> State# s
writeFloatOffAddr# :: Addr# -> Int# -> Float# -> State# s -> State# s
writeDoubleOffAddr# :: Addr# -> Int# -> Double# -> State# s -> State# s
writeStablePtrOffAddr# :: Addr# -> Int# -> StablePtr# a -> State# s -> State# s
writeInt8OffAddr# :: Addr# -> Int# -> Int# -> State# s -> State# s
writeInt16OffAddr# :: Addr# -> Int# -> Int# -> State# s -> State# s
writeInt32OffAddr# :: Addr# -> Int# -> Int# -> State# s -> State# s
writeInt64OffAddr# :: Addr# -> Int# -> Int64# -> State# s -> State# s
writeWord8OffAddr# :: Addr# -> Int# -> Word# -> State# s -> State# s
writeWord16OffAddr# :: Addr# -> Int# -> Word# -> State# s -> State# s
writeWord32OffAddr# :: Addr# -> Int# -> Word# -> State# s -> State# s
writeWord64OffAddr# :: Addr# -> Int# -> Word64# -> State# s -> State# s

-- | A <tt>MutVar#</tt> behaves like a single-element mutable array.
data MutVar# s a

-- | Create <tt>MutVar#</tt> with specified initial value in specified
--   state thread.
newMutVar# :: a -> State# s -> (# State# s, MutVar# s a #)

-- | Read contents of <tt>MutVar#</tt>. Result is not yet evaluated.
readMutVar# :: MutVar# s a -> State# s -> (# State# s, a #)

-- | Write contents of <tt>MutVar#</tt>.
writeMutVar# :: MutVar# s a -> a -> State# s -> State# s
sameMutVar# :: MutVar# s a -> MutVar# s a -> Bool
atomicModifyMutVar# :: MutVar# s a -> (a -> b) -> State# s -> (# State# s, c #)
casMutVar# :: MutVar# s a -> a -> a -> State# s -> (# State# s, Int#, a #)
catch# :: (State# (RealWorld) -> (# State# (RealWorld), a #)) -> (b -> State# (RealWorld) -> (# State# (RealWorld), a #)) -> State# (RealWorld) -> (# State# (RealWorld), a #)
raise# :: a -> b
raiseIO# :: a -> State# (RealWorld) -> (# State# (RealWorld), b #)
maskAsyncExceptions# :: (State# (RealWorld) -> (# State# (RealWorld), a #)) -> State# (RealWorld) -> (# State# (RealWorld), a #)
maskUninterruptible# :: (State# (RealWorld) -> (# State# (RealWorld), a #)) -> State# (RealWorld) -> (# State# (RealWorld), a #)
unmaskAsyncExceptions# :: (State# (RealWorld) -> (# State# (RealWorld), a #)) -> State# (RealWorld) -> (# State# (RealWorld), a #)
getMaskingState# :: State# (RealWorld) -> (# State# (RealWorld), Int# #)
data TVar# s a
atomically# :: (State# (RealWorld) -> (# State# (RealWorld), a #)) -> State# (RealWorld) -> (# State# (RealWorld), a #)
retry# :: State# (RealWorld) -> (# State# (RealWorld), a #)
catchRetry# :: (State# (RealWorld) -> (# State# (RealWorld), a #)) -> (State# (RealWorld) -> (# State# (RealWorld), a #)) -> State# (RealWorld) -> (# State# (RealWorld), a #)
catchSTM# :: (State# (RealWorld) -> (# State# (RealWorld), a #)) -> (b -> State# (RealWorld) -> (# State# (RealWorld), a #)) -> State# (RealWorld) -> (# State# (RealWorld), a #)
check# :: (State# (RealWorld) -> (# State# (RealWorld), a #)) -> State# (RealWorld) -> (# State# (RealWorld), () #)

-- | Create a new <tt>TVar#</tt> holding a specified initial value.
newTVar# :: a -> State# s -> (# State# s, TVar# s a #)

-- | Read contents of <tt>TVar#</tt>. Result is not yet evaluated.
readTVar# :: TVar# s a -> State# s -> (# State# s, a #)

-- | Read contents of <tt>TVar#</tt> outside an STM transaction
readTVarIO# :: TVar# s a -> State# s -> (# State# s, a #)

-- | Write contents of <tt>TVar#</tt>.
writeTVar# :: TVar# s a -> a -> State# s -> State# s
sameTVar# :: TVar# s a -> TVar# s a -> Bool

-- | A shared mutable variable (<i>not</i> the same as a
--   <tt>MutVar#</tt>!). (Note: in a non-concurrent implementation,
--   <tt>(MVar# a)</tt> can be represented by <tt>(MutVar# (Maybe
--   a))</tt>.)
data MVar# s a

-- | Create new <tt>MVar#</tt>; initially empty.
newMVar# :: State# s -> (# State# s, MVar# s a #)

-- | If <tt>MVar#</tt> is empty, block until it becomes full. Then remove
--   and return its contents, and set it empty.
takeMVar# :: MVar# s a -> State# s -> (# State# s, a #)

-- | If <tt>MVar#</tt> is empty, immediately return with integer 0 and
--   value undefined. Otherwise, return with integer 1 and contents of
--   <tt>MVar#</tt>, and set <tt>MVar#</tt> empty.
tryTakeMVar# :: MVar# s a -> State# s -> (# State# s, Int#, a #)

-- | If <tt>MVar#</tt> is full, block until it becomes empty. Then store
--   value arg as its new contents.
putMVar# :: MVar# s a -> a -> State# s -> State# s

-- | If <tt>MVar#</tt> is full, immediately return with integer 0.
--   Otherwise, store value arg as <tt>MVar#</tt>'s new contents, and
--   return with integer 1.
tryPutMVar# :: MVar# s a -> a -> State# s -> (# State# s, Int# #)
sameMVar# :: MVar# s a -> MVar# s a -> Bool

-- | Return 1 if <tt>MVar#</tt> is empty; 0 otherwise.
isEmptyMVar# :: MVar# s a -> State# s -> (# State# s, Int# #)

-- | Sleep specified number of microseconds.
delay# :: Int# -> State# s -> State# s

-- | Block until input is available on specified file descriptor.
waitRead# :: Int# -> State# s -> State# s

-- | Block until output is possible on specified file descriptor.
waitWrite# :: Int# -> State# s -> State# s

-- | <tt>State#</tt> is the primitive, unlifted type of states. It has one
--   type parameter, thus <tt>State# RealWorld</tt>, or <tt>State# s</tt>,
--   where s is a type variable. The only purpose of the type parameter is
--   to keep different state threads separate. It is represented by nothing
--   at all.
data State# s

-- | <tt>RealWorld</tt> is deeply magical. It is <i>primitive</i>, but it
--   is not <i>unlifted</i> (hence <tt>ptrArg</tt>). We never manipulate
--   values of type <tt>RealWorld</tt>; it's only used in the type system,
--   to parameterise <tt>State#</tt>.
data RealWorld

-- | (In a non-concurrent implementation, this can be a singleton type,
--   whose (unique) value is returned by <tt>myThreadId#</tt>. The other
--   operations can be omitted.)
data ThreadId#
fork# :: a -> State# (RealWorld) -> (# State# (RealWorld), ThreadId# #)
forkOn# :: Int# -> a -> State# (RealWorld) -> (# State# (RealWorld), ThreadId# #)
killThread# :: ThreadId# -> a -> State# (RealWorld) -> State# (RealWorld)
yield# :: State# (RealWorld) -> State# (RealWorld)
myThreadId# :: State# (RealWorld) -> (# State# (RealWorld), ThreadId# #)
labelThread# :: ThreadId# -> Addr# -> State# (RealWorld) -> State# (RealWorld)
isCurrentThreadBound# :: State# (RealWorld) -> (# State# (RealWorld), Int# #)
noDuplicate# :: State# (RealWorld) -> State# (RealWorld)
threadStatus# :: ThreadId# -> State# (RealWorld) -> (# State# (RealWorld), Int#, Int#, Int# #)
data Weak# b
mkWeak# :: o -> b -> c -> State# (RealWorld) -> (# State# (RealWorld), Weak# b #)
mkWeakForeignEnv# :: o -> b -> Addr# -> Addr# -> Int# -> Addr# -> State# (RealWorld) -> (# State# (RealWorld), Weak# b #)
deRefWeak# :: Weak# a -> State# (RealWorld) -> (# State# (RealWorld), Int#, a #)
finalizeWeak# :: Weak# a -> State# (RealWorld) -> (# State# (RealWorld), Int#, State# (RealWorld) -> (# State# (RealWorld), () #) #)
touch# :: o -> State# (RealWorld) -> State# (RealWorld)
data StablePtr# a
data StableName# a
makeStablePtr# :: a -> State# (RealWorld) -> (# State# (RealWorld), StablePtr# a #)
deRefStablePtr# :: StablePtr# a -> State# (RealWorld) -> (# State# (RealWorld), a #)
eqStablePtr# :: StablePtr# a -> StablePtr# a -> Int#
makeStableName# :: a -> State# (RealWorld) -> (# State# (RealWorld), StableName# a #)
eqStableName# :: StableName# a -> StableName# a -> Int#
stableNameToInt# :: StableName# a -> Int#
reallyUnsafePtrEquality# :: a -> a -> Int#

-- | for tests only: Packs and unpacks a subgraph in the local heap.
duplicate# :: a -> State# (RealWorld) -> (# State# (RealWorld), a #)

-- | serialize a subgraph in the heap, into a primitive array
serialize# :: a -> State# s -> (# State# s, ByteArray# #)

-- | deserialize a subgraph serialized before, into the heap
deserialize# :: ByteArray# -> State# s -> (# State# s, a #)

-- | creates a blackhole (a) and an inport (Ints are Proc.Id and Port ID)
expectData# :: State# (RealWorld) -> (# State# (RealWorld), Int#, Int#, a #)

-- | stores an inport (given as 3 Ints) as receiver in the calling thread
connectToPort# :: Int# -> Int# -> Int# -> State# (RealWorld) -> State# (RealWorld)

-- | sends data to an inport.
--   
--   The first argument encodes a send mode (low bits) and possibly a
--   target PE (high bits) for process placement.
--   
--   Send modes:
--   
--   <ul>
--   <li>1: connection message</li>
--   <li>2: stream data</li>
--   <li>3: single data, closing the inport</li>
--   <li>4: rFork (PE indicated by higher bits above 4)</li>
--   </ul>
sendData# :: Int# -> a -> State# (RealWorld) -> State# (RealWorld)

-- | sets a label for the process of the caller, relevant only for tracing
--   (writes an event)
labelProcess# :: Addr# -> State# (RealWorld) -> State# (RealWorld)

-- | returns process ID where the calling thread belongs.
--   
--   Code for experiments with Eden Debugger/Haskell scheduler
myProcess# :: State# (RealWorld) -> (# State# (RealWorld), Int# #)
par# :: a -> Int#
spark# :: a -> State# s -> (# State# s, a #)
seq# :: a -> State# s -> (# State# s, a #)
getSpark# :: State# s -> (# State# s, Int#, a #)

-- | Returns the number of sparks in the local spark pool.
numSparks# :: State# s -> (# State# s, Int# #)
parGlobal# :: a -> Int# -> Int# -> Int# -> Int# -> b -> Int#
parLocal# :: a -> Int# -> Int# -> Int# -> Int# -> b -> Int#
parAt# :: b -> a -> Int# -> Int# -> Int# -> Int# -> c -> Int#
parAtAbs# :: a -> Int# -> Int# -> Int# -> Int# -> Int# -> b -> Int#
parAtRel# :: a -> Int# -> Int# -> Int# -> Int# -> Int# -> b -> Int#
parAtForNow# :: b -> a -> Int# -> Int# -> Int# -> Int# -> c -> Int#
dataToTag# :: a -> Int#
tagToEnum# :: Int# -> a

-- | Primitive bytecode type.
data BCO#

-- | Convert an <tt>Addr#</tt> to a followable Any type.
addrToAny# :: Addr# -> (# a #)
mkApUpd0# :: BCO# -> (# a #)
newBCO# :: ByteArray# -> ByteArray# -> Array# a -> Int# -> ByteArray# -> State# s -> (# State# s, BCO# #)
unpackClosure# :: a -> (# Addr#, Array# b, ByteArray# #)
getApStackVal# :: a -> Int# -> (# Int#, b #)
getCCSOf# :: a -> State# s -> (# State# s, Addr# #)

-- | Returns the current <tt>CostCentreStack</tt> (value is <tt>NULL</tt>
--   if not profiling). Takes a dummy argument which can be used to avoid
--   the call to <tt>getCCCS#</tt> being floated out by the simplifier,
--   which would result in an uninformative stack ("CAF").
getCurrentCCS# :: a -> State# s -> (# State# s, Addr# #)

-- | Evaluates its first argument to head normal form, and then returns its
--   second argument as the result.
seq :: a -> b -> b

-- | The call <tt>(inline f)</tt> arranges that f is inlined, regardless of
--   its size. More precisely, the call <tt>(inline f)</tt> rewrites to the
--   right-hand side of <tt>f</tt>'s definition. This allows the programmer
--   to control inlining from a particular call site rather than the
--   definition site of the function (c.f. <tt>INLINE</tt> pragmas in
--   User's Guide, Section 7.10.3, "INLINE and NOINLINE pragmas").
--   
--   This inlining occurs regardless of the argument to the call or the
--   size of <tt>f</tt>'s definition; it is unconditional. The main caveat
--   is that <tt>f</tt>'s definition must be visible to the compiler. That
--   is, <tt>f</tt> must be <tt>let</tt>-bound in the current scope. If no
--   inlining takes place, the <tt>inline</tt> function expands to the
--   identity function in Phase zero; so its use imposes no overhead.
--   
--   It is good practice to mark the function with an INLINABLE pragma at
--   its definition, (a) so that GHC guarantees to expose its unfolding
--   regardless of size, and (b) so that you have control over exactly what
--   is inlined.
inline :: a -> a

-- | The <tt>lazy</tt> function restrains strictness analysis a little. The
--   call <tt>(lazy e)</tt> means the same as <tt>e</tt>, but <tt>lazy</tt>
--   has a magical property so far as strictness analysis is concerned: it
--   is lazy in its first argument, even though its semantics is strict.
--   After strictness analysis has run, calls to <tt>lazy</tt> are inlined
--   to be the identity function.
--   
--   This behaviour is occasionally useful when controlling evaluation
--   order. Notably, <tt>lazy</tt> is used in the library definition of
--   <tt>Control.Parallel.par</tt>:
--   
--   <pre>
--   par :: a -&gt; b -&gt; b
--   </pre>
--   
--   <pre>
--   par x y = case (par# x) of _ -&gt; lazy y
--   </pre>
--   
--   If <tt>lazy</tt> were not lazy, <tt>par</tt> would look strict in
--   <tt>y</tt> which would defeat the whole purpose of <tt>par</tt>.
--   
--   Like <tt>seq</tt>, the argument of <tt>lazy</tt> can have an unboxed
--   type.
lazy :: a -> a

-- | The type constructor <tt>Any</tt> is type to which you can unsafely
--   coerce any lifted type, and back.
--   
--   <ul>
--   <li>It is lifted, and hence represented by a pointer</li>
--   <li>It does not claim to be a <i>data</i> type, and that's important
--   for the code generator, because the code gen may <i>enter</i> a data
--   value but never enters a function value.</li>
--   </ul>
--   
--   It's also used to instantiate un-constrained type variables after type
--   checking. For example, <tt>length</tt> has type
--   
--   <pre>
--   length :: forall a. [a] -&gt; Int
--   </pre>
--   
--   and the list datacon for the empty list has type
--   
--   <pre>
--   [] :: forall a. [a]
--   </pre>
--   
--   In order to compose these two terms as <tt>length []</tt> a type
--   application is required, but there is no constraint on the choice. In
--   this situation GHC uses <tt>Any</tt>:
--   
--   <pre>
--   length (Any *) ([] (Any *))
--   </pre>
--   
--   Note that <tt>Any</tt> is kind polymorphic, and takes a kind
--   <tt>k</tt> as its first argument. The kind of <tt>Any</tt> is thus
--   <tt>forall k. k -&gt; k</tt>.
data Any k

-- | The kind <tt>AnyK</tt> is the kind level counterpart to <tt>Any</tt>.
--   In a kind polymorphic setting, a similar example to the length of the
--   empty list can be given at the type level:
--   
--   <tt>type family Length (l :: [k]) :: Nat</tt> <tt>type instance Length
--   [] = Zero</tt>
--   
--   When <tt>Length</tt> is applied to the empty (promoted) list it will
--   have the kind <tt>Length AnyK []</tt>.
--   
--   <tt>AnyK</tt> is currently not exported and cannot be used directly,
--   but you might see it in debug output from the compiler.
data AnyK

-- | The function <tt>unsafeCoerce#</tt> allows you to side-step the
--   typechecker entirely. That is, it allows you to coerce any type into
--   any other type. If you use this function, you had better get it right,
--   otherwise segmentation faults await. It is generally used when you
--   want to write a program that you know is well-typed, but where
--   Haskell's type system is not expressive enough to prove that it is
--   well typed.
--   
--   The following uses of <tt>unsafeCoerce#</tt> are supposed to work
--   (i.e. not lead to spurious compile-time or run-time crashes):
--   
--   <ul>
--   <li>Casting any lifted type to <tt>Any</tt></li>
--   <li>Casting <tt>Any</tt> back to the real type</li>
--   <li>Casting an unboxed type to another unboxed type of the same size
--   (but not coercions between floating-point and integral types)</li>
--   <li>Casting between two types that have the same runtime
--   representation. One case is when the two types differ only in
--   "phantom" type parameters, for example <tt>Ptr Int</tt> to <tt>Ptr
--   Float</tt>, or <tt>[Int]</tt> to <tt>[Float]</tt> when the list is
--   known to be empty. Also, a <tt>newtype</tt> of a type <tt>T</tt> has
--   the same representation at runtime as <tt>T</tt>.</li>
--   </ul>
--   
--   Other uses of <tt>unsafeCoerce#</tt> are undefined. In particular, you
--   should not use <tt>unsafeCoerce#</tt> to cast a T to an algebraic data
--   type D, unless T is also an algebraic data type. For example, do not
--   cast <tt>Int-&gt;Int</tt> to <tt>Bool</tt>, even if you later cast
--   that <tt>Bool</tt> back to <tt>Int-&gt;Int</tt> before applying it.
--   The reasons have to do with GHC's internal representation details (for
--   the congnoscenti, data values can be entered but function closures
--   cannot). If you want a safe type to cast things to, use <tt>Any</tt>,
--   which is not an algebraic data type.
unsafeCoerce# :: a -> b

-- | Emits an event via the RTS tracing framework. The contents of the
--   event is the zero-terminated byte string passed as the first argument.
--   The event will be emitted either to the .eventlog file, or to stderr,
--   depending on the runtime RTS flags.
traceEvent# :: Addr# -> State# s -> State# s


-- | GHC magic.
--   
--   Use GHC.Exts from the base package instead of importing this module
--   directly.
module GHC.Magic

-- | The call '(inline f)' reduces to <tt>f</tt>, but <a>inline</a> has a
--   BuiltInRule that tries to inline <tt>f</tt> (if it has an unfolding)
--   unconditionally The <tt>NOINLINE</tt> pragma arranges that inline only
--   gets inlined (and hence eliminated) late in compilation, after the
--   rule has had a good chance to fire.
inline :: a -> a
