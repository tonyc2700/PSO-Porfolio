<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>4.17. Running a compiled program</title><link rel="stylesheet" href="fptools.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"><link rel="home" href="index.html" title="The Parallel Haskell Compilation System User's Guide, Version 7.4.2"><link rel="up" href="using-ghc.html" title="Chapter 4. Using GHC"><link rel="prev" href="options-platform.html" title="4.16. Platform-specific Flags"><link rel="next" href="ext-core.html" title="4.18. Generating and compiling External Core Files"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">4.17. Running a compiled program</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="options-platform.html">Prev</a> </td><th width="60%" align="center">Chapter 4. Using GHC</th><td width="20%" align="right"> <a accesskey="n" href="ext-core.html">Next</a></td></tr></table><hr></div><div class="sect1" title="4.17. Running a compiled program"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="runtime-control"></a>4.17. Running a compiled program</h2></div></div></div><a class="indexterm" name="idp23619720"></a><a class="indexterm" name="idp23583560"></a><a class="indexterm" name="idp23583984"></a><p>To make an executable program, the GHC system compiles your
  code and then links it with a non-trivial runtime system (RTS),
  which handles storage management, thread scheduling, profiling, and
  so on.</p><p>
    The RTS has a lot of options to control its behaviour.  For
    example, you can change the context-switch interval, the default
    size of the heap, and enable heap profiling.  These options can be
    passed to the runtime system in a variety of different ways; the
    next section (<a class="xref" href="runtime-control.html#setting-rts-options" title="4.17.1. Setting RTS options">Section 4.17.1, &#8220;Setting RTS options&#8221;</a>) describes
    the various methods, and the following sections describe the RTS
    options themselves.
  </p><div class="sect2" title="4.17.1. Setting RTS options"><div class="titlepage"><div><div><h3 class="title"><a name="setting-rts-options"></a>4.17.1. Setting RTS options</h3></div></div></div><a class="indexterm" name="idp23620416"></a><p>
      There are four ways to set RTS options:

      </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
          on the command line between <code class="literal">+RTS ... -RTS</code>, when running the program
           (<a class="xref" href="runtime-control.html#rts-opts-cmdline" title="4.17.1.1. Setting RTS options on the command line">Section 4.17.1.1, &#8220;Setting RTS options on the command line&#8221;</a>)
          </p></li><li class="listitem"><p>at compile-time, using <code class="option">--with-rtsopts</code>
            (<a class="xref" href="runtime-control.html#rts-opts-compile-time" title="4.17.1.2. Setting RTS options at compile time">Section 4.17.1.2, &#8220;Setting RTS options at compile time&#8221;</a>)
          </p></li><li class="listitem"><p>with the environment variable <code class="envar">GHCRTS</code>
          (<a class="xref" href="runtime-control.html#rts-options-environment" title="4.17.1.3. Setting RTS options with the GHCRTS environment variable">Section 4.17.1.3, &#8220;Setting RTS options with the <code class="envar">GHCRTS</code>
          environment variable&#8221;</a>)
          </p></li><li class="listitem"><p>by overriding &#8220;hooks&#8221; in the runtime system
            (<a class="xref" href="runtime-control.html#rts-hooks" title="4.17.1.4. &#8220;Hooks&#8221; to change RTS behaviour">Section 4.17.1.4, &#8220;&#8220;Hooks&#8221; to change RTS behaviour&#8221;</a>)
          </p></li></ul></div><p>
    </p><div class="sect3" title="4.17.1.1. Setting RTS options on the command line"><div class="titlepage"><div><div><h4 class="title"><a name="rts-opts-cmdline"></a>4.17.1.1. Setting RTS options on the command line</h4></div></div></div><p>
        If you set the <code class="literal">-rtsopts</code> flag appropriately
        when linking (see <a class="xref" href="options-phases.html#options-linker" title="4.12.6. Options affecting linking">Section 4.12.6, &#8220;Options affecting linking&#8221;</a>), you can
        give RTS options on the command line when running your
        program.
      </p><p>
        When your Haskell program starts up, the RTS extracts
        command-line arguments bracketed between
        <code class="option">+RTS</code><a class="indexterm" name="idp23647648"></a>
        and
        <code class="option">-RTS</code><a class="indexterm" name="idp23648296"></a>
        as its own.  For example:
      </p><pre class="screen">
$ ghc prog.hs -rtsopts
[1 of 1] Compiling Main             ( prog.hs, prog.o )
Linking prog ...
$ ./prog -f +RTS -H32m -S -RTS -h foo bar
</pre><p>
          The RTS will
          snaffle <code class="option">-H32m</code> <code class="option">-S</code> for itself,
          and the remaining arguments <code class="literal">-f -h foo bar</code>
          will be available to your program if/when it calls
          <code class="function">System.Environment.getArgs</code>.
        </p><p>
          No <code class="option">-RTS</code> option is required if the
          runtime-system options extend to the end of the command line, as in
          this example:
        </p><pre class="screen">
% hls -ltr /usr/etc +RTS -A5m
</pre><p>
          If you absolutely positively want all the rest of the options
          in a command line to go to the program (and not the RTS), use a
          <code class="option">&#8211;&#8211;RTS</code><a class="indexterm" name="idp23652144"></a>.
        </p><p>
          As always, for RTS options that take
          <em class="replaceable"><code>size</code></em>s: If the last character of
          <em class="replaceable"><code>size</code></em> is a K or k, multiply by 1000; if an
          M or m, by 1,000,000; if a G or G, by 1,000,000,000.  (And any
          wraparound in the counters is <span class="emphasis"><em>your</em></span>
          fault!)
        </p><p>
          Giving a <code class="literal">+RTS -?</code>
          <a class="indexterm" name="idp23654400"></a> option
          will print out the RTS options actually available in your program
          (which vary, depending on how you compiled).</p><p>
          NOTE: since GHC is itself compiled by GHC, you can change RTS
          options in the compiler using the normal
          <code class="literal">+RTS ... -RTS</code>
          combination.  eg. to set the maximum heap
          size for a compilation to 128M, you would add
          <code class="literal">+RTS -M128m -RTS</code>
          to the command line.
        </p></div><div class="sect3" title="4.17.1.2. Setting RTS options at compile time"><div class="titlepage"><div><div><h4 class="title"><a name="rts-opts-compile-time"></a>4.17.1.2. Setting RTS options at compile time</h4></div></div></div><p>
          GHC lets you change the default RTS options for a program at
          compile time, using the <code class="literal">-with-rtsopts</code>
          flag (<a class="xref" href="options-phases.html#options-linker" title="4.12.6. Options affecting linking">Section 4.12.6, &#8220;Options affecting linking&#8221;</a>).  A common use for this is
          to give your program a default heap and/or stack size that is
          greater than the default.  For example, to set <code class="literal">-H128m
            -K64m</code>, link
          with <code class="literal">-with-rtsopts="-H128m -K64m"</code>.
        </p></div><div class="sect3" title="4.17.1.3. Setting RTS options with the GHCRTS environment variable"><div class="titlepage"><div><div><h4 class="title"><a name="rts-options-environment"></a>4.17.1.3. Setting RTS options with the <code class="envar">GHCRTS</code>
          environment variable</h4></div></div></div><a class="indexterm" name="idp23660000"></a><a class="indexterm" name="idp23660536"></a><p>
          If the <code class="literal">-rtsopts</code> flag is set to
          something other than <code class="literal">none</code> when linking,
          RTS options are also taken from the environment variable
          <code class="envar">GHCRTS</code><a class="indexterm" name="idp23662248"></a>.  For example, to set the maximum heap size
          to 2G for all GHC-compiled programs (using an
          <code class="literal">sh</code>-like shell):
        </p><pre class="screen">
   GHCRTS='-M2G'
   export GHCRTS
</pre><p>
          RTS options taken from the <code class="envar">GHCRTS</code> environment
          variable can be overridden by options given on the command
          line.
        </p><p>
          Tip: setting something like <code class="literal">GHCRTS=-M2G</code>
          in your environment is a handy way to avoid Haskell programs
          growing beyond the real memory in your machine, which is
          easy to do by accident and can cause the machine to slow to
          a crawl until the OS decides to kill the process (and you
          hope it kills the right one).
        </p></div><div class="sect3" title="4.17.1.4. &#8220;Hooks&#8221; to change RTS behaviour"><div class="titlepage"><div><div><h4 class="title"><a name="rts-hooks"></a>4.17.1.4. &#8220;Hooks&#8221; to change RTS behaviour</h4></div></div></div><a class="indexterm" name="idp23665824"></a><a class="indexterm" name="idp23666352"></a><a class="indexterm" name="idp23666760"></a><p>GHC lets you exercise rudimentary control over certain RTS
    settings for any given program, by compiling in a
    &#8220;hook&#8221; that is called by the run-time system.  The RTS
    contains stub definitions for these hooks, but by writing your
    own version and linking it on the GHC command line, you can
    override the defaults.</p><p>Owing to the vagaries of DLL linking, these hooks don't work
    under Windows when the program is built dynamically.</p><p>You can change the messages printed when the runtime
    system &#8220;blows up,&#8221; e.g., on stack overflow.  The hooks
    for these are as follows:</p><div class="variablelist"><dl><dt><span class="term">
          <code class="function">void OutOfHeapHook (unsigned long, unsigned long)</code>
          <a class="indexterm" name="idp23669160"></a>
        </span></dt><dd><p>The heap-overflow message.</p></dd><dt><span class="term">
          <code class="function">void StackOverflowHook (long int)</code>
          <a class="indexterm" name="idp23670944"></a>
        </span></dt><dd><p>The stack-overflow message.</p></dd><dt><span class="term">
          <code class="function">void MallocFailHook (long int)</code>
          <a class="indexterm" name="idp23672728"></a>
        </span></dt><dd><p>The message printed if <code class="function">malloc</code>
	  fails.</p></dd></dl></div></div></div><div class="sect2" title="4.17.2. Miscellaneous RTS options"><div class="titlepage"><div><div><h3 class="title"><a name="rts-options-misc"></a>4.17.2. Miscellaneous RTS options</h3></div></div></div><div class="variablelist"><dl><dt><span class="term"><code class="option">-V<em class="replaceable"><code>secs</code></em></code>
       <a class="indexterm" name="idp23675696"></a></span></dt><dd><p>Sets the interval that the RTS clock ticks at.  The
         runtime uses a single timer signal to count ticks; this timer
         signal is used to control the context switch timer (<a class="xref" href="using-concurrent.html" title="4.14. Using Concurrent Haskell">Section 4.14, &#8220;Using Concurrent Haskell&#8221;</a>) and the heap profiling
         timer <a class="xref" href="prof-heap.html#rts-options-heap-prof" title="5.4.1. RTS options for heap profiling">Section 5.4.1, &#8220;RTS options for heap profiling&#8221;</a>.  Also, the
         time profiler uses the RTS timer signal directly to record
         time profiling samples.</p><p>Normally, setting the <code class="option">-V</code> option
         directly is not necessary: the resolution of the RTS timer is
         adjusted automatically if a short interval is requested with
         the <code class="option">-C</code> or <code class="option">-i</code> options.
         However, setting <code class="option">-V</code> is required in order to
         increase the resolution of the time profiler.</p><p>Using a value of zero disables the RTS clock
         completely, and has the effect of disabling timers that
         depend on it: the context switch timer and the heap profiling
         timer.  Context switches will still happen, but
         deterministically and at a rate much faster than normal.
         Disabling the interval timer is useful for debugging, because
         it eliminates a source of non-determinism at runtime.</p></dd><dt><span class="term"><code class="option">--install-signal-handlers=<em class="replaceable"><code>yes|no</code></em></code>
       <a class="indexterm" name="idp23680400"></a></span></dt><dd><p>If yes (the default), the RTS installs signal handlers to catch
         things like ctrl-C. This option is primarily useful for when
         you are using the Haskell code as a DLL, and want to set your
         own signal handlers.</p><p>Note that even
           with <code class="option">--install-signal-handlers=no</code>, the RTS
           interval timer signal is still enabled.  The timer signal
           is either SIGVTALRM or SIGALRM, depending on the RTS
           configuration and OS capabilities.  To disable the timer
           signal, use the <code class="literal">-V0</code> RTS option (see
           above).
         </p></dd><dt><span class="term"><code class="option">-xm<em class="replaceable"><code>address</code></em></code>
       <a class="indexterm" name="idp23683400"></a></span></dt><dd><p>
           WARNING: this option is for working around memory
           allocation problems only.  Do not use unless GHCi fails
           with a message like &#8220;<code class="literal">failed to mmap() memory below 2Gb</code>&#8221;.  If you need to use this option to get GHCi working
           on your machine, please file a bug.
         </p><p>
           On 64-bit machines, the RTS needs to allocate memory in the
           low 2Gb of the address space.  Support for this across
           different operating systems is patchy, and sometimes fails.
           This option is there to give the RTS a hint about where it
           should be able to allocate memory in the low 2Gb of the
           address space.  For example, <code class="literal">+RTS -xm20000000
           -RTS</code> would hint that the RTS should allocate
           starting at the 0.5Gb mark.  The default is to use the OS's
           built-in support for allocating memory in the low 2Gb if
           available (e.g. <code class="literal">mmap</code>
           with <code class="literal">MAP_32BIT</code> on Linux), or
           otherwise <code class="literal">-xm40000000</code>.
         </p></dd></dl></div></div><div class="sect2" title="4.17.3. RTS options to control the garbage collector"><div class="titlepage"><div><div><h3 class="title"><a name="rts-options-gc"></a>4.17.3. RTS options to control the garbage collector</h3></div></div></div><a class="indexterm" name="idp23688128"></a><a class="indexterm" name="idp23688664"></a><p>There are several options to give you precise control over
    garbage collection.  Hopefully, you won't need any of these in
    normal operation, but there are several things that can be tweaked
    for maximum performance.</p><div class="variablelist"><dl><dt><span class="term">
          <code class="option">-A</code><em class="replaceable"><code>size</code></em>
          <a class="indexterm" name="idp23690392"></a>
          <a class="indexterm" name="idp23690992"></a>
        </span></dt><dd><p>[Default: 512k] Set the allocation area size
          used by the garbage collector.  The allocation area
          (actually generation 0 step 0) is fixed and is never resized
          (unless you use <code class="option">-H</code>, below).</p><p>Increasing the allocation area size may or may not
          give better performance (a bigger allocation area means
          worse cache behaviour but fewer garbage collections and less
          promotion).</p><p>With only 1 generation (<code class="option">-G1</code>) the
          <code class="option">-A</code> option specifies the minimum allocation
          area, since the actual size of the allocation area will be
          resized according to the amount of data in the heap (see
          <code class="option">-F</code>, below).</p></dd><dt><span class="term">
          <code class="option">-c</code>
          <a class="indexterm" name="idp23694240"></a>
          <a class="indexterm" name="idp23694840"></a>
          <a class="indexterm" name="idp23695400"></a>
        </span></dt><dd><p>Use a compacting algorithm for collecting the oldest
	  generation.  By default, the oldest generation is collected
	  using a copying algorithm; this option causes it to be
	  compacted in-place instead.  The compaction algorithm is
	  slower than the copying algorithm, but the savings in memory
	  use can be considerable.</p><p>For a given heap size (using the <code class="option">-H</code>
	  option), compaction can in fact reduce the GC cost by
	  allowing fewer GCs to be performed.  This is more likely
	  when the ratio of live data to heap size is high, say
	  &gt;30%.</p><p>NOTE: compaction doesn't currently work when a single
	  generation is requested using the <code class="option">-G1</code>
	  option.</p></dd><dt><span class="term"><code class="option">-c</code><em class="replaceable"><code>n</code></em></span></dt><dd><p>[Default: 30] Automatically enable
	  compacting collection when the live data exceeds
	  <em class="replaceable"><code>n</code></em>% of the maximum heap size
	  (see the <code class="option">-M</code> option).  Note that the maximum
	  heap size is unlimited by default, so this option has no
	  effect unless the maximum heap size is set with
	  <code class="option">-M</code><em class="replaceable"><code>size</code></em>. </p></dd><dt><span class="term">
          <code class="option">-F</code><em class="replaceable"><code>factor</code></em>
          <a class="indexterm" name="idp23700416"></a>
          <a class="indexterm" name="idp23701016"></a>
        </span></dt><dd><p>[Default: 2] This option controls the amount
          of memory reserved for the older generations (and in the
          case of a two space collector the size of the allocation
          area) as a factor of the amount of live data.  For example,
          if there was 2M of live data in the oldest generation when
          we last collected it, then by default we'll wait until it
          grows to 4M before collecting it again.</p><p>The default seems to work well here.  If you have
          plenty of memory, it is usually better to use
          <code class="option">-H</code><em class="replaceable"><code>size</code></em> than to
          increase
          <code class="option">-F</code><em class="replaceable"><code>factor</code></em>.</p><p>The <code class="option">-F</code> setting will be automatically
          reduced by the garbage collector when the maximum heap size
          (the <code class="option">-M</code><em class="replaceable"><code>size</code></em>
          setting) is approaching.</p></dd><dt><span class="term">
          <code class="option">-G</code><em class="replaceable"><code>generations</code></em>
          <a class="indexterm" name="idp23704944"></a>
          <a class="indexterm" name="idp23705544"></a>
        </span></dt><dd><p>[Default: 2] Set the number of generations
          used by the garbage collector.  The default of 2 seems to be
          good, but the garbage collector can support any number of
          generations.  Anything larger than about 4 is probably not a
          good idea unless your program runs for a
          <span class="emphasis"><em>long</em></span> time, because the oldest
          generation will hardly ever get collected.</p><p>Specifying 1 generation with <code class="option">+RTS -G1</code>
          gives you a simple 2-space collector, as you would expect.
          In a 2-space collector, the <code class="option">-A</code> option (see
          above) specifies the <span class="emphasis"><em>minimum</em></span> allocation
          area size, since the allocation area will grow with the
          amount of live data in the heap.  In a multi-generational
          collector the allocation area is a fixed size (unless you
          use the <code class="option">-H</code> option, see below).</p></dd><dt><span class="term">
          <code class="option">-qg[<span class="optional"><em class="replaceable"><code>gen</code></em></span>]</code>
          <a class="indexterm" name="idp23709232"></a>
        </span></dt><dd><p>[New in GHC 6.12.1] [Default: 0]
            Use parallel GC in
            generation <em class="replaceable"><code>gen</code></em> and higher.
            Omitting <em class="replaceable"><code>gen</code></em> turns off the
            parallel GC completely, reverting to sequential GC.</p><p>The default parallel GC settings are usually suitable
            for parallel programs (i.e. those
            using <code class="literal">par</code>, Strategies, or with multiple
            threads).  However, it is sometimes beneficial to enable
            the parallel GC for a single-threaded sequential program
            too, especially if the program has a large amount of heap
            data and GC is a significant fraction of runtime.  To use
            the parallel GC in a sequential program, enable the
            parallel runtime with a suitable <code class="literal">-N</code>
            option, and additionally it might be beneficial to
            restrict parallel GC to the old generation
            with <code class="literal">-qg1</code>.</p></dd><dt><span class="term">
          <code class="option">-qb[<span class="optional"><em class="replaceable"><code>gen</code></em></span>]</code>
          <a class="indexterm" name="idp23713520"></a>
        </span></dt><dd><p>
            [New in GHC 6.12.1] [Default: 1] Use
            load-balancing in the parallel GC in
            generation <em class="replaceable"><code>gen</code></em> and higher.
            Omitting <em class="replaceable"><code>gen</code></em> disables
            load-balancing entirely.</p><p>
            Load-balancing shares out the work of GC between the
            available cores.  This is a good idea when the heap is
            large and we need to parallelise the GC work, however it
            is also pessimal for the short young-generation
            collections in a parallel program, because it can harm
            locality by moving data from the cache of the CPU where is
            it being used to the cache of another CPU.  Hence the
            default is to do load-balancing only in the
            old-generation.  In fact, for a parallel program it is
            sometimes beneficial to disable load-balancing entirely
            with <code class="literal">-qb</code>.
          </p></dd><dt><span class="term">
          <code class="option">-H</code>[<span class="optional"><em class="replaceable"><code>size</code></em></span>]
          <a class="indexterm" name="idp23717112"></a>
          <a class="indexterm" name="idp23717712"></a>
        </span></dt><dd><p>[Default: 0] This option provides a
            &#8220;suggested heap size&#8221; for the garbage
            collector.  Think
            of <code class="option">-H<em class="replaceable"><code>size</code></em></code> as a
            variable <code class="option">-A</code> option.  It says: I want to
            use at least <em class="replaceable"><code>size</code></em> bytes, so use
            whatever is left over to increase the <code class="option">-A</code>
            value.</p><p>This option does not put
            a <span class="emphasis"><em>limit</em></span> on the heap size: the heap
            may grow beyond the given size as usual.</p><p>If <em class="replaceable"><code>size</code></em> is omitted, then
            the garbage collector will take the size of the heap at
            the previous GC as the <em class="replaceable"><code>size</code></em>.
            This has the effect of allowing for a
            larger <code class="option">-A</code> value but without increasing
            the overall memory requirements of the program.  It can be
            useful when the default small <code class="option">-A</code> value is
            suboptimal, as it can be in programs that create large
            amounts of long-lived data.</p></dd><dt><span class="term">
	  <code class="option">-I</code><em class="replaceable"><code>seconds</code></em>
	  <a class="indexterm" name="idp23722520"></a>
	  <a class="indexterm" name="idp23723248"></a>
	  </span></dt><dd><p>(default: 0.3) In the threaded and SMP versions of the RTS (see
	    <code class="option">-threaded</code>, <a class="xref" href="options-phases.html#options-linker" title="4.12.6. Options affecting linking">Section 4.12.6, &#8220;Options affecting linking&#8221;</a>), a
	    major GC is automatically performed if the runtime has been idle
	    (no Haskell computation has been running) for a period of time.
	    The amount of idle time which must pass before a GC is performed is
	    set by the <code class="option">-I</code><em class="replaceable"><code>seconds</code></em>
	    option.  Specifying <code class="option">-I0</code> disables the idle GC.</p><p>For an interactive application, it is probably a good idea to
	    use the idle GC, because this will allow finalizers to run and
	    deadlocked threads to be detected in the idle time when no Haskell
	    computation is happening.  Also, it will mean that a GC is less
	    likely to happen when the application is busy, and so
	    responsiveness may be improved.   However, if the amount of live data in
	    the heap is particularly large, then the idle GC can cause a
	    significant delay, and too small an interval could adversely affect
	    interactive responsiveness.</p><p>This is an experimental feature, please let us know if it
	    causes problems and/or could benefit from further tuning.</p></dd><dt><span class="term">
         <code class="option">-ki</code><em class="replaceable"><code>size</code></em>
         <a class="indexterm" name="idp23727384"></a>
         <a class="indexterm" name="idp23727984"></a>
        </span></dt><dd><p>
            [Default: 1k] Set the initial stack size for new
            threads.  (Note: this flag used to be
            simply <code class="option">-k</code>, but was renamed
            to <code class="option">-ki</code> in GHC 7.2.1.  The old name is
            still accepted for backwards compatibility, but that may
            be removed in a future version).
          </p><p>
            Thread stacks (including the main thread's stack) live on
            the heap.  As the stack grows, new stack chunks are added
            as required; if the stack shrinks again, these extra stack
            chunks are reclaimed by the garbage collector.  The
            default initial stack size is deliberately small, in order
            to keep the time and space overhead for thread creation to
            a minimum, and to make it practical to spawn threads for
            even tiny pieces of work.
          </p></dd><dt><span class="term">
          <code class="option">-kc</code><em class="replaceable"><code>size</code></em>
          <a class="indexterm" name="idp23730992"></a>
          <a class="indexterm" name="idp23731592"></a>
        </span></dt><dd><p>
            [Default: 32k] Set the size of &#8220;stack
            chunks&#8221;.  When a thread's current stack overflows, a
            new stack chunk is created and added to the thread's
            stack, until the limit set by <code class="option">-K</code> is
            reached.
          </p><p>
            The advantage of smaller stack chunks is that the garbage
            collector can avoid traversing stack chunks if they are
            known to be unmodified since the last collection, so
            reducing the chunk size means that the garbage collector
            can identify more stack as unmodified, and the GC overhead
            might be reduced.  On the other hand, making stack chunks
            too small adds some overhead as there will be more
            overflow/underflow between chunks.  The default setting of
            32k appears to be a reasonable compromise in most cases.
          </p></dd><dt><span class="term">
          <code class="option">-kb</code><em class="replaceable"><code>size</code></em>
          <a class="indexterm" name="idp23734560"></a>
          <a class="indexterm" name="idp23735176"></a>
        </span></dt><dd><p>
            [Default: 1k] Sets the stack chunk buffer size.
            When a stack chunk overflows and a new stack chunk is
            created, some of the data from the previous stack chunk is
            moved into the new chunk, to avoid an immediate underflow
            and repeated overflow/underflow at the boundary.  The
            amount of stack moved is set by the <code class="option">-kb</code>
            option.
          </p><p>
            Note that to avoid wasting space, this value should
            typically be less than 10% of the size of a stack
            chunk (<code class="option">-kc</code>), because in a chain of stack
            chunks, each chunk will have a gap of unused space of this
            size.
          </p></dd><dt><span class="term">
          <code class="option">-K</code><em class="replaceable"><code>size</code></em>
          <a class="indexterm" name="idp23738208"></a>
          <a class="indexterm" name="idp23738776"></a>
        </span></dt><dd><p>[Default: 8M] Set the maximum stack size for
          an individual thread to <em class="replaceable"><code>size</code></em>
          bytes.  If the thread attempts to exceed this limit, it will
            be send the <code class="literal">StackOverflow</code> exception.
          </p><p>
            This option is there mainly to stop the program eating up
            all the available memory in the machine if it gets into an
            infinite loop.
          </p></dd><dt><span class="term">
          <code class="option">-m</code><em class="replaceable"><code>n</code></em>
          <a class="indexterm" name="idp23741424"></a>
          <a class="indexterm" name="idp23742024"></a>
        </span></dt><dd><p>Minimum % <em class="replaceable"><code>n</code></em> of heap
          which must be available for allocation.  The default is
          3%.</p></dd><dt><span class="term">
          <code class="option">-M</code><em class="replaceable"><code>size</code></em>
          <a class="indexterm" name="idp23743848"></a>
          <a class="indexterm" name="idp23744448"></a>
        </span></dt><dd><p>[Default: unlimited] Set the maximum heap size to
          <em class="replaceable"><code>size</code></em> bytes.  The heap normally
          grows and shrinks according to the memory requirements of
          the program.  The only reason for having this option is to
          stop the heap growing without bound and filling up all the
          available swap space, which at the least will result in the
          program being summarily killed by the operating
          system.</p><p>The maximum heap size also affects other garbage
	  collection parameters: when the amount of live data in the
	  heap exceeds a certain fraction of the maximum heap size,
	  compacting collection will be automatically enabled for the
	  oldest generation, and the <code class="option">-F</code> parameter
	  will be reduced in order to avoid exceeding the maximum heap
	  size.</p></dd><dt><span class="term">
          <code class="option">-T</code>
          <a class="indexterm" name="idp23747256"></a>
        , </span><span class="term">
          <code class="option">-t</code>[<span class="optional"><em class="replaceable"><code>file</code></em></span>]
          <a class="indexterm" name="idp23748448"></a>
        , </span><span class="term">
          <code class="option">-s</code>[<span class="optional"><em class="replaceable"><code>file</code></em></span>]
          <a class="indexterm" name="idp23749640"></a>
        , </span><span class="term">
          <code class="option">-S</code>[<span class="optional"><em class="replaceable"><code>file</code></em></span>]
          <a class="indexterm" name="idp23750832"></a>
        , </span><span class="term">
          <code class="option">--machine-readable</code>
          <a class="indexterm" name="idp23751816"></a>
        </span></dt><dd><p>These options produce runtime-system statistics, such
	  as the amount of time spent executing the program and in the
	  garbage collector, the amount of memory allocated, the
	  maximum size of the heap, and so on.  The three
	  variants give different levels of detail:
          <code class="option">-T</code> collects the data but produces no output
	  <code class="option">-t</code> produces a single line of output in the
	  same format as GHC's <code class="option">-Rghc-timing</code> option,
	  <code class="option">-s</code> produces a more detailed summary at the
	  end of the program, and <code class="option">-S</code> additionally
	  produces information about each and every garbage
	  collection.</p><p>The output is placed in
          <em class="replaceable"><code>file</code></em>.  If
          <em class="replaceable"><code>file</code></em> is omitted, then the output
          is sent to <code class="constant">stderr</code>.</p><p>
        If you use the <code class="literal">-T</code> flag then, you should
        access the statistics using
        <a class="ulink" href="../libraries/base-4.5.1.0/GHC-Stats.html" target="_top">GHC.Stats</a>.
    </p><p>
        If you use the <code class="literal">-t</code> flag then, when your
        program finishes, you will see something like this:
    </p><pre class="programlisting">
&lt;&lt;ghc: 36169392 bytes, 69 GCs, 603392/1065272 avg/max bytes residency (2 samples), 3M in use, 0.00 INIT (0.00 elapsed), 0.02 MUT (0.02 elapsed), 0.07 GC (0.07 elapsed) :ghc&gt;&gt;
</pre><p>
        This tells you:
    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
          The total number of bytes allocated by the program over the
          whole run.
        </p></li><li class="listitem"><p>
          The total number of garbage collections performed.
        </p></li><li class="listitem"><p>
          The average and maximum "residency", which is the amount of
          live data in bytes.  The runtime can only determine the
          amount of live data during a major GC, which is why the
          number of samples corresponds to the number of major GCs
          (and is usually relatively small).  To get a better picture
          of the heap profile of your program, use
          the <code class="option">-hT</code> RTS option
          (<a class="xref" href="runtime-control.html#rts-profiling" title="4.17.5. RTS options for profiling">Section 4.17.5, &#8220;RTS options for profiling&#8221;</a>).
        </p></li><li class="listitem"><p>
          The peak memory the RTS has allocated from the OS.
        </p></li><li class="listitem"><p>
          The amount of CPU time and elapsed wall clock time while
          initialising the runtime system (INIT), running the program
          itself (MUT, the mutator), and garbage collecting (GC).
        </p></li></ul></div><p>
        You can also get this in a more future-proof, machine readable
        format, with <code class="literal">-t --machine-readable</code>:
    </p><pre class="programlisting">
 [("bytes allocated", "36169392")
 ,("num_GCs", "69")
 ,("average_bytes_used", "603392")
 ,("max_bytes_used", "1065272")
 ,("num_byte_usage_samples", "2")
 ,("peak_megabytes_allocated", "3")
 ,("init_cpu_seconds", "0.00")
 ,("init_wall_seconds", "0.00")
 ,("mutator_cpu_seconds", "0.02")
 ,("mutator_wall_seconds", "0.02")
 ,("GC_cpu_seconds", "0.07")
 ,("GC_wall_seconds", "0.07")
 ]
</pre><p>
        If you use the <code class="literal">-s</code> flag then, when your
        program finishes, you will see something like this (the exact
        details will vary depending on what sort of RTS you have, e.g.
        you will only see profiling data if your RTS is compiled for
        profiling):
    </p><pre class="programlisting">
      36,169,392 bytes allocated in the heap
       4,057,632 bytes copied during GC
       1,065,272 bytes maximum residency (2 sample(s))
          54,312 bytes maximum slop
               3 MB total memory in use (0 MB lost due to fragmentation)

  Generation 0:    67 collections,     0 parallel,  0.04s,  0.03s elapsed
  Generation 1:     2 collections,     0 parallel,  0.03s,  0.04s elapsed

  SPARKS: 359207 (557 converted, 149591 pruned)

  INIT  time    0.00s  (  0.00s elapsed)
  MUT   time    0.01s  (  0.02s elapsed)
  GC    time    0.07s  (  0.07s elapsed)
  EXIT  time    0.00s  (  0.00s elapsed)
  Total time    0.08s  (  0.09s elapsed)

  %GC time      89.5%  (75.3% elapsed)

  Alloc rate    4,520,608,923 bytes per MUT second

  Productivity  10.5% of total user, 9.1% of total elapsed
</pre><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
        The "bytes allocated in the heap" is the total bytes allocated
        by the program over the whole run.
        </p></li><li class="listitem"><p>
        GHC uses a copying garbage collector by default. "bytes copied
        during GC" tells you how many bytes it had to copy during
        garbage collection.
        </p></li><li class="listitem"><p>
        The maximum space actually used by your program is the
        "bytes maximum residency" figure. This is only checked during
        major garbage collections, so it is only an approximation;
        the number of samples tells you how many times it is checked.
        </p></li><li class="listitem"><p>
        The "bytes maximum slop" tells you the most space that is ever
        wasted due to the way GHC allocates memory in blocks.  Slop is
        memory at the end of a block that was wasted.  There's no way
        to control this; we just like to see how much memory is being
        lost this way.
        </p></li><li class="listitem"><p>
        The "total memory in use" tells you the peak memory the RTS has
        allocated from the OS.
        </p></li><li class="listitem"><p>
        Next there is information about the garbage collections done.
        For each generation it says how many garbage collections were
        done, how many of those collections were done in parallel,
        the total CPU time used for garbage collecting that generation,
        and the total wall clock time elapsed while garbage collecting
        that generation.
        </p></li><li class="listitem"><p>The <code class="literal">SPARKS</code> statistic refers to the
          use of <code class="literal">Control.Parallel.par</code> and related
          functionality in the program.  Each spark represents a call
          to <code class="literal">par</code>; a spark is "converted" when it is
          executed in parallel; and a spark is "pruned" when it is
          found to be already evaluated and is discarded from the pool
          by the garbage collector.  Any remaining sparks are
          discarded at the end of execution, so "converted" plus
          "pruned" does not necessarily add up to the total.</p></li><li class="listitem"><p>
        Next there is the CPU time and wall clock time elapsed broken
        down by what the runtime system was doing at the time.
        INIT is the runtime system initialisation.
        MUT is the mutator time, i.e. the time spent actually running
        your code.
        GC is the time spent doing garbage collection.
        RP is the time spent doing retainer profiling.
        PROF is the time spent doing other profiling.
        EXIT is the runtime system shutdown time.
        And finally, Total is, of course, the total.
        </p><p>
        %GC time tells you what percentage GC is of Total.
        "Alloc rate" tells you the "bytes allocated in the heap" divided
        by the MUT CPU time.
        "Productivity" tells you what percentage of the Total CPU and wall
        clock elapsed times are spent in the mutator (MUT).
        </p></li></ul></div><p>
        The <code class="literal">-S</code> flag, as well as giving the same
        output as the <code class="literal">-s</code> flag, prints information
        about each GC as it happens:
    </p><pre class="programlisting">
    Alloc    Copied     Live    GC    GC     TOT     TOT  Page Flts
    bytes     bytes     bytes  user  elap    user    elap
   528496     47728    141512  0.01  0.02    0.02    0.02    0    0  (Gen:  1)
[...]
   524944    175944   1726384  0.00  0.00    0.08    0.11    0    0  (Gen:  0)
</pre><p>
        For each garbage collection, we print:
    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
          How many bytes we allocated this garbage collection.
        </p></li><li class="listitem"><p>
          How many bytes we copied this garbage collection.
        </p></li><li class="listitem"><p>
          How many bytes are currently live.
        </p></li><li class="listitem"><p>
          How long this garbage collection took (CPU time and elapsed
          wall clock time).
        </p></li><li class="listitem"><p>
          How long the program has been running (CPU time and elapsed
          wall clock time).
        </p></li><li class="listitem"><p>
          How many page faults occurred this garbage collection.
        </p></li><li class="listitem"><p>
          How many page faults occurred since the end of the last garbage
          collection.
        </p></li><li class="listitem"><p>
          Which generation is being garbage collected.
        </p></li></ul></div></dd></dl></div></div><div class="sect2" title="4.17.4. RTS options for concurrency and parallelism"><div class="titlepage"><div><div><h3 class="title"><a name="idp23778488"></a>4.17.4. RTS options for concurrency and parallelism</h3></div></div></div><p>The RTS options related to concurrency are described in
      <a class="xref" href="using-concurrent.html" title="4.14. Using Concurrent Haskell">Section 4.14, &#8220;Using Concurrent Haskell&#8221;</a>, and those for parallelism in
      <a class="xref" href="using-smp.html#parallel-options" title="4.15.2. RTS options for SMP parallelism">Section 4.15.2, &#8220;RTS options for SMP parallelism&#8221;</a>.</p></div><div class="sect2" title="4.17.5. RTS options for profiling"><div class="titlepage"><div><div><h3 class="title"><a name="rts-profiling"></a>4.17.5. RTS options for profiling</h3></div></div></div><p>Most profiling runtime options are only available when you
    compile your program for profiling (see
    <a class="xref" href="prof-compiler-options.html" title="5.2. Compiler options for profiling">Section 5.2, &#8220;Compiler options for profiling&#8221;</a>, and
    <a class="xref" href="prof-heap.html#rts-options-heap-prof" title="5.4.1. RTS options for heap profiling">Section 5.4.1, &#8220;RTS options for heap profiling&#8221;</a> for the runtime options).
    However, there is one profiling option that is available
    for ordinary non-profiled executables:</p><div class="variablelist"><dl><dt><span class="term">
          <code class="option">-hT</code>
          <a class="indexterm" name="idp23782344"></a>
        </span></dt><dd><p>(can be shortened to <code class="option">-h</code>.) Generates a basic heap profile, in the
            file <code class="literal"><em class="replaceable"><code>prog</code></em>.hp</code>.
            To produce the heap profile graph,
            use <span class="command"><strong>hp2ps</strong></span> (see <a class="xref" href="hp2ps.html" title="5.5. hp2ps&#8211;&#8211;heap profile to PostScript">Section 5.5, &#8220;<span class="command"><strong>hp2ps</strong></span>&#8211;&#8211;heap profile to PostScript&#8221;</a>).  The basic heap profile is broken down by data
            constructor, with other types of closures (functions, thunks,
            etc.) grouped into broad categories
            (e.g. <code class="literal">FUN</code>, <code class="literal">THUNK</code>).  To
            get a more detailed profile, use the full profiling
            support (<a class="xref" href="profiling.html" title="Chapter 5. Profiling">Chapter 5, <i>Profiling</i></a>).</p></dd></dl></div></div><div class="sect2" title="4.17.6. Tracing"><div class="titlepage"><div><div><h3 class="title"><a name="rts-eventlog"></a>4.17.6. Tracing</h3></div></div></div><a class="indexterm" name="idp23787096"></a><a class="indexterm" name="idp23787504"></a><a class="indexterm" name="idp23787912"></a><p>
      When the program is linked with the <code class="option">-eventlog</code>
      option (<a class="xref" href="options-phases.html#options-linker" title="4.12.6. Options affecting linking">Section 4.12.6, &#8220;Options affecting linking&#8221;</a>), runtime events can
      be logged in two ways:
    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
          In binary format to a file for later analysis by a
          variety of tools.  One such tool
          is <a class="ulink" href="http://www.haskell.org/haskellwiki/ThreadScope" target="_top">ThreadScope</a><a class="indexterm" name="idp23790032"></a>,
          which interprets the event log to produce a visual parallel
          execution profile of the program.
        </p></li><li class="listitem"><p>
          As text to standard output, for debugging purposes.
        </p></li></ul></div><div class="variablelist"><dl><dt><span class="term">
          <code class="option">-l[<span class="optional"><em class="replaceable"><code>flags</code></em></span>]</code>
          <a class="indexterm" name="idp23792016"></a>
        </span></dt><dd><p>
            Log events in binary format to the
            file <code class="filename"><em class="replaceable"><code>program</code></em>.eventlog</code>.
            Without any <em class="replaceable"><code>flags</code></em> specified, this logs a
            default set of events, suitable for use with tools like ThreadScope.
          </p><p>
            For some special use cases you may want more control over which
            events are included. The <em class="replaceable"><code>flags</code></em> is a
            sequence of zero or more characters indicating which classes of
            events to log. Currently these the classes of events that can
            be enabled/disabled:
            </p><table border="0" summary="Simple list" class="simplelist"><tr><td>
                <code class="option">s</code> &#8212; scheduler events, including Haskell
                thread creation and start/stop events. Enabled by default.
              </td></tr><tr><td>
                <code class="option">g</code> &#8212; GC events, including GC start/stop.
                Enabled by default.
              </td></tr><tr><td>
                <code class="option">p</code> &#8212; parallel sparks (sampled).
                Enabled by default.
              </td></tr><tr><td>
                <code class="option">f</code> &#8212; parallel sparks (fully accurate).
                Disabled by default.
              </td></tr><tr><td>
                <code class="option">u</code> &#8212; user events. These are events emitted
                from Haskell code using functions such as 
                <code class="literal">Debug.Trace.traceEvent</code>. Enabled by default.
              </td></tr></table><p>
          </p><p>            
            You can disable specific classes, or enable/disable all classes at
            once:
            </p><table border="0" summary="Simple list" class="simplelist"><tr><td>
                <code class="option">a</code> &#8212; enable all event classes listed above
              </td></tr><tr><td>
                <code class="option">-<em class="replaceable"><code>x</code></em></code> &#8212; disable the
                given class of events, for any event class listed above or
                <code class="option">-a</code> for all classes
              </td></tr></table><p>
            For example, <code class="option">-l-ag</code> would disable all event classes
            (<code class="option">-a</code>) except for GC events (<code class="option">g</code>).
          </p><p>            
            For spark events there are two modes: sampled and fully accurate.
            There are various events in the life cycle of each spark, usually
            just creating and running, but there are some more exceptional
            possibilities. In the sampled mode the number of occurrences of each
            kind of spark event is sampled at frequent intervals. In the fully
            accurate mode every spark event is logged individually. The latter
            has a higher runtime overhead and is not enabled by default.
          </p><p>
            The format of the log file is described by the header
            <code class="filename">EventLogFormat.h</code> that comes with
            GHC, and it can be parsed in Haskell using
            the <a class="ulink" href="http://hackage.haskell.org/package/ghc-events" target="_top">ghc-events</a>
            library.  To dump the contents of
            a <code class="literal">.eventlog</code> file as text, use the
            tool <code class="literal">ghc-events show</code> that comes with
            the <a class="ulink" href="http://hackage.haskell.org/package/ghc-events" target="_top">ghc-events</a>
            package.
          </p></dd><dt><span class="term">
          <code class="option">-v</code>[<span class="optional"><em class="replaceable"><code>flags</code></em></span>]
          <a class="indexterm" name="idp23805336"></a>
        </span></dt><dd><p>
            Log events as text to standard output, instead of to
            the <code class="literal">.eventlog</code> file.
            The <em class="replaceable"><code>flags</code></em> are the same as
            for <code class="option">-l</code>, with the additional
            option <code class="literal">t</code> which indicates that the
            each event printed should be preceded by a timestamp value
            (in the binary <code class="literal">.eventlog</code> file, all
            events are automatically associated with a timestamp).
          </p></dd></dl></div><p>
      The debugging
      options <code class="option">-D<em class="replaceable"><code>x</code></em></code> also
      generate events which are logged using the tracing framework.
      By default those events are dumped as text to stdout
      (<code class="option">-D<em class="replaceable"><code>x</code></em></code>
      implies <code class="option">-v</code>), but they may instead be stored in
      the binary eventlog file by using the <code class="option">-l</code>
      option.
    </p></div><div class="sect2" title="4.17.7. RTS options for hackers, debuggers, and over-interested souls"><div class="titlepage"><div><div><h3 class="title"><a name="rts-options-debugging"></a>4.17.7. RTS options for hackers, debuggers, and over-interested
    souls</h3></div></div></div><a class="indexterm" name="idp23810664"></a><p>These RTS options might be used (a) to avoid a GHC bug,
    (b) to see &#8220;what's really happening&#8221;, or
    (c) because you feel like it.  Not recommended for everyday
    use!</p><div class="variablelist"><dl><dt><span class="term">
          <code class="option">-B</code>
          <a class="indexterm" name="idp23812136"></a>
        </span></dt><dd><p>Sound the bell at the start of each (major) garbage
	  collection.</p><p>Oddly enough, people really do use this option!  Our
          pal in Durham (England), Paul Callaghan, writes: &#8220;Some
          people here use it for a variety of
          purposes&#8212;honestly!&#8212;e.g., confirmation that the
          code/machine is doing something, infinite loop detection,
          gauging cost of recently added code. Certain people can even
          tell what stage [the program] is in by the beep
          pattern. But the major use is for annoying others in the
          same office&#8230;&#8221;</p></dd><dt><span class="term">
          <code class="option">-D</code><em class="replaceable"><code>x</code></em>
          <a class="indexterm" name="idp23814672"></a>
        </span></dt><dd><p>
            An RTS debugging flag; only available if the program was
	    linked with the <code class="option">-debug</code> option.  Various
	    values of <em class="replaceable"><code>x</code></em> are provided to
	    enable debug messages and additional runtime sanity checks
	    in different subsystems in the RTS, for
	    example <code class="literal">+RTS -Ds -RTS</code> enables debug
	    messages from the scheduler.
	    Use <code class="literal">+RTS -?</code> to find out which
	    debug flags are supported.
          </p><p>
            Debug messages will be sent to the binary event log file
            instead of stdout if the <code class="option">-l</code> option is
            added.  This might be useful for reducing the overhead of
            debug tracing.
          </p></dd><dt><span class="term">
          <code class="option">-r</code><em class="replaceable"><code>file</code></em>
          <a class="indexterm" name="idp23818336"></a>
          <a class="indexterm" name="idp23818936"></a>
          <a class="indexterm" name="idp23819328"></a>
        </span></dt><dd><p>Produce &#8220;ticky-ticky&#8221; statistics at the
          end of the program run (only available if the program was
          linked with <code class="option">-debug</code>).
          The <em class="replaceable"><code>file</code></em> business works just like
          on the <code class="option">-S</code> RTS option, above.</p><p>For more information on ticky-ticky profiling, see
          <a class="xref" href="ticky-ticky.html" title="5.8. Using &#8220;ticky-ticky&#8221; profiling (for implementors)">Section 5.8, &#8220;Using &#8220;ticky-ticky&#8221; profiling (for implementors)&#8221;</a>.</p></dd><dt><span class="term">
          <code class="option">-xc</code>
          <a class="indexterm" name="idp23822376"></a>
        </span></dt><dd><p>(Only available when the program is compiled for
	  profiling.)  When an exception is raised in the program,
          this option causes a stack trace to be
          dumped to <code class="literal">stderr</code>.</p><p>This can be particularly useful for debugging: if your
	  program is complaining about a <code class="literal">head []</code>
	  error and you haven't got a clue which bit of code is
	  causing it, compiling with <code class="literal">-prof
          -fprof-auto</code> and running with <code class="literal">+RTS -xc
	  -RTS</code> will tell you exactly the call stack at the
	  point the error was raised.</p><p>The output contains one report for each exception
          raised in the program (the program might raise and catch
          several exceptions during its execution), where each report
          looks something like this:
          </p><pre class="screen">
*** Exception raised (reporting due to +RTS -xc), stack trace:
  GHC.List.CAF
  --&gt; evaluated by: Main.polynomial.table_search,
  called from Main.polynomial.theta_index,
  called from Main.polynomial,
  called from Main.zonal_pressure,
  called from Main.make_pressure.p,
  called from Main.make_pressure,
  called from Main.compute_initial_state.p,
  called from Main.compute_initial_state,
  called from Main.CAF
  ...
</pre><p>The stack trace may often begin with something
          uninformative like <code class="literal">GHC.List.CAF</code>; this is
          an artifact of GHC's optimiser, which lifts out exceptions
          to the top-level where the profiling system assigns them to
          the cost centre "CAF".  However, <code class="literal">+RTS -xc</code>
          doesn't just print the current stack, it looks deeper and
          reports the stack at the time the CAF was evaluated, and it
          may report further stacks until a non-CAF stack is found.  In
          the example above, the next stack (after <code class="literal">--&gt;
          evaluated by</code>) contains plenty of information about
          what the program was doing when it evaluated <code class="literal">head
          []</code>.</p><p>Implementation details aside, the function names in
          the stack should hopefully give you enough clues to track
          down the bug.</p><p>
            See also the function <code class="literal">traceStack</code> in the
            module <code class="literal">Debug.Trace</code> for another way to
            view call stacks.
          </p></dd><dt><span class="term">
          <code class="option">-Z</code>
          <a class="indexterm" name="idp23830824"></a>
        </span></dt><dd><p>Turn <span class="emphasis"><em>off</em></span> &#8220;update-frame
          squeezing&#8221; at garbage-collection time.  (There's no
          particularly good reason to turn it off, except to ensure
          the accuracy of certain data collected regarding thunk entry
          counts.)</p></dd></dl></div></div><div class="sect2" title="4.17.8. Getting information about the RTS"><div class="titlepage"><div><div><h3 class="title"><a name="ghc-info"></a>4.17.8. Getting information about the RTS</h3></div></div></div><a class="indexterm" name="idp23833080"></a><p>It is possible to ask the RTS to give some information about
    itself. To do this, use the <code class="option">--info</code> flag, e.g.</p><pre class="screen">
$ ./a.out +RTS --info
 [("GHC RTS", "YES")
 ,("GHC version", "6.7")
 ,("RTS way", "rts_p")
 ,("Host platform", "x86_64-unknown-linux")
 ,("Host architecture", "x86_64")
 ,("Host OS", "linux")
 ,("Host vendor", "unknown")
 ,("Build platform", "x86_64-unknown-linux")
 ,("Build architecture", "x86_64")
 ,("Build OS", "linux")
 ,("Build vendor", "unknown")
 ,("Target platform", "x86_64-unknown-linux")
 ,("Target architecture", "x86_64")
 ,("Target OS", "linux")
 ,("Target vendor", "unknown")
 ,("Word size", "64")
 ,("Compiler unregisterised", "NO")
 ,("Tables next to code", "YES")
 ]
</pre><p>The information is formatted such that it can be read as a
    of type <code class="literal">[(String, String)]</code>. Currently the following
    fields are present:</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">GHC RTS</code></span></dt><dd><p>Is this program linked against the GHC RTS? (always
          "YES").</p></dd><dt><span class="term"><code class="literal">GHC version</code></span></dt><dd><p>The version of GHC used to compile this program.</p></dd><dt><span class="term"><code class="literal">RTS way</code></span></dt><dd><p>The variant (&#8220;way&#8221;) of the runtime. The
          most common values are <code class="literal">rts</code> (vanilla),
          <code class="literal">rts_thr</code> (threaded runtime, i.e. linked using the
          <code class="literal">-threaded</code> option) and <code class="literal">rts_p</code>
          (profiling runtime, i.e. linked using the <code class="literal">-prof</code>
          option). Other variants include <code class="literal">debug</code>
          (linked using <code class="literal">-debug</code>),
          <code class="literal">t</code> (ticky-ticky profiling) and
          <code class="literal">dyn</code> (the RTS is
          linked in dynamically, i.e. a shared library, rather than statically
          linked into the executable itself). These can be combined,
          e.g. you might have <code class="literal">rts_thr_debug_p</code>.</p></dd><dt><span class="term">
            <code class="literal">Target platform</code>,
            <code class="literal">Target architecture</code>,
            <code class="literal">Target OS</code>,
            <code class="literal">Target vendor</code>
        </span></dt><dd><p>These are the platform the program is compiled to run on.</p></dd><dt><span class="term">
            <code class="literal">Build platform</code>,
            <code class="literal">Build architecture</code>,
            <code class="literal">Build OS</code>,
            <code class="literal">Build vendor</code>
        </span></dt><dd><p>These are the platform where the program was built
          on. (That is, the target platform of GHC itself.) Ordinarily
          this is identical to the target platform. (It could potentially
          be different if cross-compiling.)</p></dd><dt><span class="term">
            <code class="literal">Host platform</code>,
            <code class="literal">Host architecture</code>
            <code class="literal">Host OS</code>
            <code class="literal">Host vendor</code>
        </span></dt><dd><p>These are the platform where GHC itself was compiled.
          Again, this would normally be identical to the build and
          target platforms.</p></dd><dt><span class="term"><code class="literal">Word size</code></span></dt><dd><p>Either <code class="literal">"32"</code> or <code class="literal">"64"</code>,
          reflecting the word size of the target platform.</p></dd><dt><span class="term"><code class="literal">Compiler unregistered</code></span></dt><dd><p>Was this program compiled with an
          <a class="link" href="code-generators.html#unreg" title="4.11.4. Unregisterised compilation">&#8220;unregistered&#8221;</a>
          version of GHC? (I.e., a version of GHC that has no platform-specific
          optimisations compiled in, usually because this is a currently
          unsupported platform.) This value will usually be no, unless you're
          using an experimental build of GHC.</p></dd><dt><span class="term"><code class="literal">Tables next to code</code></span></dt><dd><p>Putting info tables directly next to entry code is a useful
          performance optimisation that is not available on all platforms.
          This field tells you whether the program has been compiled with
          this optimisation. (Usually yes, except on unusual platforms.)</p></dd></dl></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="options-platform.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="using-ghc.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ext-core.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">4.16. Platform-specific Flags </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 4.18. Generating and compiling External Core Files</td></tr></table></div></body></html>
