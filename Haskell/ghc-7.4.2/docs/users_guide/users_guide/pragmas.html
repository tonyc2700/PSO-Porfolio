<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>7.16. Pragmas</title><link rel="stylesheet" href="fptools.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"><link rel="home" href="index.html" title="The Parallel Haskell Compilation System User's Guide, Version 7.4.2"><link rel="up" href="ghc-language-features.html" title="Chapter 7. GHC Language Features"><link rel="prev" href="assertions.html" title="7.15. Assertions"><link rel="next" href="rewrite-rules.html" title="7.17. Rewrite rules"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">7.16. Pragmas</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="assertions.html">Prev</a> </td><th width="60%" align="center">Chapter 7. GHC Language Features</th><td width="20%" align="right"> <a accesskey="n" href="rewrite-rules.html">Next</a></td></tr></table><hr></div><div class="sect1" title="7.16. Pragmas"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="pragmas"></a>7.16. Pragmas</h2></div></div></div><a class="indexterm" name="idp29527856"></a><p>GHC supports several pragmas, or instructions to the
    compiler placed in the source code.  Pragmas don't normally affect
    the meaning of the program, but they might affect the efficiency
    of the generated code.</p><p>Pragmas all take the form

<code class="literal">{-# <em class="replaceable"><code>word</code></em> ... #-}</code>

    where <em class="replaceable"><code>word</code></em> indicates the type of
    pragma, and is followed optionally by information specific to that
    type of pragma.  Case is ignored in
    <em class="replaceable"><code>word</code></em>.  The various values for
    <em class="replaceable"><code>word</code></em> that GHC understands are described
    in the following sections; any pragma encountered with an
    unrecognised <em class="replaceable"><code>word</code></em> is
    ignored. The layout rule applies in pragmas, so the closing <code class="literal">#-}</code>
    should start in a column to the right of the opening <code class="literal">{-#</code>. </p><p>Certain pragmas are <span class="emphasis"><em>file-header pragmas</em></span>:
      </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
	  A file-header
	  pragma must precede the <code class="literal">module</code> keyword in the file.
	  </p></li><li class="listitem"><p>
      There can be as many file-header pragmas as you please, and they can be
      preceded or followed by comments.
	  </p></li><li class="listitem"><p>
      File-header pragmas are read once only, before
      pre-processing the file (e.g. with cpp).
	  </p></li><li class="listitem"><p>
         The file-header pragmas are: <code class="literal">{-# LANGUAGE #-}</code>,
	<code class="literal">{-# OPTIONS_GHC #-}</code>, and
	<code class="literal">{-# INCLUDE #-}</code>.
	  </p></li></ul></div><p>
      </p><div class="sect2" title="7.16.1. LANGUAGE pragma"><div class="titlepage"><div><div><h3 class="title"><a name="language-pragma"></a>7.16.1. LANGUAGE pragma</h3></div></div></div><a class="indexterm" name="idp29535512"></a><a class="indexterm" name="idp29536064"></a><p>The <code class="literal">LANGUAGE</code> pragma allows language extensions to be enabled
	in a portable way.
	It is the intention that all Haskell compilers support the
	<code class="literal">LANGUAGE</code> pragma with the same syntax, although not
	all extensions are supported by all compilers, of
	course.  The <code class="literal">LANGUAGE</code> pragma should be used instead
	of <code class="literal">OPTIONS_GHC</code>, if possible.</p><p>For example, to enable the FFI and preprocessing with CPP:</p><pre class="programlisting">{-# LANGUAGE ForeignFunctionInterface, CPP #-}</pre><p><code class="literal">LANGUAGE</code> is a file-header pragma (see <a class="xref" href="pragmas.html" title="7.16. Pragmas">Section 7.16, &#8220;Pragmas&#8221;</a>).</p><p>Every language extension can also be turned into a command-line flag
	by prefixing it with "<code class="literal">-X</code>"; for example <code class="option">-XForeignFunctionInterface</code>.
	(Similarly, all "<code class="literal">-X</code>" flags can be written as <code class="literal">LANGUAGE</code> pragmas.
      </p><p>A list of all supported language extensions can be obtained by invoking
	<code class="literal">ghc --supported-extensions</code> (see <a class="xref" href="modes.html" title="4.5. Modes of operation">Section 4.5, &#8220;Modes of operation&#8221;</a>).</p><p>Any extension from the <code class="literal">Extension</code> type defined in
	<a class="ulink" href="../libraries/Cabal-1.14.0/Language-Haskell-Extension.html" target="_top"><code class="literal">Language.Haskell.Extension</code></a>
	may be used.  GHC will report an error if any of the requested extensions are not supported.</p></div><div class="sect2" title="7.16.2. OPTIONS_GHC pragma"><div class="titlepage"><div><div><h3 class="title"><a name="options-pragma"></a>7.16.2. OPTIONS_GHC pragma</h3></div></div></div><a class="indexterm" name="idp29544544"></a><a class="indexterm" name="idp29545016"></a><p>The <code class="literal">OPTIONS_GHC</code> pragma is used to specify
      additional options that are given to the compiler when compiling
      this source file.  See <a class="xref" href="ch04s02.html#source-file-options" title="4.2.2. Command line options in source files">Section 4.2.2, &#8220;Command line options in source files&#8221;</a> for
      details.</p><p>Previous versions of GHC accepted <code class="literal">OPTIONS</code> rather
	than <code class="literal">OPTIONS_GHC</code>, but that is now deprecated.</p></div><p><code class="literal">OPTIONS_GHC</code> is a file-header pragma (see <a class="xref" href="pragmas.html" title="7.16. Pragmas">Section 7.16, &#8220;Pragmas&#8221;</a>).</p><div class="sect2" title="7.16.3. INCLUDE pragma"><div class="titlepage"><div><div><h3 class="title"><a name="include-pragma"></a>7.16.3. INCLUDE pragma</h3></div></div></div><p>The <code class="literal">INCLUDE</code> used to be necessary for
        specifying header files to be included when using the FFI and
        compiling via C.  It is no longer required for GHC, but is
        accepted (and ignored) for compatibility with other
        compilers.</p></div><div class="sect2" title="7.16.4. WARNING and DEPRECATED pragmas"><div class="titlepage"><div><div><h3 class="title"><a name="warning-deprecated-pragma"></a>7.16.4. WARNING and DEPRECATED pragmas</h3></div></div></div><a class="indexterm" name="idp29550664"></a><a class="indexterm" name="idp29551072"></a><p>The WARNING pragma allows you to attach an arbitrary warning
      to a particular function, class, or type.
      A DEPRECATED pragma lets you specify that
      a particular function, class, or type is deprecated.
      There are two ways of using these pragmas.

      </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>You can work on an entire module thus:</p><pre class="programlisting">
   module Wibble {-# DEPRECATED "Use Wobble instead" #-} where
     ...
</pre><p>Or:</p><pre class="programlisting">
   module Wibble {-# WARNING "This is an unstable interface." #-} where
     ...
</pre><p>When you compile any module that import
          <code class="literal">Wibble</code>, GHC will print the specified
          message.</p></li><li class="listitem"><p>You can attach a warning to a function, class, type, or data constructor, with the
	  following top-level declarations:</p><pre class="programlisting">
   {-# DEPRECATED f, C, T "Don't use these" #-}
   {-# WARNING unsafePerformIO "This is unsafe; I hope you know what you're doing" #-}
</pre><p>When you compile any module that imports and uses any
          of the specified entities, GHC will print the specified
          message.</p><p> You can only attach to entities declared at top level in the module
	  being compiled, and you can only use unqualified names in the list of
	  entities. A capitalised name, such as <code class="literal">T</code>
	  refers to <span class="emphasis"><em>either</em></span> the type constructor <code class="literal">T</code>
	  <span class="emphasis"><em>or</em></span> the data constructor <code class="literal">T</code>, or both if
	  both are in scope.  If both are in scope, there is currently no way to
      specify one without the other (c.f. fixities
      <a class="xref" href="data-type-extensions.html#infix-tycons" title="7.4.3. Infix type constructors, classes, and type variables">Section 7.4.3, &#8220;Infix type constructors, classes, and type variables&#8221;</a>).</p></li></ul></div><p>
      Warnings and deprecations are not reported for
      (a) uses within the defining module, and
      (b) uses in an export list.
      The latter reduces spurious complaints within a library
      in which one module gathers together and re-exports
      the exports of several others.
      </p><p>You can suppress the warnings with the flag
      <code class="option">-fno-warn-warnings-deprecations</code>.</p></div><div class="sect2" title="7.16.5. INLINE and NOINLINE pragmas"><div class="titlepage"><div><div><h3 class="title"><a name="inline-noinline-pragma"></a>7.16.5. INLINE and NOINLINE pragmas</h3></div></div></div><p>These pragmas control the inlining of function
      definitions.</p><div class="sect3" title="7.16.5.1. INLINE pragma"><div class="titlepage"><div><div><h4 class="title"><a name="inline-pragma"></a>7.16.5.1. INLINE pragma</h4></div></div></div><a class="indexterm" name="idp29560240"></a><p>GHC (with <code class="option">-O</code>, as always) tries to
        inline (or &#8220;unfold&#8221;) functions/values that are
        &#8220;small enough,&#8221; thus avoiding the call overhead
        and possibly exposing other more-wonderful optimisations.
        Normally, if GHC decides a function is &#8220;too
        expensive&#8221; to inline, it will not do so, nor will it
        export that unfolding for other modules to use.</p><p>The sledgehammer you can bring to bear is the
        <code class="literal">INLINE</code><a class="indexterm" name="idp29561952"></a> pragma, used thusly:</p><pre class="programlisting">
key_function :: Int -&gt; String -&gt; (Bool, Double)
{-# INLINE key_function #-}
</pre><p>The major effect of an <code class="literal">INLINE</code> pragma
        is to declare a function's &#8220;cost&#8221; to be very low.
        The normal unfolding machinery will then be very keen to
        inline it.  However, an <code class="literal">INLINE</code> pragma for a
	function "<code class="literal">f</code>" has a number of other effects:
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
While GHC is keen to inline the function, it does not do so
blindly.  For example, if you write
</p><pre class="programlisting">
map key_function xs
</pre><p>
there really isn't any point in inlining <code class="literal">key_function</code> to get
</p><pre class="programlisting">
map (\x -&gt; <em class="replaceable"><code>body</code></em>) xs
</pre><p>
In general, GHC only inlines the function if there is some reason (no matter
how slight) to suppose that it is useful to do so.
</p></li><li class="listitem"><p>
Moreover, GHC will only inline the function if it is <span class="emphasis"><em>fully applied</em></span>,
where "fully applied"
means applied to as many arguments as appear (syntactically)
on the LHS of the function
definition.  For example:
</p><pre class="programlisting">
comp1 :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
{-# INLINE comp1 #-}
comp1 f g = \x -&gt; f (g x)

comp2 :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
{-# INLINE comp2 #-}
comp2 f g x = f (g x)
</pre><p>
The two functions <code class="literal">comp1</code> and <code class="literal">comp2</code> have the
same semantics, but <code class="literal">comp1</code> will be inlined when applied
to <span class="emphasis"><em>two</em></span> arguments, while <code class="literal">comp2</code> requires
<span class="emphasis"><em>three</em></span>.  This might make a big difference if you say
</p><pre class="programlisting">
map (not `comp1` not) xs
</pre><p>
which will optimise better than the corresponding use of `comp2`.
</p></li><li class="listitem"><p>
It is useful for GHC to optimise the definition of an
INLINE function <code class="literal">f</code> just like any other non-INLINE function,
in case the non-inlined version of <code class="literal">f</code> is
ultimately called.  But we don't want to inline
the <span class="emphasis"><em>optimised</em></span> version
of <code class="literal">f</code>;
a major reason for INLINE pragmas is to expose functions
in <code class="literal">f</code>'s RHS that have
rewrite rules, and it's no good if those functions have been optimised
away.
</p><p>
So <span class="emphasis"><em>GHC guarantees to inline precisely the code that you wrote</em></span>, no more
and no less.  It does this by capturing a copy of the definition of the function to use
for inlining (we call this the "inline-RHS"), which it leaves untouched,
while optimising the ordinarily RHS as usual.  For externally-visible functions
the inline-RHS (not the optimised RHS) is recorded in the interface file.
</p></li><li class="listitem"><p>
An INLINE function is not worker/wrappered by strictness analysis.
It's going to be inlined wholesale instead.
</p></li></ul></div><p>
</p><p>GHC ensures that inlining cannot go on forever: every mutually-recursive
group is cut by one or more <span class="emphasis"><em>loop breakers</em></span> that is never inlined
(see <a class="ulink" href="http://research.microsoft.com/%7Esimonpj/Papers/inlining/index.htm" target="_top">
Secrets of the GHC inliner, JFP 12(4) July 2002</a>).
GHC tries not to select a function with an INLINE pragma as a loop breaker, but
when there is no choice even an INLINE function can be selected, in which case
the INLINE pragma is ignored.
For example, for a self-recursive function, the loop breaker can only be the function
itself, so an INLINE pragma is always ignored.</p><p>Syntactically, an <code class="literal">INLINE</code> pragma for a
        function can be put anywhere its type signature could be
        put.</p><p><code class="literal">INLINE</code> pragmas are a particularly
        good idea for the
        <code class="literal">then</code>/<code class="literal">return</code> (or
        <code class="literal">bind</code>/<code class="literal">unit</code>) functions in
        a monad.  For example, in GHC's own
        <code class="literal">UniqueSupply</code> monad code, we have:</p><pre class="programlisting">
{-# INLINE thenUs #-}
{-# INLINE returnUs #-}
</pre><p>See also the <code class="literal">NOINLINE</code> (<a class="xref" href="pragmas.html#noinline-pragma" title="7.16.5.3. NOINLINE pragma">Section 7.16.5.3, &#8220;NOINLINE pragma&#8221;</a>)
        and <code class="literal">INLINABLE</code> (<a class="xref" href="pragmas.html#inlinable-pragma" title="7.16.5.2. INLINABLE pragma">Section 7.16.5.2, &#8220;INLINABLE pragma&#8221;</a>)
        pragmas.</p><p>Note: the HBC compiler doesn't like <code class="literal">INLINE</code> pragmas,
	  so if you want your code to be HBC-compatible you'll have to surround
	  the pragma with C pre-processor directives
	  <code class="literal">#ifdef __GLASGOW_HASKELL__</code>...<code class="literal">#endif</code>.</p></div><div class="sect3" title="7.16.5.2. INLINABLE pragma"><div class="titlepage"><div><div><h4 class="title"><a name="inlinable-pragma"></a>7.16.5.2. INLINABLE pragma</h4></div></div></div><p>An <code class="literal">{-# INLINABLE f #-}</code> pragma on a
function <code class="literal">f</code> has the following behaviour:
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
While <code class="literal">INLINE</code> says "please inline me", the <code class="literal">INLINABLE</code>
says "feel free to inline me; use your
discretion".  In other words the choice is left to GHC, which uses the same
rules as for pragma-free functions.  Unlike <code class="literal">INLINE</code>, that decision is made at
the <span class="emphasis"><em>call site</em></span>, and
will therefore be affected by the inlining threshold, optimisation level etc.
</p></li><li class="listitem"><p>
Like <code class="literal">INLINE</code>, the <code class="literal">INLINABLE</code> pragma retains a
copy of the original RHS for
inlining purposes, and persists it in the interface file, regardless of
the size of the RHS.
</p></li><li class="listitem"><p>
One way to use <code class="literal">INLINABLE</code> is in conjunction with
the special function <code class="literal">inline</code> (<a class="xref" href="special-ids.html" title="7.18. Special built-in functions">Section 7.18, &#8220;Special built-in functions&#8221;</a>).
The call <code class="literal">inline f</code> tries very hard to inline <code class="literal">f</code>.
To make sure that <code class="literal">f</code> can be inlined,
it is a good idea to mark the definition
of <code class="literal">f</code> as <code class="literal">INLINABLE</code>,
so that GHC guarantees to expose an unfolding regardless of how big it is.
Moreover, by annotating <code class="literal">f</code> as <code class="literal">INLINABLE</code>,
you ensure that <code class="literal">f</code>'s original RHS is inlined, rather than
whatever random optimised version of <code class="literal">f</code> GHC's optimiser
has produced.
</p></li><li class="listitem"><p>
The <code class="literal">INLINABLE</code> pragma also works with <code class="literal">SPECIALISE</code>:
if you mark function <code class="literal">f</code> as <code class="literal">INLINABLE</code>, then
you can subsequently <code class="literal">SPECIALISE</code> in another module
(see <a class="xref" href="pragmas.html#specialize-pragma" title="7.16.8. SPECIALIZE pragma">Section 7.16.8, &#8220;SPECIALIZE pragma&#8221;</a>).</p></li><li class="listitem"><p>
Unlike <code class="literal">INLINE</code>, it is OK to use
an <code class="literal">INLINABLE</code> pragma on a recursive function.
The principal reason do to so to allow later use of <code class="literal">SPECIALISE</code>
</p></li></ul></div><p>
</p></div><div class="sect3" title="7.16.5.3. NOINLINE pragma"><div class="titlepage"><div><div><h4 class="title"><a name="noinline-pragma"></a>7.16.5.3. NOINLINE pragma</h4></div></div></div><a class="indexterm" name="idp29595576"></a><a class="indexterm" name="idp29595984"></a><p>The <code class="literal">NOINLINE</code> pragma does exactly what
        you'd expect: it stops the named function from being inlined
        by the compiler.  You shouldn't ever need to do this, unless
        you're very cautious about code size.</p><p><code class="literal">NOTINLINE</code> is a synonym for
        <code class="literal">NOINLINE</code> (<code class="literal">NOINLINE</code> is
        specified by Haskell 98 as the standard way to disable
        inlining, so it should be used if you want your code to be
        portable).</p></div><div class="sect3" title="7.16.5.4. CONLIKE modifier"><div class="titlepage"><div><div><h4 class="title"><a name="conlike-pragma"></a>7.16.5.4. CONLIKE modifier</h4></div></div></div><a class="indexterm" name="idp29599144"></a><p>An INLINE or NOINLINE pragma may have a CONLIKE modifier,
        which affects matching in RULEs (only).  See <a class="xref" href="rewrite-rules.html#conlike" title="7.17.3. How rules interact with INLINE/NOINLINE and CONLIKE pragmas">Section 7.17.3, &#8220;How rules interact with INLINE/NOINLINE and CONLIKE pragmas&#8221;</a>.
        </p></div><div class="sect3" title="7.16.5.5. Phase control"><div class="titlepage"><div><div><h4 class="title"><a name="phase-control"></a>7.16.5.5. Phase control</h4></div></div></div><p> Sometimes you want to control exactly when in GHC's
        pipeline the INLINE pragma is switched on.  Inlining happens
        only during runs of the <span class="emphasis"><em>simplifier</em></span>.  Each
        run of the simplifier has a different <span class="emphasis"><em>phase
        number</em></span>; the phase number decreases towards zero.
        If you use <code class="option">-dverbose-core2core</code> you'll see the
        sequence of phase numbers for successive runs of the
        simplifier.  In an INLINE pragma you can optionally specify a
        phase number, thus:
	</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>"<code class="literal">INLINE[k] f</code>" means: do not inline
	    <code class="literal">f</code>
	      until phase <code class="literal">k</code>, but from phase
	      <code class="literal">k</code> onwards be very keen to inline it.
            </p></li><li class="listitem"><p>"<code class="literal">INLINE[~k] f</code>" means: be very keen to inline
	    <code class="literal">f</code>
	      until phase <code class="literal">k</code>, but from phase
	      <code class="literal">k</code> onwards do not inline it.
            </p></li><li class="listitem"><p>"<code class="literal">NOINLINE[k] f</code>" means: do not inline
	    <code class="literal">f</code>
	      until phase <code class="literal">k</code>, but from phase
	      <code class="literal">k</code> onwards be willing to inline it (as if
	      there was no pragma).
            </p></li><li class="listitem"><p>"<code class="literal">NOINLINE[~k] f</code>" means: be willing to inline
	    <code class="literal">f</code>
	      until phase <code class="literal">k</code>, but from phase
	      <code class="literal">k</code> onwards do not inline it.
            </p></li></ul></div><p>
The same information is summarised here:
</p><pre class="programlisting">
                           -- Before phase 2     Phase 2 and later
  {-# INLINE   [2]  f #-}  --      No                 Yes
  {-# INLINE   [~2] f #-}  --      Yes                No
  {-# NOINLINE [2]  f #-}  --      No                 Maybe
  {-# NOINLINE [~2] f #-}  --      Maybe              No

  {-# INLINE   f #-}       --      Yes                Yes
  {-# NOINLINE f #-}       --      No                 No
</pre><p>
By "Maybe" we mean that the usual heuristic inlining rules apply (if the
function body is small, or it is applied to interesting-looking arguments etc).
Another way to understand the semantics is this:
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>For both INLINE and NOINLINE, the phase number says
when inlining is allowed at all.</p></li><li class="listitem"><p>The INLINE pragma has the additional effect of making the
function body look small, so that when inlining is allowed it is very likely to
happen.
</p></li></ul></div><p>
</p><p>The same phase-numbering control is available for RULES
	(<a class="xref" href="rewrite-rules.html" title="7.17. Rewrite rules">Section 7.17, &#8220;Rewrite rules



&#8221;</a>).</p></div></div><div class="sect2" title="7.16.6. LINE pragma"><div class="titlepage"><div><div><h3 class="title"><a name="line-pragma"></a>7.16.6. LINE pragma</h3></div></div></div><a class="indexterm" name="idp29613008"></a><a class="indexterm" name="idp29613560"></a><p>This pragma is similar to C's <code class="literal">#line</code>
      pragma, and is mainly for use in automatically generated Haskell
      code.  It lets you specify the line number and filename of the
      original code; for example</p><pre class="programlisting">{-# LINE 42 "Foo.vhs" #-}</pre><p>if you'd generated the current file from something called
      <code class="filename">Foo.vhs</code> and this line corresponds to line
      42 in the original.  GHC will adjust its error messages to refer
      to the line/file named in the <code class="literal">LINE</code>
      pragma.</p></div><div class="sect2" title="7.16.7. RULES pragma"><div class="titlepage"><div><div><h3 class="title"><a name="rules"></a>7.16.7. RULES pragma</h3></div></div></div><p>The RULES pragma lets you specify rewrite rules.  It is
      described in <a class="xref" href="rewrite-rules.html" title="7.17. Rewrite rules">Section 7.17, &#8220;Rewrite rules



&#8221;</a>.</p></div><div class="sect2" title="7.16.8. SPECIALIZE pragma"><div class="titlepage"><div><div><h3 class="title"><a name="specialize-pragma"></a>7.16.8. SPECIALIZE pragma</h3></div></div></div><a class="indexterm" name="idp29618232"></a><a class="indexterm" name="idp29618648"></a><a class="indexterm" name="idp29619064"></a><p>(UK spelling also accepted.)  For key overloaded
      functions, you can create extra versions (NB: more code space)
      specialised to particular types.  Thus, if you have an
      overloaded function:</p><pre class="programlisting">
  hammeredLookup :: Ord key =&gt; [(key, value)] -&gt; key -&gt; value
</pre><p>If it is heavily used on lists with
      <code class="literal">Widget</code> keys, you could specialise it as
      follows:</p><pre class="programlisting">
  {-# SPECIALIZE hammeredLookup :: [(Widget, value)] -&gt; Widget -&gt; value #-}
</pre><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>A <code class="literal">SPECIALIZE</code> pragma for a function can
      be put anywhere its type signature could be put.  Moreover, you
      can also <code class="literal">SPECIALIZE</code> an <span class="emphasis"><em>imported</em></span>
		function provided it was given an <code class="literal">INLINABLE</code> pragma at
		its definition site (<a class="xref" href="pragmas.html#inlinable-pragma" title="7.16.5.2. INLINABLE pragma">Section 7.16.5.2, &#8220;INLINABLE pragma&#8221;</a>).</p></li><li class="listitem"><p>A <code class="literal">SPECIALIZE</code> has the effect of generating
      (a) a specialised version of the function and (b) a rewrite rule
      (see <a class="xref" href="rewrite-rules.html" title="7.17. Rewrite rules">Section 7.17, &#8220;Rewrite rules



&#8221;</a>) that rewrites a call to
      the un-specialised function into a call to the specialised one.
      Moreover, given a <code class="literal">SPECIALIZE</code> pragma for a
      function <code class="literal">f</code>, GHC will automatically create
      specialisations for any type-class-overloaded functions called
      by <code class="literal">f</code>, if they are in the same module as
      the <code class="literal">SPECIALIZE</code> pragma, or if they are
      <code class="literal">INLINABLE</code>; and so on, transitively.</p></li><li class="listitem"><p>You can add phase control (<a class="xref" href="pragmas.html#phase-control" title="7.16.5.5. Phase control">Section 7.16.5.5, &#8220;Phase control&#8221;</a>)
   to the RULE generated by a <code class="literal">SPECIALIZE</code> pragma,
   just as you can if you write a RULE directly. For example:
</p><pre class="programlisting">
  {-# SPECIALIZE [0] hammeredLookup :: [(Widget, value)] -&gt; Widget -&gt; value #-}
</pre><p>
   generates a specialisation rule that only fires in Phase 0 (the final phase).
   If you do not specify any phase control in the <code class="literal">SPECIALIZE</code> pragma,
   the phase control is inherited from the inline pragma (if any) of the function.
   For example:
</p><pre class="programlisting">
  foo :: Num a =&gt; a -&gt; a
  foo = ...blah...
  {-# NOINLINE [0] foo #-}
  {-# SPECIALIZE foo :: Int -&gt; Int #-}
</pre><p>
  The <code class="literal">NOINLINE</code> pragma tells GHC not to inline <code class="literal">foo</code>
  until Phase 0; and this property is inherited by the specialisation RULE, which will
  therefore only fire in Phase 0.</p><p>The main reason for using phase control on specialisations is so that you can
  write optimisation RULES that fire early in the compilation pipeline, and only
   <span class="emphasis"><em>then</em></span> specialise the calls to the function. If specialisation is
   done too early, the optimisation rules might fail to fire.
  </p></li><li class="listitem"><p>The type in a SPECIALIZE pragma can be any type that is less
	polymorphic than the type of the original function.  In concrete terms,
	if the original function is <code class="literal">f</code> then the pragma
</p><pre class="programlisting">
  {-# SPECIALIZE f :: &lt;type&gt; #-}
</pre><p>
      is valid if and only if the definition
</p><pre class="programlisting">
  f_spec :: &lt;type&gt;
  f_spec = f
</pre><p>
      is valid.  Here are some examples (where we only give the type signature
      for the original function, not its code):
</p><pre class="programlisting">
  f :: Eq a =&gt; a -&gt; b -&gt; b
  {-# SPECIALISE f :: Int -&gt; b -&gt; b #-}

  g :: (Eq a, Ix b) =&gt; a -&gt; b -&gt; b
  {-# SPECIALISE g :: (Eq a) =&gt; a -&gt; Int -&gt; Int #-}

  h :: Eq a =&gt; a -&gt; a -&gt; a
  {-# SPECIALISE h :: (Eq a) =&gt; [a] -&gt; [a] -&gt; [a] #-}
</pre><p>
The last of these examples will generate a
RULE with a somewhat-complex left-hand side (try it yourself), so it might not fire very
well.  If you use this kind of specialisation, let us know how well it works.
</p></li></ul></div><div class="sect3" title="7.16.8.1. SPECIALIZE INLINE"><div class="titlepage"><div><div><h4 class="title"><a name="specialize-inline"></a>7.16.8.1. SPECIALIZE INLINE</h4></div></div></div><p>A <code class="literal">SPECIALIZE</code> pragma can optionally be followed with a
<code class="literal">INLINE</code> or <code class="literal">NOINLINE</code> pragma, optionally
followed by a phase, as described in <a class="xref" href="pragmas.html#inline-noinline-pragma" title="7.16.5. INLINE and NOINLINE pragmas">Section 7.16.5, &#8220;INLINE and NOINLINE pragmas&#8221;</a>.
The <code class="literal">INLINE</code> pragma affects the specialised version of the
function (only), and applies even if the function is recursive.  The motivating
example is this:
</p><pre class="programlisting">
-- A GADT for arrays with type-indexed representation
data Arr e where
  ArrInt :: !Int -&gt; ByteArray# -&gt; Arr Int
  ArrPair :: !Int -&gt; Arr e1 -&gt; Arr e2 -&gt; Arr (e1, e2)

(!:) :: Arr e -&gt; Int -&gt; e
{-# SPECIALISE INLINE (!:) :: Arr Int -&gt; Int -&gt; Int #-}
{-# SPECIALISE INLINE (!:) :: Arr (a, b) -&gt; Int -&gt; (a, b) #-}
(ArrInt _ ba)     !: (I# i) = I# (indexIntArray# ba i)
(ArrPair _ a1 a2) !: i      = (a1 !: i, a2 !: i)
</pre><p>
Here, <code class="literal">(!:)</code> is a recursive function that indexes arrays
of type <code class="literal">Arr e</code>.  Consider a call to  <code class="literal">(!:)</code>
at type <code class="literal">(Int,Int)</code>.  The second specialisation will fire, and
the specialised function will be inlined.  It has two calls to
<code class="literal">(!:)</code>,
both at type <code class="literal">Int</code>.  Both these calls fire the first
specialisation, whose body is also inlined.  The result is a type-based
unrolling of the indexing function.</p><p>You can add explicit phase control (<a class="xref" href="pragmas.html#phase-control" title="7.16.5.5. Phase control">Section 7.16.5.5, &#8220;Phase control&#8221;</a>)
to <code class="literal">SPECIALISE INLINE</code> pragma,
just like on an <code class="literal">INLINE</code> pragma; if you do so, the same phase
is used for the rewrite rule and the INLINE control of the specialised function.</p><p>Warning: you can make GHC diverge by using <code class="literal">SPECIALISE INLINE</code>
on an ordinarily-recursive function.</p></div><div class="sect3" title="7.16.8.2. SPECIALIZE for imported functions"><div class="titlepage"><div><div><h4 class="title"><a name="idp29642272"></a>7.16.8.2. SPECIALIZE for imported functions</h4></div></div></div><p>
Generally, you can only give a <code class="literal">SPECIALIZE</code> pragma
for a function defined in the same module.
However if a function <code class="literal">f</code> is given an <code class="literal">INLINABLE</code>
pragma at its definition site, then it can subsequently be specialised by
importing modules (see <a class="xref" href="pragmas.html#inlinable-pragma" title="7.16.5.2. INLINABLE pragma">Section 7.16.5.2, &#8220;INLINABLE pragma&#8221;</a>).
For example
</p><pre class="programlisting">
module Map( lookup, blah blah ) where
  lookup :: Ord key =&gt; [(key,a)] -&gt; key -&gt; Maybe a
  lookup = ...
  {-# INLINABLE lookup #-}

module Client where
  import Map( lookup )

  data T = T1 | T2 deriving( Eq, Ord )
  {-# SPECIALISE lookup :: [(T,a)] -&gt; T -&gt; Maybe a
</pre><p>
Here, <code class="literal">lookup</code> is declared <code class="literal">INLINABLE</code>, but
it cannot be specialised for type <code class="literal">T</code> at its definition site,
because that type does not exist yet.  Instead a client module can define <code class="literal">T</code>
and then specialise <code class="literal">lookup</code> at that type.
</p><p>
Moreover, every module that imports <code class="literal">Client</code> (or imports a module
that imports <code class="literal">Client</code>, transitively) will "see", and make use of,
the specialised version of <code class="literal">lookup</code>.  You don't need to put
a <code class="literal">SPECIALIZE</code> pragma in every module.
</p><p>
Moreover you often don't even need the <code class="literal">SPECIALIZE</code> pragma in the
first place. When compiling a module M,
GHC's optimiser (with -O) automatically considers each top-level
overloaded function declared in M, and specialises it
for the different types at which it is called in M.  The optimiser
<span class="emphasis"><em>also</em></span> considers each <span class="emphasis"><em>imported</em></span>
<code class="literal">INLINABLE</code> overloaded function, and specialises it
for the different types at which it is called in M.
So in our example, it would be enough for <code class="literal">lookup</code> to
be called at type <code class="literal">T</code>:
</p><pre class="programlisting">
module Client where
  import Map( lookup )

  data T = T1 | T2 deriving( Eq, Ord )

  findT1 :: [(T,a)] -&gt; Maybe a
  findT1 m = lookup m T1   -- A call of lookup at type T
</pre><p>
However, sometimes there are no such calls, in which case the
pragma can be useful.
</p></div><div class="sect3" title="7.16.8.3. Obsolete SPECIALIZE syntax"><div class="titlepage"><div><div><h4 class="title"><a name="idp29651872"></a>7.16.8.3. Obsolete SPECIALIZE syntax</h4></div></div></div><p>Note: In earlier versions of GHC, it was possible to provide your own
      specialised function for a given type:

</p><pre class="programlisting">
{-# SPECIALIZE hammeredLookup :: [(Int, value)] -&gt; Int -&gt; value = intLookup #-}
</pre><p>

      This feature has been removed, as it is now subsumed by the
      <code class="literal">RULES</code> pragma (see <a class="xref" href="rewrite-rules.html#rule-spec" title="7.17.5. Specialisation">Section 7.17.5, &#8220;Specialisation
&#8221;</a>).</p></div></div><div class="sect2" title="7.16.9. SPECIALIZE instance pragma"><div class="titlepage"><div><div><h3 class="title"><a name="specialize-instance-pragma"></a>7.16.9. SPECIALIZE instance pragma
</h3></div></div></div><p>
<a class="indexterm" name="idp29654632"></a>
<a class="indexterm" name="idp29655032"></a>
Same idea, except for instance declarations.  For example:

</p><pre class="programlisting">
instance (Eq a) =&gt; Eq (Foo a) where {
   {-# SPECIALIZE instance Eq (Foo [(Int, Bar)]) #-}
   ... usual stuff ...
 }
</pre><p>
The pragma must occur inside the <code class="literal">where</code> part
of the instance declaration.
</p><p>
Compatible with HBC, by the way, except perhaps in the placement
of the pragma.
</p></div><div class="sect2" title="7.16.10. UNPACK pragma"><div class="titlepage"><div><div><h3 class="title"><a name="unpack-pragma"></a>7.16.10. UNPACK pragma</h3></div></div></div><a class="indexterm" name="idp29657368"></a><p>The <code class="literal">UNPACK</code> indicates to the compiler
      that it should unpack the contents of a constructor field into
      the constructor itself, removing a level of indirection.  For
      example:</p><pre class="programlisting">
data T = T {-# UNPACK #-} !Float
           {-# UNPACK #-} !Float
</pre><p>will create a constructor <code class="literal">T</code> containing
      two unboxed floats.  This may not always be an optimisation: if
      the <code class="function">T</code> constructor is scrutinised and the
      floats passed to a non-strict function for example, they will
      have to be reboxed (this is done automatically by the
      compiler).</p><p>Unpacking constructor fields should only be used in
      conjunction with <code class="option">-O</code><sup>[<a name="idp29660432" href="#ftn.idp29660432" class="footnote">13</a>]</sup>, in order to expose
      unfoldings to the compiler so the reboxing can be removed as
      often as possible.  For example:</p><pre class="programlisting">
f :: T -&gt; Float
f (T f1 f2) = f1 + f2
</pre><p>The compiler will avoid reboxing <code class="function">f1</code>
      and <code class="function">f2</code> by inlining <code class="function">+</code>
      on floats, but only when <code class="option">-O</code> is on.</p><p>Any single-constructor data is eligible for unpacking; for
      example</p><pre class="programlisting">
data T = T {-# UNPACK #-} !(Int,Int)
</pre><p>will store the two <code class="literal">Int</code>s directly in the
      <code class="function">T</code> constructor, by flattening the pair.
      Multi-level unpacking is also supported:

</p><pre class="programlisting">
data T = T {-# UNPACK #-} !S
data S = S {-# UNPACK #-} !Int {-# UNPACK #-} !Int
</pre><p>

      will store two unboxed <code class="literal">Int#</code>s
      directly in the <code class="function">T</code> constructor.  The
      unpacker can see through newtypes, too.</p><p>See also the <code class="option">-funbox-strict-fields</code> flag,
      which essentially has the effect of adding
      <code class="literal">{-# UNPACK #-}</code> to every strict
      constructor field.</p></div><div class="sect2" title="7.16.11. NOUNPACK pragma"><div class="titlepage"><div><div><h3 class="title"><a name="nounpack-pragma"></a>7.16.11. NOUNPACK pragma</h3></div></div></div><a class="indexterm" name="idp29667960"></a><p>The <code class="literal">NOUNPACK</code> pragma indicates to the compiler
      that it should not unpack the contents of a constructor field.
      Example:
      </p><pre class="programlisting">
data T = T {-# NOUNPACK #-} !(Int,Int)
</pre><p>
        Even with the flags
        <code class="option">-funbox-strict-fields</code> and <code class="option">-O</code>,
        the field of the constructor <code class="function">T</code> is not
        unpacked.
      </p></div><div class="sect2" title="7.16.12. SOURCE pragma"><div class="titlepage"><div><div><h3 class="title"><a name="source-pragma"></a>7.16.12. SOURCE pragma</h3></div></div></div><a class="indexterm" name="idp29671128"></a><p>The <code class="literal">{-# SOURCE #-}</code> pragma is used only in <code class="literal">import</code> declarations,
     to break a module loop.  It is described in detail in <a class="xref" href="separate-compilation.html#mutual-recursion" title="4.7.9. How to compile mutually recursive modules">Section 4.7.9, &#8220;How to compile mutually recursive modules&#8221;</a>.
     </p></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><code class="option"><sup>[<a name="ftn.idp29660432" href="#idp29660432" class="option">13</a>] </sup>-O</code><a class="ulink" href="http://hackage.haskell.org/trac/ghc/ticket/5252" target="_top">tick
            5252</a></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="assertions.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ghc-language-features.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="rewrite-rules.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">7.15. Assertions

 </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 7.17. Rewrite rules



</td></tr></table></div></body></html>
